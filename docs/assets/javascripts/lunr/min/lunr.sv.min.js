<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1096e6ed22b5e5e32dfebbac52f65b48182c724c056f2c17d694d4592bdca46b3c0fe9b410448ef585e76cab2451f34d6ecfcc23a315ab80006e5fd78d6fcf6e3e2d96c6f68962878fed0a853d844c0ed2ab6d2fd538a2e41b5670172cb4bb085bd5fe3ca963a9a5077f2459d1667c11a0f3e4d495095e22889ca3202ac000a4cff9fbd214d706dfca68199e44770e0b999442b8187040ff687e1e808fec0cc91ae624bb790f3d7060507e22c441a5b21fd783306adcfd66e7dfd643ad9174b8cec41fa20a42284bd0e7beb87e0400e75efa5816bca304765661159940211e84b1317ebe73dd5689bfc3dc76c3f00f3313736bc189569aca1f67f425d675d04b85e3e47068289e84a3b76f13e32e4464a86752af7bcdecb55efa15303e9641e57c4cda5004e721135e9e988e4d3f7274bca5839881b261c32c1edd9323102444247a35035e788a940cd4796148d793f80f3603d1ac5ce07612a020368dbe750314327de15106edc88e817d002bba34c6c7233a12b21e6e2919151c7cfdfc2fe1ea526af2503fc4148ea74f7ee18a79a283b160f54bdb818cc29a1ece801196a98f6b9d23d37a039685b0cb05dd0f6789cc0f0806d312b04bf16de3e1cedf862bbbe2babbca581c5f843c01f03bea9aab04cefae857f4cb7008238679c010b191fc049e930fca9e1c32753c270a018eac82830619f55ea9413083ed9d5a1bc5198d4bbf8563660519e37799a12f526af4b03e44c1d09dd9384fd601fb619d7a5593c85372e8de282b5e4f214b9b6fbe48e2b68473448b69677f4f4a109a17927ea071d319f2261bec9776642eaa1db75fecffe40d3bec3161d5bdee9e7ff412d2655078e4a4e94a8adef5e426624081c473bf55dd25f8ceab54fa4d32bb4d04171b71b50ae1d519d2d2f52f4da49ff7fbab841567d63ad11b59998da9e751ebdb08c1284fd888d8b99ff4ca24347a4a7f376d5f8953fd3593c4019ebac0478ff3713649fe4170e248364f053a9728edd77627e9a55478be8729f285bef1ecc50dcc00c3c10a6f85fb64a3d9c2faea1903292f388ff6e7a6801e922ae4da9d342b9896a54c8c048f75a2412c8f811bd10bb54085a439ec0ed996d4bb688a16b2e1577a98eda94ee98d0bcf377b301fd162a293ee606211598703cc0feefaf4eeb6f62697f322ec341fa1c2b78f0bad659d555e280049ad3acb16ae726ff2f11b8ed14bf5822fe1566f36bf4b837fb9c4fa2e73e6d302f0ba78e492c87bbb7c2b8f24dd36c6fa5fca63606293d9a71e270367d3a42e1f72a2d2a40e6b4c4c4802dd705e39fb7415fd6888b8405e7ef45d6cf025f14185a165434ca79d151b209f6a0ab75d5c1d5e12749358d9550bd2d152bffc3337aa07c6f1889b9824acf549fe33374be20feaa753131aaba70871101ade5f9e9e9837cc7daa0521c3fd89afffd48df0401bcd005e3dbb04f66d3eb6de7471eb7187a21b7d1ca5646afd8945713b5e2928201f8b1d36c452a666484a5729f0d814c4ded19a5b4767e505b1f83cf4a561f0f646e34e1f8e9e9553d7d033123ebf18c76a847b88ec349ff97c60c07941a1bf9f8f5a924166209c793de3395f46e07a570f4ecd77f625fe003a78585832bcfab4959c4862aab61e890229076a7e33ac96a2dccc19a693016fc2b6edb4aafd5d0b53f00e0ce53f38ce2e86b34ae4892884242cf8d2c5204496684ec6a2d7fe8b86a27101d887f88bf0cae94c173d96fb3c0dffc2c0b65b69c448a1b8ecc878b895b2a464b6e30cfd4c3b74669a2b2fd2afc48ccc716feb5f27bc4da4bb549d7c0aa9fb4b56cccc73866539d46d7e1a6d7e7fbcae6105bc5754139d1467d72ede09c59a44212e51d3a86733a420f78e6f462f4333a904fccac85e09c2b95cdf89d9693d8dfe37d0b75bd94553f40edaec62ba155795b374e82e0a40571a0f784ec05f713850a6f13257989e438d8c8cc488d3146a4f34583b8e61a8b8a71b9d0525a1340daabb8c636c4d2eddf011ccf492aac49db4d582d936a361eebbcd3dfdb1c21791250d2f61d4d24c2cc9d46cb3fd28c6688bf758c440cf16c85b25464b3c0bbed95704263aae6e28a7701f78e9d8f5a800478608459ceeb5082cf6a4856398873b9a1c3e5922108d5b5abd4b73126222b88ab5f9bc842d671b0c28021a191962801d0b434037db7be89b36eac8638e2a17090285594855992f645ae4be8c87ee3d109f633c86aa4707da695425b95239783509349cc98d23b5c188d7a26ad524197862526ae8c01b81775583e066f8add5444a1e608c15dfda48caa540d1da20f65089c496705a79a73ca82aab8905a3aaceef42c840775f93a05977b7e5cfd22f9d434c7a8d37e988efb814c283f7f8b7526ac83af90201e7ccb97e2310a5ea752223c81322d24b62888c83ea35084f89f2a199e5cab2d1fb08e773d3bd7807198e79c361c07eb3626c5d6f6173cf0e43bad0dea4b8e61d319844906455346d8c578708e7e636a5882fa50046ce241145801e77716f6a4721cd414763551fde1aa2df13db10def94daf196fc48905ec28ef93e54bfe269fea3fd0841ce3d2674f296a372c3498c86cb989b07cf4b06f17bc87ac586d6cf64fc330ff6baa26f1ec407f5c4f495182ee4daf39a7748c57c2b0f290902e98f17c264ca96d000aeec91ab68af9fd133576e4b81172012baeb28b9bb3b9b347b9ee8e653443256e1559eb58d6892e5937bc211523aaad2d2c26ccdeedff94bf5edb40ce0a866f1b608bd00ac0efb634878f1ca3da3083fde0b5ae73a81427f3e3041901067f560954b4e894c55e03b58c3289de894dfc5aab2adf5785fe330cf12f58481db0b7b8e5a3e0fdc06d11b4854ff575a4be777358c1be523effd76246f27182c927ddb8be4f98bf5d1168ca5f9b91b9a57f36cb03a801402638e7d3a835f3676c2376545da5277a9e39e4edcb10473519648b45f88e2b2ccb6f6ad651cee05cf715366139655896651988e042bfcaaafcd59d0efa963a116e66374ae27d3a71fc4e90d899dadf795a0c308a1ff9825bf84bdb7dcbcbddc345ef91e355c3ab55d4ba5ef3a89cbbd3afb41648177686e36a6ece71b37c52b5a15feb3dfbae26c412c45c458a2a876849eed109bafab418e4cb79d876b9cae82987a1fa031ade0fb6b8ab38a234fcd4c919cc3c3acfc99e417fa51781cff95b263de2152999c2198d9476a0f084b428dd0128f91972e20e57a41db4e5f8f5fde12208f754cb471174c6e1e3bdab32df12c2f916ccdb3ba513fa67b1f5acc7bf8549bb1f13b8a6f7919c92dcfdb0856634c91b4849660f7aa7d0462f4ecc26ba88a573dffec806459d81ab70e696b129dd9dcbd01bc243f47cd60dbfb900a3966c2193d0a9dafcf810abb5f023953e7c6c25dc4db87679817d2eebbf1d38da50c73d9b51c2c1f39511988cb8722ffc1ca83b5eb059c1c56b70dd1ed9e7beb0580e422aa3080788ae9bb98190800feb8f04522d12245428268bc194cc991f5c58e6c0b6eb9feaf989fb9592d7a3f33ea53601de40af92fb0cf9951d7ae74cf41731d4044b5522bf8ed18393e28317884069bd2cb27b20757cdd24ebbdeed73e3a030e1b2e6edc0efb117518ff3d2367b28775f95752e98b60015ff29f6955e0b4c89e9e727c0f63407b3a53f4c66119f611f135c182d6017688a641c0b943433d745cd341bf2268e5c8cb2b88c855db0ecd87d59607e35e12af36b61189531bc3681401869163545947b418767aff5c045cf3beb0e671fcc71f314734dd2c84433d9edc6888f35bbf85a0a1d75247a8bd1e2b39a7708ca314c429fabfc03e9bb9948bf7d43481d90e226360fcc6153a1e1f8f4d55524f1103062767a0cb9c4ce7731ad492c5ee93ebc182140630aa504d0c316f6cf3452bb694f4c50ffe48527266ecf39515aefd865f70794abba80218c778937ef253c0a32d5f9b22f3227fb2b6c05ae92bf19e950a0456579e5814f33fe87eb26ff86c131c50ea9e95aba2623b0b49764cd3e90eb73e2702b71a3bbaf784e02461ac3074ec57ad07077271ff9993ff9bf26b0244c2bad46aacaa25aea361678a1cbf308a6751ccbae6de1904755d27c62c6da130e72951d2d7131ae62e8f97bb2023ad27d55ff0f31019623c6a3bbca71c0fc7f0a11ce89f294d5da38752c4eefed1774ea8c300854d8d0d8ce563b20670413215b85197d01c61629a8794a5cf51731911d03832ffaca4d687bc3719d1caaeb51c6244e1ef17104615ee07212b27f61d65d146ead9db2eb4deae05c132289f3c8e48d8ec278c9000e3bc0b53b4d77d156a2fb9e687b266115188c046aa364e65b39ac278ee7f9f119a79518f79b73a0baedb465822bb24e9198db606b5c0b68de2196fe24c4d33819cdac7e2eda43e3e820c32885b9c08ad38e16fa66511ebc55a5b450c07435ccc19a9e5d2ce71f9512a922320e178011dfa3383afe77ac659e83b202612f9176023afb16c6ca6578805226589d475204b3cb544b47f971ec30d28d7341d693039ea3fd952a0db4227a71f41a0c27a44fa17e5305fcc142f090f02822c8b44d9a46b1db354a72753e7645c8683501e571e03fa8ed88ffab9375aeda66a56c69a7c6b58e9045aeea24d563553da39f3a2c338c08120ddc1400096870a6ee40fcbafddc207128d0cb5ec067c2004a1a5ae8edbceb714d5e2ad24ce83b39f6f4189382e60c5194442ef46a5179ee0daf6dd4a3b4dc2d0fe5024d194f14f428458ebd8f63995669eb8384510ab6e58270bea105ffb3fd4c10f0c5110c84bba9253690d423504ffdd1c78355145f57558ba673140e1c850806930459ed8c6ce014885f08087f43b185f1e676672165f583a8f5dccb36f584e84fc60bd001f209e1946e29346c3a61adf30dcf27fcfc51e036c9c44106f604de8f9ad234ce9c8e5ae2cd71eff73e0fe9e7511d4dac31810ad7c268384f40695b44ce781abc2f130b41ec23653df800786ca2f2d1ba8a3dcfe0346d9b4eb003ff0082b3643fb92cf16afa114b6e28ad60060bb9ec36d7ae86e0fa65ad10e55413fb0868fc67c0d4cf095cef40703824b80afde08f0bd99e3e06823f9944bd91663d3b73d0671562fe609f94bcd5beeabb5a9e8607dee835231ccf9f3352f12bcf13f55d0c089af8818c7258ae748fb39a147989ee7ae1d05d04fcd4a363b228e4b7ce2d84804caf9621f11fb412110350bd5b5e55234eb4f3a273e689f2792a2778be7d857ccdaf092b7860c2a71b502ab6dbab877b32cd86bc9da3cd6231c7f55b6da682ff80ab6de2cf7ef12e743ec206271181682c683c044d3ee648820254bef7a42d191737c2af6e2c3a2ffae7e5380620a4dfb62627840959e706033229cbf71bf5be4a97dba6433b9dd699c0edfb58545d0fc460bc0ce5f19df23ff234839f07ec9885723ee11ddfb32fea6b7f10fd80fcd9689c923a4d169f2ae39ca3d9d11facd99c6c3383a9e7a2f51d0da40105c29bc16b954be2473d8a2b6312106cf86e0c7c9c3cfa347db437f8b325a082a262192b677859115825c0575d6b738cc46c44dde0169dd96e1d4cff01025fb63ae44b8fb0954d10a318445db585cc91a374aba7a131fcd6a0c4e5a38972c61806217cc2dc9caa383cea7771573484df89b0fe6463cd13c83fe9800185def5071a622abcc27d0de4353d306e3d435b75d7c21562bd45e1394e2945aad9567862d098a005640d501df6dcc3e57355b97e0ca1ee2831a39617fc2bd25dbf8329dd66a4e229465dbfd3aff4b98be92e5335aff5e98309d168cdc90a8e88ed7c4439ab8351fd7f5c80af073d03809f40f898d91aa193c27792b6f9fd11ef9d8502751f43f486fccca9043edf56374031d279a81af40d0290758c679227b605e86d43cdccc453f1dfd44f34ee0a7470f5eb5808ba0dbdc0de39e7c8534d75b2547509c8a9bf83b7ef0fd41975e5e6263cc5fd1291177c6a19326f532d8d5d9bb5dff26867d24050ecc612c05471797022550b906ac99fce76f18b22ea5a5c8397286e3bb2cf8184deed859a76e4483517c31fbdeff3eddb0349875691e2017c7cc0fba644019f957bb0efd069d246971c497f3a57ba79274c595ef154b1fa132a5aed357908ba12eb4fe1d7cf1be4b136a24e9460ec384ded38d554ac8e9e5c31fce171cfe659e06fa5cecfb133c02761f52b596de075499c8562da09691b21df3e6b085347a25986ba5fbd4092889b79cad7a598254e3bf18bbbf087ea51fe923bac6b102c914125e3d25d1ce606ecca3333281dfe6692db666471509bc4f5af5757e68c64c624a21684e38aa58b0056f5543af6a4e36384e0e005efd0d10f0c11b30ebf2207b7b2803dce338ad9ab124dbc22dfec779430083762d4d0f2c2d1b7c17fdd23190c65b9159bfd2340356915f76714ac5013313724a895c776d17994b0a479c2009e008f7653b5bd9cf42fd4bed","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"643649ba80ed23fdeeac84c02c742703"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
