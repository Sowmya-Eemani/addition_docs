<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a9bc1e75ddda5b438af1b83471f3d91ebc17243c8569872d683f8c31aa547142f57a6a6224c39935c848978c9ff892dd6cd736102332fe3c7ca712c8daf08de4b06f67343783dc13ed213589b081febc9c49a28063d7eac59b893d6dcaaf14a58ec4fd13dd45fcb23756c29ae12115d016439e441f4f6fd2aca82fa88c91c3ea679681f84a943a757e19777f0d12d650b8a09e6198e2c1f785ede9b45a0d55ce7993cde71fd3aad9f972d8df28a95abd54ff0aedd2a2a894bdac5f95d96d4787ec89e64f639e18f0d76c506e85206e0f3e4332040c8c3f344afdab07671e5160c964b4c1431f0f0932c09a9ab285984cd2e43e7c15d764b38c522b44c1461b692eefa7e1639839f659d43d8a481bf2b0b6a10ba4ed98c01a66527ed390ca3a416c2eb1e84743c5db4cafbbfce5bfe8ff840be72ffaa06ae8b791f442d4350afd466a6183a1b7d8812b4514fd053fd04f6613d7c006ea255ecd9dc82fe7f4857b1ed9287528198f29fc9b910485f15367db07bc995580618e1eb75002d020e044b495d5159f5fc3a37373b0cde5c1d7eb1f10151a9ea519e1115bd56123638bf0c56a2788f733c75148b9ab0b1233b0fcfab6ee1f4a09b9a159225c0cfaa681c64cd541d6e8a0896f558c72298cde9f942b99b7531197f4767175fa39651983a60ec81bf2b8b22690eb284413545f3b7672470a45f26bd340a8542dfe4f2db536c94c23d9792e384555205219630eaed69eef82748089c41c35f99e24b2bdf2d28615383668d16ce652000e37af6c93503b4b0fbad431e6892d43b6a6e42f3e31937eff16c06243e7d329c9ce9ede66b37b769a10817bd6e537d63ec18405819d02d3c3cabce7979664dd7f47498dac818109850b29f21a4c6327e410cb3008022eaaf9c30381cc69f8480ef682a1280fedfb6418211bee20eb631f6b4e60c63e44a36e9d85328aff3223782cef243dead9a2aac280be6c3e1dedf78bc662cc58b1268b4a31ccaba987b07846f51c8f582fd1268ccbf67299bf90de9c712636734554c7ee14797bd0d83cb384f0174d70e12bc9ebeee97da36efd22b221be1f1cfb0c9b454c3475f41d96939abd8c07da5b1b6dc076017f9d18b8e60c9116ef35515b71249ea1ce89b84170bcc6f61dcf3b96c2cf921a1d4eefdc2f92e7b53863c6df85c7870aa41b870e82e1ae3d5e2b51dcb57f0d3852e9095ab2df40e057aca67ef1ce21c386288d27f321c62787a82edaa0d3a355f4394c0683efff8dd53193294c40a29ddf914805c7826c83f992da58794e741bd49b5414de692f8cadd6dea054563ee0cad05a1c164ef54a75a294f6740f6d2d5c1bd552ca81b966d2ac2fea2b8a3fecadcb706b24e983ae11e9335007a629fcfe0f16514ac03482000b0e5e14b4735caea794e26acf077a302967c5d528d537cd1cd756eea70c3ffce57e23c170c0ec1958e71c5e9f6d933dd5de8228b15da05916955c8c5dead750a85f959441fc7c4b20ed308f0838fecebfd377a05033752016745eba441624349c6cc148684d200663c85343c51fb252cab51f1f03b4d398aac663fcafe9f94ca631b6b5eaac9a6cf4bfe4f4ea2c59fd5b3f00b53c1603fdab6c97d01f71ebbb9593a8b05d6e3d14b8d73a1454d12ca1e2cdde727c9ca179145528a512cd27678ea90e5c5b5607b1eee6d24b98dacdaffcc13d061682f470f80c16e237a7c02a73f18c69506a232c0b71a731b46dca86f0b74394f28a5457d5a22f5443d537b9bc8e389edef5afdcb3cdb333bfd9afbc6ac833170c45b62e5e98c00e8afd89222c784f31c1f2f6b8bbd1aa98b685b9dbd382e6b5b0c8b1b91849c419af63d8705922253aee0e80991ecee52910a5ab901b6ae6a47853b2ac768eee89b434c963796ab17d2c02430d392e594519af5c65d9c6366ffff3c926cda46335069d8cbfea6d300b5ef2e4aafd9b0ee03dedafb54757ec8e88d3c81fc7ae10e686c46e14a1bbee20e88b8767b27aa84244ff5187fe18d3309312eb569d8a6b984049922db642252e74a600884bd98cc601eb4130609572efbacd5dfe3432059a84e6d276cbc6df2d0db415ab25ac2dd8fbf3bb8276d0337235328466324dc5b1967ffc9a6d6f251cf04dad1ced91ca75d98592197484ad6c439062e441e238d1dc9f7237ce2f7be925f96cf9e7d8481beb821a43376c1cd714ac7b25ea3e21373b9622618e6354467590d096b40f6e3d0191784c19b40f50d94a4dde05d55da6a2f1ca1cdce0bdeb7ea8afdfd3f2df617d4be63d6cf0ebecfbe9d940a5d5690c2ed32b9ce55469bb734e31dfcd12f0efda49908e2f9819218b2559f66c01a2f29ea2c1a4ee5904e4af793229146a02012931edfae15367f447a46be042852a2ef0bbbbf0de11c98dc98a926c02d29d2f16d959f084450e7cebf44b2cfeb4bf41e1ee28aefa93708fcd24de8a8b3ea43e759317a6fae99b693d6e6cb97c65cffe789006ac4ec682c2b009b95908a3c01e68b35b033adcb98b7756131b943f67bc4a6564f3bc21960898745af83b086d7da7279e692a0c10f52e4d3c8b89fba5c4dfea1f0d1335ca266bc00bcb133fbd30dc2af4d3beb190b7522d932e55d3ab4203915ef27e0923f84dc0e23eeb10f012dd8998a2b45bc773934fb588c9293731525e7a8c0793537820e3c4c7fea55a94ecf66edaf24ff83d5878fc6a6d7392e3369a97dce10beeccd08bc5c62d905656a9dee12c2773576982a9efd775ef3b4381c456f87818248f102fa17c4db9a96ed147c466427fe7e4dcea37264978717d78c627e2c0cea07f32daa3e53d35f0eba3d808e8c9c375a7d3d4f5cebc33335c3018fe3f8604b3f2e1b52be6cdebccd3a43a7117ab1322dcf7f0eaf5473254d5bb91aebf1158905454ab49489488cd77fdc401ff5ac16d2c258e7c40e5fd5a6b21af974e5d9ebaf53c51afaf35879dc4db056516811b307a8addb5c74395c8c455cdb7c7c1d2e6e452676e1560869bea0ce734d9be93812fd33ad28c8fdca9a7125a99f3aca6b59723c8edfd22980ccacd72e5a96679cf9a36fa3b10d92769d0ecefac6393f4df6ad633d92c46aa365c6290ad6a814dafd091992b597a6f36c8b4a0b735daa64c596b87a9f57aa71f00a8a5c016599672a9435de4a7aba94d0f7da156dcb4eba6787668e9332ae1038133f7fc8d2b54322176f631091ebdcf8c64382a8db1cceb941884c8696f1d1d93843724dec3dce96cfd4e723f7029146d7d60108a1cd83108ce35f80346dff39a7da5f1a6508247d2c69089ea9657f324d8d5fd4a9988b98dc64a368d16272597ea397f48d5f6a759a2ef8e2d07dfc91bdd1a4aaf1f06b2a940e0da3db650dac4ada15a72a92fd825a275bd0bf12653a1be5df48ac12e830fc8a6083d0f9aaa39423d4f992d15b8276a6742fac4030e5b780a5d99ce7a30c1249cc3fc27e88eab9a207906eee2f8685efab68a6f5be08f7d7e92662ca46ebf93c34209b3faffd05cedc3cb787825bff7e81478a0e5c46547b850fcc7dd8ae3102b4ae5c0ca4907c4b0f14458cfc29adb1ae61a61eac78e63dc0bc6c23e3e1bb487f0db94241b6eca2c85cee9d24409c8f828bcf7cef591e46f4000c96e6f7d165d18e2879378d94ab1d702c9532466875da25dcbc0a5f442cb0975de969939150ecef86e0b9f104229216861627ab6dfd5ffe2ecaf099133d54e858ec2ee0d6a02b5860670a3fd2253cc5a238ff89b27a552f4d469f8f639c4e555a4babbc5c8cbee80fe4d032617c07e0a3059beb4ca67f52ec5ab7e1ca54939fe34eb16707f561a43676a658b8c716f32cd5d19a0f77627b0c1c298f58f7fd816c64bb43ce944430b1357f68708cc3ba7d50150f3e7b7ba82bb866e665239f78d2a37c222ae613af52442dd0b8b87ace33d20040b2ea27512eac5f0d4a270d65065db37734653e339331605d72b9407bde8e10f9928bffdc017aca9eb4f9bc376c9099b963e2ed6c75fd8bb442dc4016a8e59beb05fecce4d5a64910ecf90378cf6b95713c0f8d3ddba06dd990de38bfb29f8774c64378153fb0a52c2560bb8f13d109c356ff648b9a0bf29f8390add1f263f75a900b50efc66f39b247fc29ac3e9ec5d88ded639c51ffb528ff65767c06f86ab198b40ee5d08fd3bdb94f5ddd9a513c127ef6cc946eb6a31e2f06de80ced4b5343d96a92a24daaa7a38817f0edda0b7af11d44a4696715fd7b9d5fbfee56ef5178e711994d55ed33fa592de38bbaef7b3310d680485d803324760fdb9ab50e178bfecaa6a579cd6e9dc964f3cffff7126b06e8d2cda7169863495a795c52b75ffecb8eaa92117aa29a52b4a829bbfe8e1051f485012c5ac81f0c1c833994144776a4bcf90bfc919bb84282f76ee9b68419e512c7e2c8bc6cca1e881ab2b35cf27c30e5ef05526aabdfa93c64f923573166aa18e226a893f8032a779b1a77ffe6f1f07026d20097f13c2764ffe40fe150c1e55f55f82b4bcdc8bf584a093fa7ef62988cfec31bcfb7b6d9551aa09fb50a8eb523855bcc043c23befa00bbf567e4284c2a9c391dade2500f39dbfcb295902e2576147005637d2f52ffb8b9440108cbf035f49c44325e46ef58e59f20aaf6f360e385efb17ee31aff894e43af04f85b5a6d3dbf93f38df18126032e206fde8b766c8b1435488681124833c12af33f1d6eb8e7f74583631c49219c4f558c1dbbb5008f4f1b930e00ab9ec9dbe3f03e5d5893655ff76b8b61c9ea5aa49c7c3ad7457a47cc0719c3e5cfabd16c63d0e8ea1caaa79a1f1d8243c58ab6b080ddda8bb10ea84d9cbab78c48fe37f2969d074cd11a55378bd60ba0f4ebb3375111ef40bd42e2c3a16ae91f91b81e72f4a513182252f86c50730ee29a01c1bf0abb8ed106b7af5986936eee8bc9cedbc64a491e454adb89bbaddbdf8deffbe57c2506403e101b4c7f6184e8458cfb998edf913dc43f27120b731c6a128b56d7abd46f4add0d70f0deacf3656e6bd3f89fc30f6920a97a9690303bb5e3c70291669fd2fb27e2e8d34576cee3a9669014fde128e12693d5edf64417b8a2386851750d7dcfed23c8ac2359f07f9e4523520d0eeb2b3e6eb6ed27b846e864c8579e354cfb485beef8c10167c8ce1ac6305b39316da52ead0f84d701665fb85ffd30d866d06e560c8fbe8d67e9a1dda84d4f02aa81915ef4a6e7e13b33f0295da0efa6f62030a88ac023e3033b17bdfd8ab2e6ddb05643781c552148cb155afa46df071a323731aa3d2ebb18b9645209ac270a81bed72fba458361a756263abcb351cfa30489d0e54c072a987d7549949a503e8759aa6bc2d990524e30e11a937dc84036c868511604992d2aeca1161aed0bb49895d39ec693173755b47f25988211b811e6bcfec8e14e35357d6a33d5ecc17fcdc5eb835ea853468ea1ccbee60aabf0585fd6e60e164cbfb0368165af4f76e5c8a25383f7764356ba0d611a4ccc39b7cbcc31ae5aba74dde8062069f32a914475eca3d4d673ebb5860bde4ce39c7d31311bafe7c43b7f4a5efa9a800dc0616aaf37b1fc0341f87fbcd46d9f702830c8625c7efaf952618ae6f8697829287ace92af8fc707b91cdd0fd721190283a9b0a3360678aada5c553377f5c49d51595ba386164d487b22796c4f5b8cc794ebea3e9e21a657d754eb4dd9d06a1d524b7c51ccd04c610b16757902450b2426bbe486f08ec12404e73befc68d0143b5ab71ba74a1a2c3fcf463a844013b5097ed950c95277217a9012ccf424088343ed340a67b6132074ec8aaf07718b90d0467d151370c17526ac78e2edf95048141dfb090ef6c6394f9eebdfe1762860fa024d08898aae5df656a208a179c515135d42f00e52157ebfb6ec8f3d7a85d7b3ba590077b30103d72cbc7aca88b5b27041676fc082bf6426ba12503ce1868800973150172152021720e2524ccc91f30cb0dcdf6e442e8996d1114506a007340c37a52632184f250cdb97b023f6285a38e9dfd3ea35c439099b75ac3e1daff467609c5326d02d5d4539b38798c23eccf4bbeeb3620b1bcd5524a12f38755a20d5a5e32613d268e6b8cdd18b0f64f4d7028e21dcf86f6fa457734756b1770f15614bf2cf70e1173281b96bfb97265a18e5d708769d35563153e0d92b7c546b6af6f78f607e8422c24e142fe0938d55d7fc39d3ad3f413d383b029de973e2dc002eef8413c5b58b2f03360383b5d7b34cd1dfcdaf4f0a895510ef0a4e7ccd4b6a6a244d116cfcb604b2ddc5a2bb2569fb9cd8d3be126db36e6c77b5c525ad2ea3ab68524c538a15f574e61c79216fe8c88cc7fe754660b271081786874616423bfa2df462db67ea9ba92b9bd36144240f31dda53967b5f18102a7e46cfca54d6582726d698e0507822d77854f7f65f58683b7e371e1f6d832be1b32082b8bc0975fff7fa19342393342b80e471ccbd3176d77dbeb7d742587bd00e8b3fafa8c1a0d09ab44a0d35b804d33b00b9f8637215291b6ee1dc2a849ed76460214b48902424b5d07ddafe839c75569b1a25a461b7d95237193fd5cec539c7dd281fc1fa4c891a4c6da30e0bdbbbe9ecfe97df9a6f40252b13c2287c55734c85af0a5c2d75eda7112d1880fbc3d2fa2810ec7f5c9a39ef47cabc276653a9b45a0dd061c9be17d84f23e9e22df534bb3ab2af7080b9cc5fb0b759df930650cacbdf9f3079e2b5c6571f38c987c0c0de580717d765d716b3ac999fd137d1bb06db4ef37816b9b24a2aca9f30f94373f813b403c0e1f3d314a807c9b3e7ba0ec57d0310f1ebef89123cb5d6c3f5c8f997969670d414c5266ad9e2d1e2ebde3e5c7624316c8b5a8de1265265301fa631450f69899a9bf617d1f64661b8a8d1e02919cb58ce65640f8488b0badb406570d05500e63ada34b597223fbd3f6b489f1ded66afaf50d6d17ccc581617fe3ad529a890e37141e966f297ea7b23fdf6170908f4547baefbe5102cf8f0f9519af71049ecf9061e30a4a93ae0d11e344848aa2cf55ae58c8a589c7bf2e532bb3fbdbf06e94c447955c67e46a3077212879a342a69def4e94cf567274e14ebd406666b45c6c81f02ae85762a556dc85786887c29db88300317607aad9bf7c4817a9248a704cb0f4b8ed53a087a104c2b521e8ef5d88960d98cac537d26329424378086aa75d888928abd259743ca3f38db6cfe31e8eac6e89ab2ef2976b129d4e1885adf592d80a88833e58632c1664976b5a69f46e3d11e0c8677bcc92e2720ced57105b23520f1cba72692e0c3da2c8967d0774ff9af7f655bb522bb3e644e2e9ad0b738a23c9e9451d48bed40e0ef3ba7712e9faf2c1dca2542c7f7f7abd7c16d60cea0ac3a953bf2c7329a60eee76bd0b6d087e41556135a3203414dacbdf5053b8f9e2c217b596d15ca3c4be9b1554105a8d9b176cc083f0d2371c1702f7a9404778069ad0b09282673fd9109381cb87ffb28f7aa98ec380ba6951a8e86bbd63b3e9c9fa364ac36b2b1f47761a5ca2056ba2c8a376e864b457eaed707af7d08ce5552496115b38de2a454fd1d1c78fc7ae742e6c82fa581e01596be573866df171773aed1ac7ffec5d51647f0ca5c1192c2b2066c08fe1e0d83eced516f7b90c477668e429127d4fc5f2d56f5c53d6c13c8fbe19f8c7cdc4feb94233c2b67fba47826710e37e5cd1795bdd010293a0dc4118759e47d6b4b01c485be5e8fa12e222bb42f8cee59306894a1f70654be7b1f0143b4c451a8346becc07f20288363c39a8488042eddc49c00595543c72102013ed2c1b068f3a8a6c129148a1a7983cc2a149792fece4bd4b4c9b7c8e74995da40fcc5ea1c84ec211c6e97f84d8345c592df4a405f4e2e9d598edb7cad07674e08a2f4e40e8d50ad8075d422d573a5df0458b9a3b92354c640b188e6194c330b010bb8c4bccb4bc5a0fcc2392c2f403994cee0d2497a8635398dbb4a256543ae3b7628af04836abd40ab9e0e139328f092fcf4ea9b1546bd9ce95b84efa026109637aef2a2a1fa1bc5f1b7e7a727be1f009936e0d2d6f7a52830f0e91df8572e96b86fa494016f1875c3933b374f2b666bcfac95305c23a265ce1a6846bdd3ef3a3e82a62692d38334de37112d2f0461132b3cdb0c67d693deebff509a26087f9cb79239084e821b20bd7fa943138a730bc1cb766a20ab21b00964bf968238a97f519c57a61bfbfbc944dfa5d8cbfbd2084ea0bb37d61596707d78f4b3346696f7afe3faa0e0ab145370361684399ce04366d657bf72bd134c8d33978d6302cfb6e352a0437a26656bf04576efbdcea6dac30cbc8e5c21590e3f2c732b8647b7a219029ad6dee779e21d2aa8695397581ad7085968078bc893c79bfa78821df9b0c5f0de9ae9253244cc3060fe7bd1c946580a1bffce312e750f65b1975a77fb289511f5034fa8a721d735e8699fedd9e1e5dc9e0abddc66a78917bc2366d375ccd8cb19f02ff52d0d230b8cc38fe16912142ed11a31acb901521434d54f47f7174697ce1f6b3e46e2c6dd63d13c282070e0598d64947a82f1f910a28f300ceb66050be4ee7e78da84720214358733a4ab95c73ce1907263674d27aa3c554a3c7a0e4ebea2f7c6039b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"643649ba80ed23fdeeac84c02c742703"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
