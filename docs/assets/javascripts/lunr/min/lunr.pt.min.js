<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d50ab32d85c784bd588731d7b6ccf0a3a0557071df958de2de2b0d2a115174b7dab36bf2b29ba40822e83740104d9ec3cac4e43fb8057a45883d57145bb31346de85fce18893f4cf5db8e9ddacf229fd7c4226e4f96cf4cb0bb79015dcdf13740599ea28e1fa4a6e2d4d207431f55f53e06fecbbe055aa942773e4306274b4c4f00bf7f766a7d64e4f39e2db16a9e4d6abb394639e86c2b6f7f1b127cfa244c32ce9feebc7f0278b124de1d9605432a81a79b06e82a353d76cc5c9d6540faa03d47b727097cf3eca7c4f14af7a7b1afabdbc52f9ea0d2103ff7d28c4e6c767c119b47952b93c5c87613b5005b9847e81a8fc691485b69a664fd478cd34f16b42bab8dfa36e368cc20d591d2f93e03322dc42becb4f3ec90e3ae41ac8622253a74f5b96966fe4f6f6555797cac3d6ab24ea38b51922ff20c4ea1d5e5f79d1644e138db81de034390c2c3f0f6dbd8dc38a3ed022f62ec302e6f26d156b06050a01144f927a62abf04b97a09b895e80772ca76afa22ab5854df8009563b110e0b2106ae0fc59b97caee368ef71105b994f525b52c9ddc2db5d832ec43354784d7366080c287877179404bf1c7ae3fb6062ed18883c19e608a33de429927883bba60ac2cbc6a36c70f3823e2ec97d2ffec87eeeac2466ca6b239a8cdc89dafe49c03114ea4c05b0b531752f70270e2fdaaa3945f5e4a577ce388086f0cddeac4e70cb8abda07a33563cd3f3925fb05f133882536a98893d34044d5f7146ed8a46632f8629663297db7d0ee7b5ec36cf45068032957bc594ef6b7117da6e9e9e53c1982e2e69b3b03de0dc38041f608142342a83c2bb26624ae43bc3d6cb996c8fbf369018aa7aaf3ccc0892294f298e8ce59a815b66c9a2a6f1ad368563157552bd6c3b779e9872fcb36964a7f97717c322ca2c737ca03e61bab272a20bc73b085abbff3f5ba060df56826953b14d0598b79899b71eacf80449a199e409865870281a3cc5140ceaf614cc806ee1aab15851b50e53f0c1e6043f93fb95f3414cb30d6da940422aa1acd8c675f057255efa2692adc421540c451c064127ddac6ccdbff5543a6056dba3db01bf56a2a8a577474f7c68d890697dc09fb3438512a0e5cb5544f7333afc832f4123a0c07458b0ffd11b89ca682333ea60a31cde3636af580a7a5fbdb9dd05fb6c16ebcf9c05a8e13a8a8d075291b4c50384d8160e850826aaaef31d6c1acc01d6848eeba11c1ebe4008c00295aa9cf12aedae5764cf6a2ac6d35a4dc7571db20ad3e50e156c9d172853ca75b83d3fdce41399e62e1cd3153eb06a61c610f6106bf864a52b3bb10961827b3828c80078f07935381d4fb4e64f520aa0eb1c635fe580076ca6b8eda8de10ece3f39a3a42cb9dcae553a54e2d915cd192cfc1039096b811d100c108fd5de7d2b8e69ea47aa30d1bb3407d5ab46b4ff22904ff486051153b0cecc38789bd57b79fea232ea6992a802d0a0236d4a042ebb8d6e62d3a92ec5975e36d3f838b72f150aac80a44e5de32e9847405d53c87be24c3cc1e967d7055d1294eb6d688361e492c25b5122487b8519a44008ae818753bc24a3d35899538ac3edd302b24ce068c72ae4e6ce58b661d58563382b469262ec865dd0593dd55733b8300cc6e3fd08bb499bec52a329de6d6d74ff4755851df342a416eb0e926dbaa6514a1f6e408182adf436759f5aace54c9b44487ea242a551583afbd97cfe4a411c38b6c0efc515f6bfc73e20c05c5c8b31d8d7e7317c957a2aef479d5b5a7bb830a032b653715debd4da083c5b71e0e665c4b852215896a1fb59cfad4e0b0a6cfa069a5694034a2af23ae76aa0e06f531311eafbb6aa2beb3ea21b4a85584d3779feb87746ba870f49de4ae702fdffc35de09e62486c7572a0d2c650b6d6e503dcf001809907402cd3f24472e9a7372b829fe7f3e38bc3454cafe34dbb9ee8bb58ca1ab251e2cadb8724148a06e343962717cd5a7143add6ac32e2a373581843d57793abe4cb2d7861b2359158fd5d374c948e0bd146bd437d87817ebfc6c7787c6b310f0f8bbef5ebb45af874120939428e8fb1a7e524bc8750f70bea79bc24e91f3c7106703f27cac62abd7815c388da8d1dd12486ca6f467b70967319109d5e42a4c338e620de7d20e7c8f0f7d109814483285bb56d63ca756099fb9bb1c2a1c302c276b3092b31b5eea709a426143e9f19fc1406ba814d681e18f5ff3f3ed52805d572c342a4f068ec002cbeb30b7bad1984880a2770a5d016c4c6565697e7273edd29db92472fb48ea7f7dbae2653192fcb98a17916eea92481f3616cdc5061622780c2efae2eb5b3ac4da8d7438616ef29d329e27da98e2dca6c057af35913c73ca660c70a5d4f43e29300a787998756c87bf1733a297e9fe3d9d13109e3cf85760a898555f4d39750acdc86abd4703dd1c5709c2c9ffdfdcc1ba410c9da8a6d6c6188ba853c1e0c1e373fe852cde02b86bbbe666c615b2772e20f9ccf1dea545e5de142715f065a5f8a4daf36c765ce4170454a171932dff68a6daafee3a3d1f558d437ab8b90c75401af0e47e69dc4051fe36725c5b2eb262bdf880acd93059513abceb86045fb0634bb528da6da8913b2c7a06ede5fb2646eadef59a7ffa3ec2b6ee667b7c41e7fab8b116c80349c0410cfb7f8e9839babba38d81318ea8be2c507f77b94963a05f737860ba0ff3bfd1dfd4ed007195e7b2c5653d86a001029f05d08916cc1ade7bf4a6b5ecb2fe57a51eaed9539535f4bffe2581485be0ea670585a43e9217da3b4812a475faf282ce292bf13f58267aa4d55b7c0f27a7b271f7ea3bc54bb3618be5d4cdc3f6747001b02b664bce0807118822d8b9a3e6d5a011f23675c1b25422eec59ac0420b0704da9960e31594b8ec2c29f9df6817924082b5a21c3acbb0092cae6125213df0f32f03f4bb135a451de5d99e73549646cad7ccde4a9e55d027be9fe17de9692d2a9cf259d9590efc1bab0c620d84168491199ff79b6c36749018a4e346a359f70fdf95ee7b4f56a65a1173b47e2e04cc3566050b15e49699901bae1cb0bf5b73cf2d3abe0fabc8560dedc8c2bcb3bcf8a9bff8dd1d2f93148b6b05cb334a1b5e348995e2badca0fb9cb35d2834606cbb33daa39a40bdf437e13c822979e68a8713bf3a534f8ca666aad6fdc547e92e09aa6e544596e8112d23d6da18c63f3482fb472017da0fbbbe3cf06cd189d03aa6161027197fcb4739d0bb59daa700321d64654dd758742903d3a38e1e176581b9adcbf397a2375bf558385612f218ddc6760596e3ec5b19f3053d05cb19a61c16fdd73e61b6ac87fde102b0b7af05a71bbbb078ac619d9c79ee47743abb0d4bdde164b2f3dcea1be38fb9408bac37d7659d819278563bf7b8b707744176f1fc510d93f7f26ea66de95806bda7cd4d04aa66b691e5229bf99fd138ea76bf59d3dcee5dd28b5990a67196e26cb277ca030072ce0b65be7d11336bbb7674a115c3cafb7e233d09ba8784f86c084d1753ba466977fe3fda0d0f524fad249cb0b91d4d86612d251529570b9a914ec5dcec988143ce1ac8b90af0c40650da525fc2d49511a7d8df4ac202ef48a6c4d243a6b3da73fcde5f2cf7ad4a00fbc792000c8f9e9c268f6fbaf6fac966e7bfc8ed5950ead9a0187e97d66571e00407cbcea309d60cbe2ba8a5931ca84c8c3f34b353803e2a4bf8451cbf1f893029ea677376fb7d8f40d7b9dd56c3e7dae2a9622671a3fe763c43e44854f42ddadc4aa51f715481bfeabb690a4e8071d2a8c28b70754d069558984b61e9818ac8be9cedd23e343855504a6dcb53721bc4f13520f48e3c856f39b986a08043ba574c76bd604cc0b4060318ea419488c995960368c9bb4313af6e6c1a7f0cb16c90f82cd710404a9f45bbee34e0b2ea3da2f0ca37748057911ab760d536c25ef69b958c19def9ee9b6d51b2b3518142fc63730399738a7c4cf397db8024c67bc1b076d12d0f82b71d07d07ecef1dbbd7ada1867e0e9d53f31f7de5bc9065edac8a1f609016674c08371ff671a0df6442863a58b17d094aa34c83bd7d2fe28f884e2b896e792783125e3a617476a92279f7b96270ffba362400d683b529fb356e26ce31f61e6be2467cf6ced65abc06af22c5956ab836e46fd91ba42fd8fd41d8332c1cd54a622dcf5a74834f5d3bcedc360a4e1797262169ea70acd0fdfa34788d70ab8125d133595c4e448d37aa60e1c5351dbb552f856c43f8b8960d224e554a5546ee4eeac8cd186da4f1980b759456f4f2decf6477b2574d7a20630bc276e26d409715fb89ffae4d602d9998532d02904ea45fbf29f595b867df24d9e6f2f83a9d00cc10babac5e08dc0b3606918d8ef51616cc4a8863ffca8ddd2ce30270f9e6be5302f0f68bf0e8a0c5778edddac1a56797122764c674d9412eef5554e1fc29feed88a7766499a330f2233113b67eb5525c8b1a223013b2b3ded14d12bd761e8c0301a49bcbaeda444b393d92f5a99193e68b66b1623f64a722aee461597ac67227f6686a5a7b1ec3e75c59c99abfed1a509f5f157b09a3383632190ad20581addc0a3afa1cdaef6c4f50cbbad4f2700e81416415604302e9a426aa8f83865a8115fcec507cb0b0c2a40aa053ecaff29a454c53dce462887ab2c4b10c1f90dd0692d3e3598293a58b6e0ded8f425834a2b5cecdf2bfd2bc88c9b1142312178a14aaadcd7e3af0fc1061cc12d63a187ffea27f13a91d76e193f2def4a7c047365df596a8fe0a32f633adf1da341411e7932f2f01f527ea89a99fa7ee525b290a867df176afded5caedf82e2e180d4ea56de33cd852928d99d7d49d1b313a82d618d1697dbb68e78c05246aa6244d6ae05c9568ac4c38e2a16d47255e86439a6de5b7929e8d4b6bea783a54f7e83925e0d5c69a098dadb53f83b74eb7251a2572ca295a2455943e393ae1152ae6ea980222cf5118be7a2b9b5e6439df6591b635b07d5609c8f6ce91d1210c34cc05a287e5fd6cdd791c08822f8efda929374f14251d96de69aff48b49fd199af666435c04da006792350a21e3b90fce85c0b28c6012494383d1770398902f9d3d80ff86beb6939d5df7825f97d43c52cc4ef3879c3390cfe45b92e68bff61a3b5e987897f94b8982933ba69a264b96a6d11e602a38f703d3dab6e96da7db8b7279d295e2e5ce11254abc7bf8c2b80b7b182fa8259ada6f0b88e28337d87ac0c4cb2a426082000ad385cd32f9840815c6fc12a296c53813a1018ba72cffb7ee23d9ab764ee67ad3c725b4c428c14003b9bdff7cc833c9bac30e543c19a2b207975d1a8a1b0cc1e83207d8b32898ec4f65be76beac2bebc7ca866d4e3e87d6f2d10496b06f3affb0ff7f6b18469c9eba55d61181b2ff76337a658b7f4956489afd552fab173d5321a9b42980e9df665bf828258537315ceacb133c457c84f0a3c9467ca30e9cc15bda36c1f7e4179d4ec39f6a7c3ace7dd6accee2808e27aaa755213542a07ab405e4743f487e5d9b7ade12ac7a53c55fe9a7754720ce10f3fb95d3d0ca487c9502d905158b2fd8060d8b450672909a54da32ba1d8d004016e91a57d84b63ba190c1e833d33573b998968376ab379741408e88fbba1d55171d2cced7fde0843c02cef3a392568610d62f3f9c10732a8ef58e77baaba0fa5825565354cfc9f94c36542d7fbb9d1cec512da3bccaa4703ec014bad339dc57dade90f78773a4ed35337429b278fa77c23108e6862ad3fe8e32d5904bbc0b0be7eb895f45ab894abf9630c2e139d8580af4c9da7d7c32e0b818c08390eeb6337a6c871443adde99098d9a20c3017e4c8c3156fe850fabdfc6e9f30c812b934c680cb40b83e85ccdcf2f15752d5c1cf7b25f989d76eeee627df977453bf56a86b70f026438bc5aa648af9495990ef2801b6dc95a2f4d3ac5cdad815da5b3c6e5d1881f015f3ffaead64b889536af0a7fec449f60715e13e65e917eca2eec06c94fa50c387b9ed73483e3b0d579ce074ee9d41cd405ffdc5e59916989e5a8f398295cafd92b37f1e5f84a75a86a19a446f7f00fda956d75acce9d6303a407b9bacd1c6b24141d18b100026f089fff721b8d0e41027d156edeacb33289c6ed252f7cb87a2c8ce5aea5e5e1d8950c7fbc3ecbc3fc2611777877532802a6a1a5e8eca63270689397acbc7deacb5a222abb109af6bd99e449fb9ed87ea5898d9c03f6ed861a8d7e1ffa95b4343916edff1cf566f36f20a805d6eb6d92957476afa53a4899b2844367288c9a68f7c19dd09f9171acc1deb6983d6b2a31c155acd42e64d578e4bb0336f3cd22fd619048c57dbc62a9e03d28c82ef8b9aed3a511b8706179b778ba15d08026af8af489777e88f09649341cbea1d103c7283cc1ff321d4d69da27efdafef02fbb1bb362235386948013878c5da25c0a274a7f05d2116d9da4e9c82b83d0ba1ee0583ca0683607f34c2d38fd44c2eb327c5bebcef88e6f4f0893b8ed1fa4b926a8123ed7cadcd5143668844cf6514e54d1e92893db5154756573e1801255d8ea7bc3f8fefafac7ffc34bd5a4873880897d6881d8bff17dd71f5348c3cb076a21c7def842516844663408c6a67f59391c4b25c0fa9d05ddc6716ab0a84351c5cf781c6636155bb6ec117702c362896186d9fd0e5c8f13b7dfd4dd58014b0df369dd75fd23c2a8c6ad89ad6afc26484a04b6e64372bfbf2ef7f1cad904eaa275f1c935069e8e380c0fd309f9383cacc8cf832f8a12ac2a84e4fcfafd4d859a33b06646bd368cb6eebbc2a6932ec24e445eab834e711a103e49cae7a8711df6f5a8809c179490dacf1a2775c005f4ecfbc53fc98e15145f646b1590412cc48236d4bd7d2accb55e061c297594c8e808239e94ad79aeed925205495d7656085a291280d65f9e41a989bc4ae170e01f714cf2da3f631a4d609147ef8d732f919a2a15e09879149a2c23aaa2da567e6ea516f755d9db654b32dc9c2d721a7fad4ce376a0cbff65820053b34716f1e0cf9bf81fbefa68b1aad65c36c89e3853cbb4671c60ea6f9a561d66f91455ffd61dd2d71f6069f66f29fc8915a1e4654adeef867823604856780b3917fbfa178d4d4e9031aaa525106917f1054fa21ed5136dca2c36b4d4ddb7abf5829cc08a6a95710a7294cb1f37b85b8f2b580dc20d5106aaee051a42234397f274d843dc6d34a0f37436b43239c7462256ed0e2b229309fb9575d919b7046141a9fa24f6c82edb1a475f63052c77c5e1c04c10d506e384d533492aa07f42089106952cad3248d312b3cac199a4333becbf55927119955b7217809d8ccbabdddc688626dee9ab725d495eb604306f31b4bc657ffe290001dc09080a73f4b4f3ead96d229fce62e3b15a3e79fab3e251885029cd477b587141fe2e8183de0364bd51d4f474d6c388b77d8b415ec4e62b4b452d031fc122f7f1f71e32415b481db06b1ad310373528c8712aceac072d16aa8f9669e5c8aca901e9d317db095743c0841c154d544f587dc720ae6cae6e5bf9e548324d1f51657ab07b5cc781e10510bd16d6875b8ef311474b3be1eba9fd7e285936d82c0734f49e6a22d7f4a7c4bdb38e0733111569ca31ac18dce429839c5632d588d15af10fb134b049602d0c1bcb00cb795dbe3f6aa936e0cc2dfb55c985b4f8a48586c2f8cabec9d91e3ab1c29d8d465497b14166f11b217d3c8d05a8dbb2c7659b44e89680adf5b3fc722b6fa4e9232856cc4b30d50f783e89c0be72b66c31dec66393833d84b6adca22ab7c4e5ae84be732f4abcd2ea224f6f14064d7558c74e37e9335eeb21ad32d79d52338e7e9b23483b46c94c06b7835f9abd3a79bb78ab9b79f1aeb3300034a15a23c5b530807b79463f4609b498665581ccedca7a598b2d659eafc19b61c35805037e4add5c05adc30c68e7c7263daf195ae2377e0d688152f656a4f57f501843ece0884138d937641c2d9dda0a06b8cf0db42bf0be23c619c0bc7fcedfa61d11c13b9d5e37731dfa9dc560ec9c3283a54a85a59c89bee3f4551b2808dd438ab20884fcdc154fdbf92e85ae5c13ab962b09146b4038c2bb9d186504248efcef00088b336b8dbcd0276262c89bed1e0bfe05e0c950b94c7533c748bcc8fa5b06ea4b220349aeaf3dc6aca4df681587384777eb6c00b15c07e1a510a22ed18a725455926d10090f8bad2dc6d397e176f030f90dc81ea44ce60f1046573c6ddb1d6cc45dd743aa7a3f4fbee8abec959a0174684767fe0182878d8f89eb1ce0fb76e7bcd215d1c99643d35af3faa9affd866cdc9f39259d0d81325f34af64dd5c307aa79c6c7a3b0c7af14f61fcbec53b3f7a9ad94a0743b25567279161d6bbb7cf5dad3c6804d36e4feb1a270222caf5f1fd3d00160e9f7bab4c8f468de552f436f047dac4e8ff232e228b248b999e0313e3ec9f9eaf566ad6c09344a4e086b1b6a3bc9bf962618032ff558a3d12e669c247f9dcd8818ccd6a18ba5202e5569e99b1f17350220b520f20463e6b7b3ce18d1498cffcddbbd4227d77337ac022519511047f91f712ff0f5e1172e40ab39becc026c32b6d6212b73c9692e5d2d55612dbf7cd500494bbd9bc9ebf5678524f15cc9847ef361a37611468b777155d37165a569abf6e1b23bbdbcc5833124310b830e12afaf8011422be69840361049efd5949a926eff9b1bc9be194a9ebab0135f3c4105e48d2d9b1ef6d5c605066820a045102e6b9a86463d88407cf0e3a9fc45b89fc0dbfdb8d0a73146f9c3f2dee133d09181cfb6f090cdfe1f359fa6e68fd67b8db6e0132aa766dab5b1cc7b4674ec3260cc28b4791ddbf593ed16d863dc6c06a937366dd05b003e2a3e275a576edeba872689683275b856e33914ec972edf6f2d6c1bf8ca55c1280fb0646335114ac64e00d52aec3edfbce6298c2945ba48ba928ef1802fcbb49c73d0897437af7dcc15e27c5c3de09a552c3e1e1c1d100e1008d6ce7500d643fb9024661643dc49cd8d499a7349a02f07ba86ff1e7388013e049cd444b0ea9bcde49389ad3dd9593edbf8c53cf818cd1a024589c512942fb817bf7ba3e7d83fd8d2bae46def6e3cf01f020603d5f4740a7bcff29e10d83f6767fa3d28ff6494d70e842d9fc8c084d18e52ba49cdb218a1a0fb788e3a70248512f89a8a5b3b092b40ad864bd102cfa3a471e981add68f360f9f58b190f5bb4d52be193032fbe48f865eff72d620983ec9786c733c0f8330304a45d08e3f50a87fafb1deeae13dd4738bee94d0a5cea142f8547a8400acbfb6a1a21b684e1eb1d7985d91c07d26363f04e7d289c223bff4d1b393b95f8b923816dcf5614a7dd99bb4707c154f23a15249cf2be1e957199ae094cc79fc91ad06aaba6af09ea23352cbeadee70a0acb286badfb7cf50a86f50c8f8287220d142171227d74388eecc275472103f1068c011d698691b0f0055d941bd1b34b55f2a17eaa510ae6c17a0b3ac3ebdb06f250486d16b57b51bbde81b13b8b684375ae83951a2175ea5ad47d36dea92981f3ba82b9007f2ace9f2247d57ce30169c26b75c8747f0a116e2fbd0f819264c346bc2543a08ef8cea916eb04737d9f270e5bd94ad613e98ae833a97c619749905711a507cfd54230b8ab634ed5ac72e28ab7dcf159d73529c5f3d3c36a7ab27554f691215758175833465f096386fa930df275e3cd6e3d5241c29f022d616001573b481111c89a1c754ff5a03db44d14e6969afd5c92b555ff5aca978855427c6347683642ee9308226896fbaa0ece195e122f3b5aceb5d3d936b5e82029247a490a82b69072fbf65f10b4ba0e2f8d8854a6e94eb8fc52fdae851eb014ae84887f4f33f9ce5412ef37f22f7a0d6765de8352ab483d1377edf03d1b0382e89339739cb3020630bc995cb25659fcd54c8dece38588a26267e3efa083a384dee5ec95f475c3d162bcba6bfcac1a053fd847a857f1bc480f00b8ad9cd77086dc1e3b5e370886bc56a50ba599e920ad77790400ebcf6521fae3f97bb073b1af00fee92156c15552bcfeff2ed61fd8f0685de5617c897a8a93758ae39b283858f26b3f7d74ad29888195949de500a51759779864ac8674e422494e1ac14a21c2dd8c39509dd632875dae92678984688f1387f5b21eadf87ade50c47636591d4f8060ac39e59b586373019d1d775c3b969a39dbd51f94061a6035f1b2c6b23b238d25392a0a8cfa4e2569957c2c4c5469c8cb231924425569de1c64239e481677956888c6a787f490834634c5f53b6e5badecfb802c5636112ce109471c8d26c317fdfbc4e503da451ec2cb68ee59c00cdb731d4b64ea0b7ed7274526504c01063c2bac233b77d41bda330d0388c0cad6d1c23546ad88bf28c4aaf233ac589f3c8d2e61bf02b30d34d7701ade0f18087f7976ef4d74ee96098fb3ad99fff8dd20e984bc72d3a19f30b4d40463baf98e21eb623b0ae258b3743e7f611b47814566d384d555850d237b09de6390be687ca2ba7f6dd4044e28636ee9fc45b4d538cf04aa94faff7532a3b91dd30d0e311167ab3d2ce1967334b67e59626bf1b7f51b807b6d0a20586eb64cc18888c1aa53f2b8bc1b41b2ee2781cf803b59e50f423c66d76901ba438f877f4485f753364ffec474f3bbbfed4db12a428829ca5a0af9e04639845691bc481f20447313fce5f60845b798d52ba3b1340e31d4e0e468815d057ca31b37580040636f0acc817c4a87cf52541006b8581b6a5f4f0a33d47238d4a5c5df003dc2dc7ac4187f34b079a9ed2d307b8635fa8d8554eb8ebdeb1bcd00c5a2e321439c2d404c091513290f6dfbe73564bd6f75dc36f0b31be15623e77ac92f64b1af543426a4d7ce8206b93042ca85918e1cba4018602d07ad09ef4a5ae495dd58fa35cf9eea5fb7a5401b7a80ccfa34ad83b4f59e2fc2096486b1aedd8144057a5c1576cdff585838001572b13288ed09506b65e3fdd3dede888dbfaabe7eea3b3733725139bb189e981dc2f9ee80f8e431993e914c4e824762aaeceb52038e65e590f28b1b78c46dac0051abf0d90d95725b4fc16c8251c9038a3131d1d2da0bb69d68580bb3ec2150a05058fcfe51c8f2b5ac6e5633271388f7ad5fc75a4242a154b358e10833d138a2e5e1c28ab7439887366f7eeeebc03125ad9d9f51b67609fc664bd05b58fecfdeb16f53c4c561258e4662d218de6da8bbec2b66a87b07854a5d61d92cd7ba4eccb17f13baf84d28c7babe1839eb33d6f2330fd32f084f457a7198264e50d2e7a0ba3eacd940a37c23d70d0353f311f21724a20f8f9a74482b8102223082d546c19561f7f578c3109c5d6eaa8f6b3c944cc855fe41bcad690ef4b227f9a76f48ba2e73465adb74b3ce33a74d9111028946d4cc7859f38e52c39dd305ff4d968ea432d4849d43f1e1b05f06a8a04b96c5108bc68677aea0e571218ea5e116dbde93626c248efeec519c521af11b9edcd640bb26f6d548b069e75b84217cb77316a1e478cf0c6534f4cb09544a5193a533a645cfac3e4eae3543cd6b782e0f12e5297b1e84bddd76f2fe48ceb3de05e437cc1fe20e0d45b513dc3299feaeb40169d10a459cf7e5ed7cf1d0bb1afbae52702a490c486b05d1384d3405936cd89e09ec9b38dd7343c23b30b6110396791a7bddaea0a5eba5d8991df06d086f1ceaaa38129e2632e7b471c8314c0ca87c0bcd728a0f0da9f9ff4278b7262c8f60862d2798755804cea5863a346510c40c075afd58b7f19948255a7b51ce40f638494bc1a3f733d3a3115ede84083b41e0b1a1a3cac7f3e4ded9e07e4e61083b776948490504880e43c891eb7015cc4e22c06ab5f4c610482840329abfadf6c134ca7236f6595c2d7569ed46981b83ece81b386963ea55807f077ed60b591e86b0130af8bf6d9f94aa49c72c4b9fb56209904335b786c986ba21819ce2fe258201341d0c403113a5af683e790b2ff9f3b6c7ddb7aedf1f58b1d0ffdb176f3d7d8457be78a8d06a4fca0a1870a620c045cf983aa2c09f68320da1c9a4662b5c35547cad7683c9bad58ff85dcff5b91ec2626aeb6710d29cd028a9484143037be33cd1dda57f9c2b17e2bbbf6b53ebf4caff90a3f7ec38148a95012a46e11ecf72eacd81fb9f8aa2de298f5688953e360d7baef7a3db221c077e9a7f0856e3ac50298830968e18cffd78017adb90c1934282aadb739fb342f61a40326d9cacfafbc1d85926c8a31b910c368f3124a19ebcde8b164a0f7dd003002bf1cdc5caa4016d64520d45b06f362c49e2a384290d5cc008084ba85d4daad7428dd1c9576169101a72c135627ffeeee031dfb79c98cf73c6ae80df8e10ace3e1d347f8f269fc591e7009d347138f724fa10820eac81ffcc78e9f5f333204d242a7860353de6004299a1687f9564523111350315bdde842f9e259585d7c49eb73f0213c09e4933c28361315a4ed1a98e009b0153e4fae77697384e05c40edb7c6d49ba535345dd0b3c754ebbbff1c2ae2fd8af84d3dcf60ea94ab8ed5a69ef349767c53fc44b21e3b41a74426dc6d50f17c1806f8af694f84139d07d43996c3a7c8f433800a6f3c3ae799ceacddc623dd55bca57ce478109c501b9a64863bb92c4ecec03a25dd8a0a25b0395bbbd84e8467a6fb9ea07285807947f29a81fc943eba1f615110dd4964366c1b53749e5d1b8aa36b49b66b30b924b9f03d8af5797105650e4ea8f18476262fbecc345d894eaa6154d7e46b3552a3ad13c9ac842d9d2929471d9f884460ec191665d3c4489f17e9f5be11a23658832bd9f49259099701e5478013a8ea8f945c0e7bca8d782739cae564a0e2166dd8179c070d998c80181da70cb07da7e872becf38bc18f557f5cc170a5b978ea00cb7e594375eca385d5b47be17a9d40d95971c32f7361a0a09a0d72ddc438b17f51610b1752635d2fe7fc02af435d8cf4746e50b2e1ad4bfcfbbac1e06e468df05b4ef393884979f1002937f2673d5b7f688cbafd9f14982702de4e2515571a79177f9b3c86ace9ef376e13c7fa4d68f607ef2d18486ed2643a6c044a9d07a02a4c7552c01b69d5d572f0c8359f586410985e70859ee0d9d0853ffaccb88e1ec3006bd9af83342f0978f87f6589acffcdc43bef177cbe5547a7e2bab8f2e6f61adb7b5b93567634a6f6e5ae8f867b913e9809d2e70fdaf75b188a5108eda4e8acce47be2ec8e6aa5b7bcf46f3e9485108a902e357ccae9809600cd3e13042bd3b8d43f5c7a6e74576e2b61a1a26ae9d27b475fe6183379b8f3e174dddef300baa5b5b29efadc01787ba158065ef5cc511d935fd729f24a9e3833f20d0e7b3c27e9c4b65b61f91b05b9b79daad23330dc141a386c05687d98f68c3df7ec308f6be08a0f210de065e4493c08f690cb4df87d98dabeaee3f6c79b5dfef6c3a4c214f5f2821e5a75cf860bc9d552f4c07b739d4bb15ce0918983deeb73571daecbed5fd7f08ef64eb04d7682db5630e3b15238082cca04796790a4129ca5f67116d425b160f01a1536459652a81254f0ff34dc1709c4e5360bcda3eaaa5368e99ad019fe4a9495853132505b134484a67899840cd3d26ff49e32edc3ab6a44f1b300c8b439d2ce6bbb56fe8e6166a88a98ddd0f199527cebe011291a0efdf6f95347390d8c3fa270377a8d3533d5fadfd09a1d0192480fb14fac0fe0a2ee91e0dc09a88b42481737ee2afc348061d9740786c2ecd6a29314ea4c702bc27c962d696b65a76128a516574ef2f15f4c7d6cbf7c28f2aea7345d89a24805f5af8f7f1de6aa6e7d7b8ef457dc15b82971be4e0b57260aca1c663701720e526bc16d768322cc1b78f176d3aed297c4c233d51d94c101887d7fbd1c86fda1c5ace7086283e23fc82d7789fc271143e66fd4cd3545b8207181b0d62d9d4d97cf98ccf900b079cf2573384520d30ad2dbf291e568d02fbde22731fa043e475127957f7c1c208ce8eb2f2c9959743323636dc25f35251d0af9bec3046ace43ae686f12362b024448b207d6149c1477226bd33f55393ebf8cdf8371ec2b60815881698086f34128076ec3b16bdbca8902d8529bd9c3bff4bea9dea86105271d8eb8c585c8efd797b6e47166dd9baffd750d0e3f753dbe93d288c65b81eb9c609cc4687dab68aa1c41360fe5bd3d1250381b0713685ccf0fff47594f87a9831d50bdaeaaad26e9b2905942193fbc5b92a8ce0e5b56c245e81685bdbf40700bdd9bccb30e6a5f016854c30be52c0bc08cf95e8c12f07fab8c74205ee33c1b6669ee92e8b5dbedaa9d0c00c9f8fdf21f015f36f8bc9d8e0a3b4e505a3285cdb57d17189cb36118892e0ec02494749c938ec08d3060ab7fc5a5a045b994c7504b4deb159fd6e425ee1ad231e0ff84211126378d812260dccad809d252cf61f507b107fef4256187097afc727cdd2965876e53d7e0769b9f0c90e7ee1847ebf7f2f61ad27340bbe","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"643649ba80ed23fdeeac84c02c742703"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
