<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ded5a2b42534f8bd46850fb15a462bb984621b5ef06b1664210b878f32f570add18c1ccfc7db22d124ab4fb0c70a19fa85753725063f62bf958531253e8c6f863cb47fc580ebb62b32a7d814e40ec7c1d92f80d982b385a67a786d536a7a16184d2c862ba605f9d2b2e224207858d0f5ba6deebd8398d017b6e54977a7e05deb0b7bdcf6e72e15769369197db1b37a47bf19e2396e78e792794356897b2fecbbb32343636ab6ba5907ce80c5b0feda649f2e97399253ef4fbab270d50411a77d028a361f669ed1afb1eec89649dab7ab383c9c84468f85db6098fda85da4fa87c47248c1473f74eecc5f7c4afc32539b689d5a227f680c0cc82354358471045d8c44d2ecb799447de7a5c7585dd47f602e51fe694d16b8c055d0c3ef6b647331362af6bea62855a159e6e879cd6b4fab59d922c7b3c24d800bf368133784d8e896d661b3d97f9afe35a2f4b642c98243e47cbf2bce9228acb520457f1983685749c9e2b71d72e8b2d961448b8458508df68854a427874c0db4b13b5c15221b60251580863f71edf374e1f93711b51c81334fc16678faae4c08bd022895bc0e6cb16a06271b95f373c01c6c67883ead2d439e7b3517b8139356c09a32f9c1071c41852d2c7eae874e7aa5f593a1efbb8a6b8159eac0d0b833e9674f451dcc8de573c22aa7e4b7a8f1b2071114768a3e90acf001a9f0b388fd2fc7de99b115c028cb836db4a0503a4fd8af85d13d8af901fa1a015e45fffa050b2f999d52a0309b066626cd7fa6e6c55dedb2d19eb93e9c74f9a2a0f347385a2d707dfada373a9fd2c94e548e42e58025cab823949111f92275934c90f66020d2f25413d139f4f2bb5e993d098c2241df425392c7359cdaa96a9bb093d5c66f56a64fbff01a5edcdec0ac5ece88455b366795368c69a7dc00f0d13ee84d3b2af0a4cf12c59800308f39e31a6aefd3a139604a952a93ea794bbbc161a353a66c6d84c22d05dd27fa87ae0fd959e36bb347438305ecfe0912f0ab591c591944c999cc7a78c2e51b83277685493c39db538d461748c6483db265d23df1a2418f6426a2ba8bf5316e9334311938770ca9d539ad0c0b4ccf45d661342f862b8d4c1b55599f146e1638a0648d00e4a88ad81e1a1803625047a3875b34422b3a66aa955d609562db58f32f506cbedb8319d07a2962cf086085ad9b17146976815a157a7a7214b253debc8b9dcd761fd1182b3ae75e7ac88a29b88f498f58a37ce171e8b9a4cde18f6ebefc0336585f0682584e391e32657a042297a0b7f7004f220234e47be1aa40d0dfb679e603b837170fdb342a22d39b271d1f2fa7f4592b1aee856cc289d51d9f0cf895b65ca8c3aed0381b74b7376751ae9d1c924af22515b820f9de8d38c848ca990561f801a159fb44f0f2fe92365744c1ba6e0c38789d7a29f66c0ce23dee71d6f6c43eeeff4bc5497bbc6addbf74a6342df40bda090e1ead147d37fca89d97540751e21b24de192d203e68d7c6d75d47eb208d83c4d1f9d450153b9382a9529c2337a2bc56f9aba9577386228080088c6f6d98b93b1249bcf0cd8ee19543750b99203bf8dd2953175f1d415bd59da92b5bae844af8ac9d023ad62d76a86649aee2e248506a792daa0ad80578e02d56db30e763f2f13cc933d93ae311c7ae41a2ce4096acbed5d1c68faf71ce1b9404432b7af659beff7a30ef1b8afcde3b74b36688f852951c5a738a0e22d3650d1a7fc05ce1b0271d127f5a5e91abe9a7670b1a34acb77718fe489f0069e486d401ac6c0fb7f24dd1f869f2f7a670b4de99b988588aeff2736a7310a8678c6c0dcc5155a887ce2164937f7ce12f5148df28becb8156ee315589816595f8fb770ca3a770b5d935d880d55ff664d60a68f6d0ad44098841e727c5e85ab6d24d71949de898e5e8355f2bdc0c4157e83f1ebf4bfcadc0727be24145674b646277cb1916b3fc5764d1cd324f98e40541507808dc4c5628d9647e887a8776ece48769f96cd4af206aaaa75a25e5d53a47934aacb8c05637a96fc91c0ce8c4038024b7f780d08c923f5c7527d2f0d32ff6df3e0fe001fe77ae4af01bbbcca45b30a399d6df64a58f25ab98cdae62c526845558cad0c0fd73235e66a56e153965a795ed3b357d100ba21e038a36f3c41d02a64b9bbebefb981462ce7cdf9900cfffd55bc7e6c1baf4afea061d5650c9cd79676d926c021bb2ed6de744e8b9fe0366e06b18ea489c8b0eb30d79002021270d0480c1fc08c3ce37494031840267398e86bddadf932db4c86949cbc6d7bab38c95a3ec65ef54f58a0040862fafa3369baa331ab0080e60e801dd3135d362b3cae40cac96398a6f9edfff6f06f5a794e966de2614b14755395d6ab8f32a34bc76efd66e01cbfcad17b8432fdc003e4e311f2502595c7664d1f567c34fa0fab783f6ceb5684810e0d8e011f2479f2ffae6ae06baa508c7736b86c0ef6886954eb1b22fb020dcf3b27280fcf4ba481dc1333f0440729d43ebcdd58630f6e0b0c8d1ae900cc94df75579c1b6625b25a3f363114d6cbe1041c7ddaa7a14328bc78a850dcee671359a3942ea33adea8bfa1e1c339a48f7d52b9f54ca2d9e334c7d1db90de348975ece452ac6d3a70591a787c4047f03532d59a04b92dad0a24f14307d61c2c8ba86443aa5c8ac6aa7f16c346f1e2b6adaae2b4f596826c4afa12fd4970a67ccf6186275724df9fdaea72ee8fa9670c511297fc83586d21c532c255a4f305d956cc88dba50dc5398e5ab28ea6df3c67a376d1c951299f31d82d1dda86c683602d8df49a3cf013b0908fb2d87ae7828c7370cb521ffa29a3ae70589f0fb99e8ffaa92cb6ec9d4039353268fcc0185543216233de13ddc965269497400f8c9cadcd387abc1995f7874e990d9a451d737308e16301e3737a0493fe91f834dff7557050a1c2897dd81c004169a9e5a6d60f46766555ec1d294492eb1100adf56dc72646eb8e7a279243b51faeb2ab763df5844a903b3359af9d4a7f0c5a94023cd16c14b3eb3ba0f52b9a7bb55806750110b44c892505fadb5a7423e16bfd33837574df3f8252b626548e9947b6dffd48212509867d8a64a8620506849ddb7a5fa1ad15b2afc8e4ea22079ec3555620c063dbf64d085933eec8947d2c8529b8d7cb5afb73523699f0653267cf1c4709220a141588f1fd618e2a997ad0bc1cf1d5e35fcbf969fc23f8b3f4ccfc3ee64534457bf17509136da6de2b385d0fc1476756f3fde3ae64a7d27e2da5f947ac0ec50502d0d881b27701046b1d0956ca558328e887e9afa25f16d6c2ed852a6e2f719fbf4200c6ea76f2698a20b743f7f64bf409e1df5163db5d1049aa006074658f00bf123a92904adca1876335750d14a0c76075b0da4425a9aea56460ae01f5c39842c6a6c43757985456e1c051a7c251abb75a72401f0ec45cb2e2c95fc6f41f4c4191d76cd30a8463044f276e6c6bb6d3d88489d5740280248b994203c8db885a664d2323d6d662614e0380fa9273f88e8fc93e87ae631291f871b9b57b61f1432b8f60c10f64b934689c46f0d7eb2b725df68d460b969f7d4fed15b82d03b3681f5b7c2219090ca4b5e086f36e3f50ffb849d87ea1ae2b79ee3db0537d4ec4d8aa0f573847726e9505d45216896b867c03456061e1f878911d2e67c32bcf10a4ecfa9b1116b08713531b6a52a05bb80a59a0eed5dcce8a979f20488b08c87bbef56b24d9b2dead31b40cf8d7812080bc1c959f45e84ea321da558f705f5c0b379991a19862c2f480e834c94169a022fd37380ca25f75aeb2d31c294eb52dfbea4e0e56c613f0bbecbecf38b9d0739c7b3bbbfedf7580a1827a354160472bdc3298cd9526eb9f7a4ccf197af14a9127427bb24d247f906908237b16fe9e1b2b991959b330652cadcf3c70140ce58aecb4243e474b0f0c4057f0991a94f8144b7736bd78b2fd1149e6129bc36f72b08b09b2681cda8be217079b45198c2dcfe0223d08ae1a3dda9015bca9b30f9a9cad2399100e3feb9894fd259b3171b81e614d96561b3a3d809c82c3092415f86b7ab9722a9d2786bcbcf980ddfc50c18c8ef1f5fbb624d9275a1dbb7d459689cc35b2e866f67555b8c02f5e8b0a46dd2083fc7c66cdec8cc8345217fd3b2f717dc903e6ff4d0794cce96a0be4fbb1a0ebf358d2227a6f3ae40310d1e50e3dce1dd73be66bd6bf3ee17b816584740c6a6be7f82ab9d9282d3bfa2e06579a25c23ce7f0eeadf322021eddb1a328778fdc8528835afba340284346fb6ee3c89649e8de1a83c2a5b5bba882da5823f8408c42baaed674e3082c0592fc9c131c68c33547c12026193b301d6473b76085255d20ec031f52ad9579f212f0ca64de3b7a09216dc1880fae8086a7cfa7f0de59869fdb40787073272ed34ad73c33761870cbb9f52312f2a59a4d3ca8054275ee1e578ac3e9020fa9e77d4402ea69127ab39689fb36418f18538fd4956320d75de4bdfa37d4a25ade27e69164ca8791e19bda7280f7bd58fb34d96f9d87bffd0abdaf4b9a195cd95b385d8d131cd1f26f071e2928b72c8773ccc2c01eb3766dff5cb024c5b35a856d575d76c227247cd0c4ff501e6fe8d9687cb160be6b425788c0565f590ce5e1f66b038b00322ac76c174dbcce51b8e60040e5265f5f73860fe34d7d13562d87a995e8bc444eb951e745bf9a3fb9fbe654ffe308efa170faf84378217a8a54e29bef73b5117d381f02dfa629e0856f5662f78ccf8668f3dca4411e342da0d193ad9c583d4f4acdfd4ef09a92b9da7a35b84aa7099dbb24dcfbadf5858e833e6f1f6e45b0876ae4a82bb52056d042ec9b6919415d23396901b17c0898bece83ed2c66c83dc8fbb408189be2f13b3143d7498e12bb3186576d4f74dc24be8a638b556985131116cd044c5410a875ca22e105234893b54c3c934b88753b50a29113bdc10647d4e4efef71f463d41cfd55390039bea9bee949ff710195c3e0a8f09715f491977fa0665ef128a1fb37ca303c96562fb27f5f61072b18bd5e842e32012b874539e5b0bb2a655ce408ffe7cd2e76d9cd88059bad74c339fcd843ae610c5058cf7b92ee96d69482465261605234a95efe8b4ff3268877d6a8e14857b171f8fad1a910dd3eb6dc5b5576e0c94761cb6c70332ed41ce9ce7b9480b25d72273ab92e1c521d9c343088305da5aa935a0848a2ea19883ac64f7d833ab9ee7fddf710c70000a449e9459eb874b17322e829102025db24964a45c992f61c51846c30f7bb11faa6308afbf145c62403fa7628d79540decef5c79ea317df71a0dddd91f63d0bef86f6a5260b1eb6b7dab544f6fa595589d110bda93f738885ca1f12cafcbd3471d4328b6203100b4e04f65380c227165e8c8129ca68bbd814f60da84bbf01cdbb6db6eb84adc3d8b677b4157b049ef41198a16e93e6432397856e8c534ee61dc33e5c29c23bf2e0997886b42a700baeeb9acb35ae50a3744e4f7ce9f7703e436b4da35b50cc51955c556c45a3eb537f582edc81b229e33c2e2c9b124f51950a0c3924c9be4376bcc2c194ec6a527575ce2f90924b4d8b75aebe5106f61dbe218edbde3fc607bee8e51d615f4948475bc279cefadd58693be2c0dbcd653cf794cb9fac0694e0c475258c258858fc276c11b6aaba82cb86ac9ead4422b4dd839438d0a310a1f74e7e058829f51d621cb52de8236a42dec692301adad3ccfb13fb1a8dd30d311f354ec12e75034d690addfaf66d90457424f8474d87eec946ef0bbdc8b933c356a46ebd9662288acccfa70d7acebdda2d410d6505640d038c24426e8f83f58d89a7cea984f4149097f76fafdf0c7ff50ddb6c5152f88f7ef26d72dcc9f267b8b7ee796d14e2f94529aefe709876547a7162d17397a1230c7d4caef91a5ab2a827a8b0ad1e29bef1c7102735503171fb81b04c373a5c6338fc9fffcf65b62be1a8ae9ee45664e1f9122f627d69c0938df27e1d04fbb87c5088bdbc6ac2217cad9ca517f03c5fa73edb8bea139c415210b87b94032294f8ee7e49e97fa4c2fce590c59a77e73aac3f72d1f71e2350de8d58b6e3120c2c22fd9306c9152cf20a68f7de442e3f7471536153772c8121e457fff96e3eebedf976e3b50fe2cf259e8a513db6708dfc3706605ee8513a7bfa57c817b4bb07ef178d4979c82a1a796b810b07038755d205d64b4aa90195f544746ae7b01581bf4dc7e3c440b906081610959441caebf3ff2abd7953b7538ee9e2848985beed3f28794bd2f426ef5ed4440c697b25256ce84fe1a90371ce552bf307c887884281f7254d091a1be5ffaf8e9b4e27243078320dd2fd627bdbf21881d10859f9a16396b7a2e004a6f1632eb3b730960c6086fed30f963b466552c324776fbe6068a202f295999578ccdaa6528da4e6b23e15d339ae71919f19892f10726201edcf780028ad74f218b2f51c7109adef1bc6e5e6824341e1e0af07414f6265e77f34ce0a7a624b410aa222bb95450c1bfb63bad11ebcad93816f07af7fd198e17a04f313e711a730f08c7a7e11593b509758c1fef5bb4310d59bf0c616869b2f60a5c9b2ed2317444225e205f73bc7928ed5ee65ca8be8a3e84a4e15555f10600790016fda3a99b995dce266fc183cce7e8e52d17af59045a9a00b7ac7e4e27b486f808d75f1c4db05d3ee7644d2f28c9ba60d3c495c5ea76fa79f1dcba790bcbf6742a2888059e5a35c8c150c4ff8f5ad7333c1791d02ba07b90314830178c7bd3f50eb4a71f8efb246c559cf289bb52f7bbed43aea542c6128afaf442068240bebff506a270d569a2cd67f81382a21fd9540edc3ed765bac4455b60741e7fe6a070034330ec998bac93c8a364bd49d538ecb623355c272ee811ce0c890eb305104c5b4764171e62438f3088f3059e09e416fb981ce0f5da307dccf316869deaf143cab5e7567ef1a7e7240b79ace4cda45dbb90792b0ef7a9218bb5b627e82060b2da31126a75e90865c8833120fb0d9ac7f0513bfa044f196a8514195b6bcc0dbd7ddbbbbb1cbcb6e0f65e427e5e21eea76f62753a1b64e41f632f6e7abaf0ac21253ca248cd2e1e9fc27075f2ec7ab82557a85b9603907d0da1f4db7ebfc2a0ad7a38c03b9d8f54199c052c245414d875245c276e9c8b87c51ead712e638de8b718f43597f722f06ed3f3587e7e3db27a9a6e2ee2cb4814de8e9e1a788cbbc1c1c354f78707b186e80e581c2244c2b375a1ca14fe37d42995e2fdcea04144d27710f220f552cecfe58ea4261a63aeb72ff2ab3633a79309bf5caec9d7c10f1e66774a4417bbe57c48d300dc3c812920774d4dfd7080c3a621026804c540668acd38dd3b59d56f6117ba09455db00a982effa8cfe7a92588299d5cdbec113c7117c3b034bc29e26c54db9646a49e44edfac644731e0d7ba4ff7b5032ae39c29ee5670e3580373679c79efd6f1532e040dca7c48050057a588ea0a7bdba350f55545b728c3a167bd6e1613962f233cbd4f0dc8f7a04cea04d02bffe0aa38e1da4a688b647b4b4db9a4f547b226261c4c6f6c8a13292f9f9a0ba271782597c42c63e52899eaa496454a3dd4c6cf177ddddfbfb6f5fe7a3a3ca014f3449657c1907ab0e1fec9a3ce5ffa491b5c160e7c3ed8671bcaace2d7dcb2d2a0dcbca9b37d27c90d8d9dad88106970b9e7b59ed41d54ea51f27575e487b78baea3e23b1fe803626111bd7f2abb609a4891b6399fa76b5cdd30c0a58cf8d47a4f87a8fb724533541c48e4a2f15ca81fa754062469ef89777250878f7e56a2772e6a07178b06bd87e0c3e9f049b77bf86238c2e6b7667a62289a647ae7efce6df09519d46c88f467cad9703dc4eaea5c66e68cbd8b687db12dd8105bc90d3b360da139524c6376d57e82ab0f2eaa6237e479a3da98195cb8f511a5c02d996b0238afa3c2ac74c43c1b8ff7d75f150501a404132a1ef386b50fd7ffdd38e5e4b43a80ee4b2a2fe9689098009c9af33b498d917b61e843a91e11824b51a07042c1a66f1b2c1afb2d4f0f84134e056c722bb9a14e3bed6159c43281771551f2ccd2f61b78a3a4ecd6f905be4bafe47dc7de9b999b3a5c76cea6b3e0c5bb518aef9a3b1d52ac316f98e2f3c8e3fca2231dae445223b72fdbebc5b6406bb2f141af596be66a0cf1fbb8873b740647c69668d24ea2ed525d58414fbf7f4ca3b7ef6971b5e2b07fe7e919168277ab5041cc803a8705b286e46e6a82db7375ee2c14cced829b9a296a9dab5dcf75cf95f70f583740006dba6df8172cfbe9a0d334f0ca92e156dd5cd56e5f97d84d52469d7f7e6cddfaaea0298e5c94ebb870f2f28c22cb5a777c1737ef6ddb60302b67fc5b0dcc5aa1e432bcb857f468fdf17cb10a83ed5ee5e216e94d9b9982ccc6d358676462fb73dd0d1f46e6391adeb1bb833b4519d2bc5f76447dbb1d1475ec2be79f85b853c4ba214fbad342fb61f4a110dd8ee1be0ef8f4997cca146aab977167b55352ef5a21c2bc82136a419e228b7d941afcb58a2debc398e8a760c20523586fac219df5bfa631d83fd65a7063cc995554993142b9dacbd28ba55f8fd574462f2bb4b72bca56dda4668e47fb130a70e70e7969c7d0399dfd0916ec1b3a69d3171163a4e0337444c9b182033f13e1b47515732763a93d37e2c3b444f8930102c534da4f078e997d7b9518f005ea043ddbae49ef64dc0559f890b1724bbdf6e75ae5951d076c6aab6f8b22b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"643649ba80ed23fdeeac84c02c742703"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
