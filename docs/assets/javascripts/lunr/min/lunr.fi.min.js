<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4f159eeb3bb2bcb4d58b7f3f52841e3481760c76bf43dbf67f9b0af69ac3e5f16066c7a12650a6425adeaccc4ec5386e05354384e93a200aa7cb0890f3d25a09f9e395d03f0fd166fb55d62a55fcdf59ccdf0f575aeae660f393618f1834a5b1e94c145e3e9ef7bc6d890179213b1aad1d31663eb8f8a96bd4bc0c37dc49d169649403f81172c7b0d101579109b4fc26bf21257bffeb20b8e8a97cab9a12448dbf10ef82dd89bba490d3297adbf364657190520aba1b174bfd5797fd11ba586770d002a051dd4cb0da35eb26fa87e8f0560b8b781090c92f225a3a95a765d262e0cf3c49bce1850897ff1254922dd2e0ae5434162068d68511ddb742c779bf1e078c47df8564d4eed00a27ed1ed5528ef458a8ddc783f7b0a5b552b8ac893b931a87b09b98f8724f1a10c08c09d728673ebc20a482d8385f9a1d98792d2ed4e4c311c7a4d4f157dc89609b2adf359d2cdb9296da9b4ac56fcaaea1b3531d3e0db5b1197ed18d86cc86b65aa8e24440845a47d28371db3fe8a6fb6494028894f0d85eb1e97cfb71542cdc4865b4964474e2b5a6a5c635d78e49ec2c400a34b0665d9778d871a391611d6b8f4a0dcebdd346f2145737651755863b9dedbc829f9d9a523fdc979501c20f28dd4cd18d735e6965bf16b32359a46d2d8802d6be2027987c70164c2ec4cc20589ae6b6f15662966d46bcdc3e2766db67b8fe1a795e413d33db1f0dda3d94b124cccbaef27a3142fdbc05119d249358555d726e8f674025f7684a3d3cc703bef8db5c33cf6ac457ffdf74ee24e269af148a7bb54e3797e33ceed6bcca01a0f22af53ce9692c352f73a9d07a5bbc6ba05d7c069d42cabb734e59cb3c5f9a28ad45260f0352d7f488c0a366bfa428c330c851ce766ab4d2a4d8bd7359a536d258cf8c6f9f591bfebf4548be5b3663a6ea024a87198d32fb8ff587f4c1192d32b0d2573be4f59aebef16ef3fe04601f0e97d7d28d9aa3353e06d9ba7a7767d6424360165300bedc8a7b3011dc437ba528fe9514f97a13bdf192b67bf2a1df60950dbf525b3b685385215a6e81decc79082b2aca3723f54f52dc371771dd7daf2d016bb7db35d5d6507e58faa2d61aa508e6bf969c0c7e49c8330d89e432bc492a65cc6292b051f5b00c1708b6c4e560f2feb560b720b72cf162ddcee919dfae6e6918317f3f81356639156eca978fe2665d14888a560651f5276f1d7537ab86f43747a27618cf39df2f918bff7f77bf5bcaca051f4d0f600fbe53ac1685a5c9058e40103b0f703addd285d274ca3229c8c17688e1869a047879470091718c7f515d08cef2941ea08b9461664fd35bf2b7b81d6ce64edd761df4f23a204d14b426e50d294ca0442ecde197d60f15c493c8575476f277337b6eaf3b141a94e11b163addd549777547dd7d6f4e9ced5ee5eea046cc227832fb5ac200f2dfcf0f8dc4ca406219aecb832f3c6031ef964cc41a11a27d2862e6da19f98db1eb34be6644b18f37ccfbee50578de1e8306ca0087dd357abed5f08ff038e6e740d952732cd6e96c3377ee60d035d2d3a96550dd5caf54c9767822a6a67b21ab9a748f2ae6fb0bb64eab1d53247025fb49117cbd2066f0dd180bbbf0dd5ee16f7a5989ced258f6c1b1626bb09b8cefd5a4585a0268da005e7b7323df14b5d59bd921d9f1ab1690fbff5109d62116069106d00a7f17e939b4961d942b088f901c00600fda9730062fbcc940045210b84fac383bbad9d45223a5aadb23d3df825dd600cf5adfbde29f59437109722863108082c12de6f926d0a14f9f902a1203039aa19fc716b70c54e297e0e42907c4d192ce98f9b48da47cbb31244929b553b665f04a3aa038257b6596a6b575f88722b189162f923b1e2ab5feac5828621e2dae8fe800377be784fdbad1dc9ed9e9d05b5dbf594c98990cd8ea525d8d9397bdd807c2a257c6e95903fe9c43e52193c6e6022e5c02abc187ec76547be26cfdf2d22ac16ed98347ff4cfe16e33415cca42466e02355f9efbecdefae8b3cd8fbb16d65d75900a66661c010bc74595d53cb2209e2965652e261624bc06b8aaf1a1acd673fb6010c41077d1b2642077a964f299ce12fbb73dde068d1d9c62466dcd4ba3f7ef666ee52346e70376c2468e921daae1585695b6a46bf960d956853057f44454fc06c54c58ae69132976e2c8b37522595bfe5d0bd04e2df34ff1f480b9fc915695b3361fffefea55febc2094046645502ef29634f8a144c6b0fc23906c9d45248fcad19a1792a0ffbf5d6c0caba04ebe9da8ef3f364b75330ab3d9cd2dac88f7b4c10aea832b41c7755f3d65e85d82b10c37db8baf40cdb85bf1804df35e05f681e85e213a62f80c8161d24c938fe833ce557eabf2b302d0eb8cdaf01e664368db3612ab12a7399bc7ce75feff2e519cce1ed2afab3a42244b9787a34201ce2e5ae35a58c0fd79d2114512338177a0b401b18dae0122588ed8a35fc06701d98c38151d7bbdb6e4a2e7f2b9fbb4b52ddcb9d129a0ba45f46108710f6dc7c96b9c76f94980101fbd48a967ebad31fe9b8dd60a0f91f9d39e9e51cebfbdd1f2f7d5688e6e71217a8b8fd297615b3d430b976dc40a3448a1114170d78c59f89f1c2eacc094e1121df667f0567c315b9860097c83d81ff146e43177f2890b2873d445e1df5b9fee5cf15b0e89e2dd5f38edac754147ea4485f8e56397bf12427f94a8f5a8b24a24a9e10eb84a49065a98f9099abb5e40809c71852d9715683ff97a9d6a27ab9489b5223efd0f10b6855862b7f520e7a00ee6353f97b906f21851bcbc12dcd2cc25aa3446dde92bb9bb8810e808396abdf91bb14ea6f0805486eca74d3db843fe722b29b3566a072d478b603d8485ded56a21870cf1f2353917e4aefed33aab4152d5df1fc0d374eea9f1e66c976c5ecb16ecbc8b596fab62922c356750ed02a76abd2fa6eb5afd0d5c113c0ae1e41f45fd7c5ba2f10edeec9902ee2d6772f9fc6fa727f98da0c0d7b763ff46579d67c83dadd44a9095142477e79bb7fc1ed15ba01e0452b928e3918d78f31b4aa9a98ee777d630781e528c212d4295f7c22a01d7fcdd3480a001b961f954676ba091cd9346464dbdd240d81135c947639e14a7805fec4611042aff04a39ed9eeebd76246341bc522bff973ec865385d2c558bff172b2a1cfadd557cbafd13171b92f44cbf502abe01f282c144ae21b2ed55de84bb91b6bac185563aae0951ce59784ee12e3ce394aabf67ca91adb31bdec704e31ac4c9d12e405475c2cf3c899c546f4f63339a7fe9c1ebec901e60cd4ee6ff3aeb67abee0d1e3db9a5d402802e046f8438acec073390b55a841400bffd6862ad42d521a776816bd8b32d4a78a057cf7e5a78badd2f89456149edf6b20154a8ad30c16bd289c3d73a278ac6eb76e0718bc4dedeac46a0752fe5fbffd589bc72cee2c27f745c46527436bb2778ed2b6852d930a650ca8fafaa7919587cb3d68369f68b994525e9886ea171dd76d40325919b7366e2069959583fec600098e98189d4809cfcbebc011b6f8301d7fa8ac6712e547072aa5c629624a7e138f82027ef8f51889fb5aea15a67f1fad391f5d28f71c1ec4c957a213e64ff7e21adb7ad56c2ffd8365d03bf79960101c9aa9cfd68309ebf92019a711ca7ee65ffa4d8030e9fd8d3ba68ada3fa950799703292a15469375f25bf0f46d8f2130faa35724761b656048560eb367eec7ddb18217a37a59922cc12655241646e4acbe3df2ede3ec8d48c825730b57add1be9605d6db57eda6f2cfce348d30fc5b07ef1bd0c6450007167e3d33775dda6f961d6383b400d12791d12770e23b4d3f4ba0e301743b760db874366f0c20f48f3e35f56834fec302d79b973bb201b475506c22793d7769b411b7de03a62eae291393f7943e9ce9faa7767d5deb2b2a39fd86780373d7d1bbfd3bd5f74e74b789cc7ec24dcfd53ff677ea8100ab00d5d5b894557564294f44c89083b54b0ccf030fcdfd6e1da57586a0be3e80e41636057462595b229a252d9de0f070a14da6b91f686c473b49f30e735649cf83d6e36820f789b9679576c54f7073513d3a70d105ef9d9eeee4cb2b10e54284f1b500754d8b3017d0840ca6687dbbcb5d91676bbcc9f535aee4c966bea9835269d2bfff95f65ded6acf319e7acc50a095b9b9ecb35f8dfd559563817e7fcc97d8ccbb7d7912532cc4b45db3b7946a33e3a57fd8c5187cfabecf86f71f755cec59e4331547cd0f7e71aa4f9abeaacf00252df5d32f4ccfdf9ad6ea1e7519cf324cb9e1bf6bc00eb149c0812f80026d5217607275a10c517d194bb080d4406ab106734afbd48131d6f5360b716b02fcf364ec397cdbd739a675ea3fe32d43853d6bb14e11d272899466b20581301b8d420d49869055a3e7837a78f73684a1dcc328709ebb5dea382fe804fc94adfdf5eff1e3b19bbab6496fb87b6843e7d38254263a9486b6e8e02c917bbaea8a66ce145bf0b49bddbbe8b48b8ebcc4db9c923f96886220fcb79f6f62080adab73823b71c140f4cc4b3c8d5fe6d021216f542b5e605ff181832468d787d90566ad7acb593651a5bdd615a9c503feee9ed1ce52fadccb7c4454dec3ca7edaba9a7d46346154a0a8fbacf08ef86cecf3af0713266f9843d63b4225c656ce69cfe16aa48d39afc6bf8fecca9b37aa4839073fdac2c1716a8f9010f337c9fff94bece5f9ae2a30d31ec63e4e424f01650d3c1ada2a0464cfe7865963e3d0677f20d6490378a4c979758a74765f524d2f9859b1d11f44c141892c2a9a707d4610f0107e4418bf19f05e424d4211e6e8209c852950197fd7f00bdd415c628b76a8e276daadefa8699c85b4c7fbb86e964a78f3bcf1a88ff5159e108c631fda1dbadb516554133431f3915690e233315fa55744d4e8fb729df58ccdd9ec563124efe9480f6584ebd2647ca11be5b961c28d615bbb4ca27ff5c44f4be9d2bd1f69b538ded785bcd7be480049a07a968593b4b55807ad3ce508853cced2d022c4711ba0b0b33acb533681623fec8a0cd6fb3003ac8b953b147827fc08fd39da4b54e5656ca699b0fb3bc1518e938aa64ffd5bcf9e84f6fc0d75527f2e324a33799cdcc65a6a8ca1c7fe9cf257e0b6082daf1e681c5ad76573adf2cb700f5192b7404e3e2ccc64c320ee0c4a531f0e4b6692aa3be2e4fc9646ac2ca96fa97a6ddd792c271e6b6f02bdff60571334fbbbac368368b63c39fb8175c3947f43ba1edd5af64ea0f8d9db1c29ee5c3b493d5d3016c0f79ffebed64ac10328b49e8679d5ca1b2c5f99d946d76a69dd251e6311085149b7a1d1233938111c1a2d17b14347202bcf6b3d53024df20e6d8b20cc6cd3d8b530f9c9c126a4647d183d66ec87b352e683601ab3424aed58b58f65eb5a747e1f7c3a7d037eb792498fc7aff84fe3be4e6c341dea4b19bbe1d86dba243c47e7caced7c7b18722250a5f2c675a21003669b4231572072208cb3f779e4a94981ee30b14287b62fc682984bb6a0fd79bc4ad5b7fc8ccdebcc4506391796d1ddeaf837896fce6ec3fcd7547bbc489a2397733cd3122a7d0bc760e8c58feb6e8d5bc5428e254f06e8e1f96ec6eab102c89bf0671d2b9c0145210e7e28129f7dcfe5af12384387db2f4a1214656f5203398e9f511992db35a7ef0fa521191348b7c5c4568ee2b39233f4f360034deddbb4185d959a1c2f16cf6d237f548d7353c18d3efc0fdc6dbf831d32cc616358f66e2b0b86ce79e91c264ef9846f554b61206bc2b8d81994e8e242a311d4c73f2cf687a518b4771a02ff468f5c21a354661c771e56c7f34a5e2e4a07c63dfeefd8ec4edd808576c399e5152b0c9b34770eb1fd376b39eaaf46935604b0038ee1d434c84dd5fb8c31a521c459bd3d22bfdf24f63fc336175525d0ba33090a7a8ca5f7da8b2e83ec1c6fa1cd0a1bdcbc00de93d51ecf429a881281db928b1bf5f93c971eddd4ab9b77d94068a6cf61e795df55b4c3572f50e213270e7aec2a0fb56049486dd0308441467367baaa5c21cd666d69c2733976dfa08eeb6d7ec601622a3fe90ed0eba4116b4e11457927590c8a8173cdb83e0c9de8921991b2c5df153a3df11cfe7492787b70dde66870dfc4f899c70a6b2935d83da2f98b76406e65c4a170069add8576e8fbc120257bd92f583d5580506da82d94976e332ad97b66ea72702ee43dfeea4811a6c5f70b4c54c49e07caf90354d6083a41563427c5cb8dae1454c5ee5cf8d43fb0b3c5b782c503c86f4ac34259070354d2f5144330e21fbdd7d7936276fb66228e78cfcf027f939fb7c0167bfd99b3c9b3dfd6de59a04474fb23837717dc73c7462f09c3d61505e4ef5e1709b9746f817fbc01e6c289ccd5d7782a5dae6b2eda6f4a38d0c7144b5ed2fe15fb9bea1c4952ad939757a973eab905a806db85b0dd01a29942c3222c6501f62f7a6f6690f993e368448374c2fde0f20d2ecda56690537715a7881e334d374ff24979f5ca48eb4135f6b06ae79086ae9c0ba046c61821922deccccca6570a47d4ce567f00ae887563753918e8b4666f8f359beeb9c404a61e8f815f993320b0347d42e68115dd75a17a69593c311bd8b2b564948fb15ded059ab3a0abdc9f32a4289cd7621247b9650f7ca18eaf9aee06aa4d15cb5900f00a453b1824f656ecb7e07cb12f926e92519ebfbe98d6f134899b33f731b33c950d16a96ceee5a2c409cd30b07bc1422f2f96764d52ac970e5b3602889de8c9f2334618655b981b39c23fa0ae83c44ef1f4b74da63279df5909c0aa498dc52f6577e531f889ba5096799a681f3ea67a8a5306c063ccdfd9e11ee184b60b5cbfa2c369f6696d0592f185d86bc93cf67e2deffb709e39414bbc6cf7c42a0cdebaec9de6a57c184976bba1a3dfa90b5afbfc0ef14771db8c1b256a8ed54c4c2e948091cccb41851d4375f02fbdc42b4a41936d31c3bd0be44fd94844c522195fd08fcbc8575ed7b0d561859ab7126d5974549ab66424eeb12ea712c308be94a9c6c8488669600a8aea18900540f4d659cf1887dd469e1883e9d612970638f2c59e8f2424199c61e9f834c86713c51a30a6584f4403ef3d7e57ea5cc3b9e1becf138920714a251fc20cf415737a004576db173901accfb8db9ee0492077aeb3393fc04cb1db10b9fcb2aa4d1f0184c1e592b8b84c4aee978743bb37609a5327a4e5832119247c63d3d45dc8c9de85049138e0d2e56793013270e92717fb57a2fa885c87493c872aae4e2a722486be7b53253bf7c78239faaa8f017d853beb246e9ce4f2208dbeba1ade73f6ef9d6480d824eadeec664193bb33366b452c9690766e5d205785078b2f5b787e98c23b7d288f0e87054ffbe30c5933ea75ed75a4b8bddf2307f11bf60a089d00f7f22820d703d1cca54790c4b17244fcdbf4dfa148814f3f5f93aa0ab9f65492e07167a648b0b3054f35e86b65b50a6203bac248d5dc24b2c4b247033d1e72230406ea9901d2129ce0496716b34bb890a4abbd50b09d6018bd51311fc737c5b4b9cabf397438c7b95aa422bb95b2d76961a4bbb1ad470d61587846f09db2e768d08c3521380f0e0d82eebf20f1eb7abad11cf3948b310b06384e3bc9e6cc6a600b006d5ce199c23df72361898863935531f3dc47af11c5c6ae255b1ec001548c0922e65007944d548e24b69f096f8787e7ded6aeb25fef693a34d0f13a7e9210eea16617386ed913ca267189581fdbc5073bc82d88efef6b967644e46efa9786cb06ee8928d916950f747d9d75fb0de59c1cef6f04cd604ee35902f090eed0509103b50cd1ce5f217ddafdbcafaa98594e1725ba113f9310e318628f310967ccc7f679125ea9b8da522780d106bdaff9ab627594de6e3369ab644f06a4215deedaa1bf46486a4e03df2f0c7282abbe46b26d561de32f780002642514c0875e03f8bb4952a9e2dcd7e2789a376de024eda1d2f53324643cb676c3867c0ebb832af6926e43bfb6ce42485698dbee292b326f7e4ed8a1101cf6b59e152838fc8287bb6013584577eae9fc3360e0e675cf9b8c4f25493382cf46ac95864b38c0bfb9c41c6f6006e3a47ef822d034783e21dd2a5845ebee92a1c25a1e84f9f7a571359dea6f1310334f5800c15bf553cd9677b98be36b8fc8c3c48faa722025b26dd5de5575d1e9b02242619a7bb3ed914d2733209393e607254ac85c7425e620e82cb3f869155d656f9d21e036005d1eab19418e62b20529c44419dd5d0768031d3ff44b7c4f0ab6cc0f6ee1fd2e7ff10df84b6e360d5127cbc99fc175f579dcac61c7113efa421b0bbb909baeaee2b001d455ee25f4b13e0a23c56c4a8e489c3a7444fecb1ebd5f2f8af51b7d3e42530c0c3a43f6543f6a15953f9dcd1ffeb0ea9205d8fa94e86fa720cc0b93d7eb0b8bcbac9ef1d1b8a48979b7e68491007ae395df3ec81c662198fc1afe56348a70af7f3ab689211151dffa95f88c82ab45ba233f1e0bcfdd1044c9394f9c74c8d5d36a6ce3141b237d2533f5603a9c5f6679375c4d052ca81f57cca9988ee6e175b438484202f7b4e3c51f23499e635683d0017bf73cc7d24541366fe3d4e9ba03c042e10e3652b5662bc190b3b27eaae3e091948be4841b1b13ba3ab5071cc3f061789e3775d47c0ba88ba267844a796a5449c997aebf36173652985ed30688917e972268c1c00e27891ee8e25b750dcb93f02003c759025f3982c66bc1d6ed02d8c07fb1e87972070047f1d7b86e237f6ba6c2d967cfd9264594dbd4ce755996f5d7625d2ed48a06088f677cbca347b8b8a9d264ca08b4087a6628d15147e7cf265dbd696c7ebe343601d6478e95a216107fde2d4aada8c03b20cfc2e56ff2918d0cfe77027fcbeb838db89d871d52433ce3a391dfcfad5f9ae215b57270bf470148ee415eaf750a98703720e63257c486cecdb29f59627e271448605d5cf9d339d0930337fd3b76e8eb3a45747863557f78b77fba98c19c821031c3df3dc4636bacfe090bf71bfb27fd984d443bf105417743fa727562b3bb749065c7b38e1dfb1731e5c0528dc94abdf632be8f859b65ab44bd39ab3e62704f8f1b866d1ab4c09f19a36bd487dcb9fd41289b1fe6d0b59205bbf77cbbd166a474ca0fb7a62697969071a588123da8e92a43072785bf5a46fb959e0b6f23af7901609ff2c50a5927b26f0830fe1265a32e3a92b13a5e96f0f01ac76e948ba486f59d43b649da764af0e6ab647f7b0a5c8f06069f338e3934bd28b12715f569e9574c31d1255e9d95ef4db9c6a06b8188842b34a7850e45f615d2270e035ce7d8dfb5edc3bddc8e5c6a79b66d5560e8bc53fb7560b93a59e53cdfc5929204b9021c52007dbfaf6cfd4b44439d3642e6dce6be2b68e2482a312a3f1455a1b2109d62d011eae488ebb2594d47da47666751e6ac28bd29ca2b996971d98e5aae4067e6e3dca19bd4a8f8452bc47b1e75953038a3e15aec0c8685720a4b690b1459c0ab0ceb9de5f8d4f406f022d162f736e07fb63e5cfbf09f04adb472c2efe2da162539a0fd530809a6284376789106ef6f468741d069ef6bb1b1b75b96149cbdc8b1eda95cf899da44b8b607f5328832103e02c7d357194ea799824b09746d2034259f469a67334ed772e7275e9cd5e9e53e4859e43cd891575602dde144b1848006d8af57b2b2aa16d046ee2cc443145f57fad2b1c6de0caf92a9d9a8bc4774e97a7828471f54603e50cc393e34f508e2a813d64b1ec510a5ab9dd40d85b556521214276ff26ecfbbc93ba2f745131dfa859471184cca89704ed9366ff9ec84020d732528370c87d392d840b05882af6c23290508d8aac12cb55df7a0d1dca92f9c6b84baa791afec60cedd725be6ae51b781c558a1d4e18b57e826271bb5e9490873d567118ac8b834298827c58b0b6f72962cbaf9e745903570abacf51554480bc7ff570171adb94331b801a8836c97cf3cdb513cd7bc5be91aeaf957ec14ff2da5a8701a8ec1b6da2042308a0df1147a96e9e4d79c8145d1844591ccf66f879319dfddc9bf1021db833cf4538041a22585648b2043118e97626e7e59655ced4d0864dc833263a2839900bcb0acbe5be9d8ca42a97fe6fcca83ffa1d23e8228541f78c94142249a44195ab500ea229476d22135c03709379cfbb92deea1ea4752d9b1b5ffc3ffc70b7c3eeef531a014ab8acc8be8d42655ebf43260ef4712c22367905b94ed322f8aec741c2d8dd21dde721162a5b66d67f027da3c7b49b07d26b7206dc0d6b010e28a2d7bbf578387671a127ed3f29e2a63f1cbf916bd435f7d9032c6a2e830254e5f39f42fa87cae01f0a46c3ed5a5a7bb09c4a7193a06c615cab67653cd6e4b23ed87d96280298a0026ca133470bd67bc4bce1dbe3ddff740ee0eb572efeee679665f603d239f55cc74247d16f05379692ab0c258b3bb075cedf85ec2ea1a5520e294495f5d246d87e21800de550baefe0a3d6e34e456a7d95cdb13a2075c25a6cd20850aacd298883acaceabda1a38618bd0a56e737a4d479a7673766e78af6a2dc09b2012c0c2361372139782630946d6770261d98b7d05aa76d6d565ce488844b93c1de24cb94ca39cf043987821717761ecd8151fb2a6505484782732459b9b1cf0c43620589a0de10fc7999ab65ea2a4afa2b861df7bd00d47bd2bb533dead9d838a4fa97254d8bcad9d38e0055822c5ab58a07a8313645a78a5a05b32024f0f8990e241b6a7e362259e682d7026beefc282d83aab3503d471e8cae20757b734101a66cc623bc1a87ed473cf896dda319ce0ade1329be65264ecef4563c9e80419fdd17dfca98e27beada4a7e7bb76db63f4c108ca444957c35c9b966c741dfd0aa462e97e3a95188e249ffcba579fa9dd8ebdce5cc1fa008c50430ad2876112f0a72b48b420774be98691fb09545c2b730cda648ae4cb60f52e1001f68ef29c10b19ed2d2b4629015314bdd059be5ae811bade32abfc434bb1850183fe540b79a9a55da85fb8a2b33d692a7e07ac56189e059cdc25d4299e353f4132189de14c5e048940de25656d3864f5678cba7cc3162124e47a71742678b2d917b22c79167eb8b33c004ce70373aea4b33cd13f6827e3aa90ceddf3304ba37d66fddaaeb2667973531e3a49a436bf4496b865361aedc0a6d62112028a5bce605f1334c87bc4a916cd9784f9e36b4016dac20bd21be4c4f6dc9107c91d8d2868c57bdccfa4db4bcebf077cf91322cc8e623f080cc8e59b9e97c3f70575a893c246687303b5a42066b6ad8f1f024171214ea1743092be3275ad5285ec080f6318efc7579bd49ac5d54b9597bd7fbb4d5f333a0af2de34f2f96b7ecc604c4445c7d27faf8f33853b182cb9b5a9235293ad5e5c64696e4eff11cda368d98e998d1bdf3ff8f4e408d711166b18a1307c5386424b2c9910904b32b8882fda11b859b49d712a9c32effaa00923ba532ecfc92399400771d815aecd27d58c49999d887a388518ef08d33e597b39269b776e8a0a359d99d2577ab9b449a349b7e1318b6f654629c6781c989cbae7f815151c985f3a73e8f4290e112d4e2656705105ff112cc7fecca2de753f8a69e395d0f0f60f752b3106c9c00fde659c884c1793919cdb55bad2e44c746960e9798fc5d539002f81a164157659adde43e6e13afd3acfc5721a83d83b21601fb43173c62e9fe74a118e2e1a275c7e5a168e881f6151ef820f95eae388753822931c1e8e1eb282eb585e6b14e9f971ac5aef7680c771b6195023a7680475d9a8d33f816e5cc9a9e44552f01adf61692b9a223985370e1de51fd20a7419e24ee28b6e23d0040b3a8031663d5e103145b8ef6f930a4abfcd54f1c1ea82115697f4d60594e925407e7237a90ee2ebba3ca8cb22fecbecc8343c3d9df8b7b87bf382467e1e8e732be64a65810cef5919629fa38498590eb4e487346e9aeb718eecf42c425393c37abc2219d5c35da93683a89f64a9e081ded3ec1e00c202057edc66cb5fa047faa1a74b0f8a1947b2dc8d827009add54b6be9568643d1105835a355d6e0b1da954bd0a16cdfb2b5588dadc7936ce59ff7398bb0ec3ca2b319b43647dc4fc4a6c4b2d43bfe4736b5d486326f5c70b1a187832f55b207f8e5b5cf9e615e4070846efbb20f1d0f3d895a2fd1a34ea39c3a53861a479bd75f610c858dc6fa4a961295e8040d7c372b443c7adbc8ce76958a0666ab721adaf49396b54600bc9d9e9649e4bcea893e732a182065b43ebcabc430f8b35e80741f1532a1709fc592d43fbda2e66a2c7bee18be2d49060eb6f053ebfa5e22aba89748ab0931e1feebf9b760953a23fb9e935bed938057a7c596aed5e331512c8375dcf5bd248a7a6a656f1968a8e4d29ad6e7a6f38210c9ed3b042f32f4474748b43c4780013d2fd74ec2ce0d1c04162b81432ea7b76242bdb666985abdb9cfb2cbd3972db431a176d4c3aea7dd535ba00aec06aea291a47ff74c15ccdb1ad22ae65dd03c3128acc6bba73e8c5aacd24fec6f4a2f77c06f9a67a737e41141dc5ab6ba016a5fedf282d76b34bdb0049ccf9c7fd3b7fba264ae3cc7007b7e743a4f9590be092fef514afdeb50824042ea014a111bac313575715d4a6937a6658ba5077ae0fb25a56cd329191bf7bc0929b1b4558595c1bced1598919611c7aa12278f8db4635068270c5588922f545829fa69515435fecb687a1ffc1c8bcd24f7e3730d167b581c420aa46c3e3f49066089e67bac2b3587eb91c2ccc4a7526828864256b0603eaddec394bca2d4c6a577e7b36074535d9759d7a939ab81bbf2a61812725620d685e8081b9a3f32ae96fdfabf28b8deb0bcb54ccb35c96241454292b77739912998d14980ae1cd2bb28b62b96c5808d206c549f61a85d743eaba88383ce672a7d20145b2eaff4ec692cb269af4b8d9d17a3f4e32116bbb780edc51d2f4a52330670618ccf6292fc2c39e9f4cd4944d64fe975f582f396e184663f69b1dea869e411a210cd06d8ec685165122fb56837509b34c008e5a0ca001fe5a2d186387d93234ba19f34f8766ae3d78a5640cf5933c9d865065797df2a054c59953468ebc7a637d3c19b33ea4b765c76f495559aed6d89e81dc2605f76ce20a09dacfb37d7d15095c6f4ef8b575574f8c95396b3e8d575d81b6023213b1a86ccc94488cef21e0b946ffcdce442ba7b93cb8ee0c6d3a8b7d9a2e8176929bdf6040d50ed115622f89d9b348c72d7bbcb2fcc9ab685bf5cc79dd05a3aef155a9bfef15dcbf3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"643649ba80ed23fdeeac84c02c742703"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
