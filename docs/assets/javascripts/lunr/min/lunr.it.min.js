<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dd25e84f7a5a72709f98a4d2caa467e2dd25426e785df082acf0abf39c093204df110355e90c3491ed0d2672c845c04b0274b3a34b5897a0e9a1045823b3295ded6b2c2e13a090a7c0af5687fc0133da4864bfd857b7d58e75c6bcdd7aa7ac32ee699fc2e0f226ad7fcf7197aee720be189812d93947db6a80d5195bd395cb47704a550c83b270303f92649e3b67540f237342a4274b1da5056e1d02c3fc79dfd5f8e689e49d8ac082d04a724695584338d2fb3864345d23324b2b84624c47ae744f3e2a916bc8ee0a7b528a746955015751aca8c6995ff085826bedaf92e45b0304e3d221479fafec82bb9b932ea8bccbffab970d838abd0448371253ee3012a5228436283f047b82529cb54bd16562ebf7d83a4ec043ed1003f00073943f09fd6ac4b5b0ffdeef4008dcd8fd294ce8f4f7e85bc9da45fd6cd6625b27a28b9354ba39f16bf91a07b048fedf09dd9d15f65d95cb65f4e1a27b5399659b01462207546773af20af9251e8f22cf5c656066ad77d8127461a97d391f5484381e3240c4ca6e4387067c02610e86c6735550ac786cebd65e5d41f5a8aa9ad5636c4a588a0f380ebb8282f46a5dd99dff6778410ea4e1afb18494d29870bf4b5d4a93575bf9cef39151356625434974f9eb06e0187976d1e99e30abd3febd6cb6f71256e01439ac6ae1df736f462e36afab460085abf211bf61429a11ed7a0033c93ea6c9f829b1a1dd63f4b260b308d9c9bfc5c6e95ffa52c65a88a87172943f2082d0a60050d22a7598eda51344e72a87f51ccd3ce7a7d91e7fa30b7b8e13f0ff310608cb4bf55cee497b48c97584e77b16a9fd9e35e61291b1cbdb74917cabebee4bbb4e8ee69ab4c9cb5ad2476c55c8a8bb58551de0845c18b3f42fce919c1255c6eab870654e1608c94beed19e0f7d089a9923f9e31cbbc9225184f68ac37b43fcc4dae635dbd2f0a76590ea4145db001e6a1ae0909b588b82edf394bd390b87e538faeb15e80064d8599c6b2c5147bcd52f04b6ce8fc26fe972a9786b8bcb3d87dc6c4206bb8c9b875321c1b715c6bb3954dd9777cf62f2aed040383509ede428081a623034aad8c0b071ce855e95adebccf5e1e6662c881488a469b5860f4de75b26c975ab7fb76b1bc59a749e7755a7a3a71e0f301fbd4c1912517f6e3f493e7c8dce2d43e647c5e7c1209c5fbf6c6f0125e614e2ae217cb2d5ce40604c3362575f9529e995d72bdb90594e464bf14d57eaf4d567f5343841829a5aa6442252bcda853662097b6dadc30177e4c4f957595e662f3b7a018f75939b25188d9c3c1683d43a093a57b0cf29b4db31072cef7c756e0f838de5d98b5cbd0729754339188ddbad9ef53f9d97ef2d6bc17e63789b7ce5887667fb69c1fb90e51edb0852e61db029e99808c8df343c367ee58be5f9b832dae593d1a7d7ecff7db831f04a8ddc5a58d8bdfc0a345c9124edb603994ed2dc0ae85a36416867662b59ed325a0df996a9faf02777ae4b805559e7a7dbf236539aa17504bca5ca835314168404b840c33d0caee5f74014180ecaaa1c147919a6c0fecc0a42e4dc2ec69056a1d490a73e9f00ba0fb2c39200610053f334f8c8b30316ef88e15566f2de8f9893c0554d93d084344afadc8e2e82172a7d020f0e7903613717e96e2c348b729d53e7665fc1ae633cb6c78e6741773607b92c9ce76055278a87b99c3716d0383af0b2ab1d6f5308515c3c7aaac4fce1a1a41300a859af2092237860c140a1fb1328e98c18c6c4ae004812386975887fd8bf3bb7dcefa1baaf121f6909b12ed1ef9616a7c42e165f7a6b2d0dfbcc71b00624923b1763d98ea1e898924b000f614e2098d8bdb239c0dd26df40e073d8dd631a7a2339d552d1fd6f393b703a2d84bc328a794c15c478f7faedee9e9ced7fb214c1a627fec4866c534ebd866d0f838e579db35b7dfb688f5d15cc86c3037983abd952bd9b7b8d45b1036bccab9387af724b8263a7417c5d3c2e4d6c59c65fdf029aad251c6678fa0df5feeb77ff3fb4b1ccea74b17a2e6ae8680ad82e17c27e6e8f7f2d31c8e698232fccac97bc12c8290742b55c39e59d75cc67156b3e706838e4d8e35a420994212a963355fa0d0da09c24e481cbf9da2b52a91c2085077e0cced6d4dc6b3c53f171078ef6fbdb3a4526ffb989e0b7327468ed3520155aabad37104c387e93615b2c359b1240e67df4c2bbf27afc36e5e1ad32a889023c224b175357757c93d439531b419c5587396db0f4cda2df04aa78ba1483fa19aa75faffa50635ef963457b0d46e3db02e2846622f2b117d50489f3e04cc70043b9ecedc22f6c80e584d727622a5b51f9b70432783e671d9671cca37667e651c597804ac0462f58c630b97f4c4453e95109c787f16430ebc2b71bff0c148c1c4b9d5ef8d8e033b958b8c8fd2e168e2deb1b7a8cb7a8766e9646467b58c0f484e66badb68fa4c75b20e1935cadb4eae22ee483b4e73011f0913c318345bef36b9e650a7f7e0a132afafa90253c8c00e75bbad6a7abbd4ad5b75ea353e5e9978563f467164387be6e326ac23557d8fcc4c8ba4e2da8ab9807ccdb7c61c743c52a17f56f9225181d1adf79382e58d651485f33652b602533963891c418a31585c467afdf47b0ec6504fb287056863aafd7e8c367d19d643ab14ba4c015fcf599a99716a6080fd8d8b4d9436da1f5be3294d1a5aeb497fa6b38a8aa00af471700de4f6e265a7dde07516952ebcb57c7f0fd1c71da5bc9bb45afbe0b747291a672880737c9c594a0c7d11b2cd932dae5da1ef3c240f0563840ca56163a0315e0a97a8a00d5a23ceef91951d0c34b6c6f3256eaf7e8df4412f4be015c488b1432e225349e270980dce921d9dee8d7629d058092fe6d3043442bcff645943be5041540aaa5e437ea8133be88608ad62d860b46149956569b226920ae7986132f4d6d482346b851bc84fb5aa91c048af93ef6c3534927aaa35ec450332ed7b151e4a7d5f94d4015488a3e0c474d208a2766d79730ef1f18c01396c1426afbaf9b2f54723707ac5e0fef66568468be68cb0e472fdb9b2fe0f6922d548e79e7b0524404b73d4dbf0c63672af023495940be7b790c134292807b770ecb5c6664ae1f5126ee95ee855f61047640de2d3b65d3d9a750462b5908582f12f94931c6d0a11c8b15a50e951aef0522a938dbc81aef7f99ff93ea1ca45ce09f83a236b9acbf708d01cd8abf0b66dfb665afd7b0497a528120563723ce4e55abe9f892c09d85cb494eb308ec79e033da206d1f2689d58d0986d76c37c8b06c02bebe222a4f86e1aec9c76ba02d9806b738081f7e0fed387c77115381aa5a385b530daa3a8640a7ec0ee5cf7a9caf7dcddc07055c564c70c4bc55a0479aa041552f71da52d1db2ae83e904a785ce944a73ab5d715c41e98c86b8ed256362074fc472710a8cb84726b81823354a2942f8c27d2e723c6983cfc4cef3e0cc36a3f80e4163cb3ad9584c23590ec05d8df6fa71a3b5f779a562d3b64768c1d1a07f34d66b0980c2277a12ab16094569f324ba73b81633d3aea0ec6fc3e5699896a57b4a778156ff66a96ab269ecb22affeef4d968073b99dac2a46618b83decb9e0c63a073c2dc1aa4523ba1ccf6134a9b75a55bab09b2dce6686332e7dc309c9a9b73ea59c0390be35bb479596eb9fdaca3d49e29b6f9132c2f805cb176f92776447945607554e474a235989b2ab28c3607eb8e53032089a0cc06b824d0c26072a81cc0eefab2438db760d2029815245e08560ba80b2f07324f89c0dbddbd54f1d9dfcb907d7104434dc8d45d2b69c2b7e068d880805fd180d519148b1dde2a85d3a1f74f05f751a15303448757560a771280a2d1f9c659034b29369d624ccc184811ba8dedecff351caf6139378f0a99b4af19e1317eecf09838a466b7b93e08ad59987ffef08271334c0b8a5cd1955529da910c9b69b2f6f43b9a19d8c4ecaea1e40f71c2dcafdd7464635c548e3a7e7c14f0cc5b402b5d49119882e01191faf5daea5c054e24de9e6b264e64b92b2da039b0c4492c7f72988e60eee5f88637226f75b33da5bdb8dc43b0b51bdb0519a2ca2a3a9a82a1b60283fb993817c70920de540029d4a0184c7b732e8aa51d39e642be7af85508aa577fea18fd8ce42b219597001efb83a58dff41109117cbdf1c892b6e62a5260c15ff7cfea248b28a5e9ee44eb9c575173b999b0aed614a00125be05cd20d6d806a36c645d4366aa0b3c073a083eaebe5c8de7cbcb8f0a125dfb37776c62ee51d7d5b3ef2c6f16c23696db4f976a20b12712ec3f86152632051ab192c132d42a938378721d52a9141ddb08334d5f457f8a85b324f25f828fa3911b91cd47d0e191c7a231bafe683e155e11347f984464c8fd368120d0a76e0a07e4dfce71c496407c21c88a72370ecd7f0e13b4bcea93149cd877fca9113c6b04ea9d9866d65a55a0217067cccfb07e81c99fd9d4274a5bcf65a58cdb1b3bc431195f5e52829b561d8f2e27760e2acbf250915ddda922ef723ec69b128d065d840e9711ca2fd3388f8765fa1605081ad8eb15bda6d18b779b160c204578ac8112bb934d504cfa49930076c0238124b6888b8f03b4fcc1ed7946f2bc5f86791f1cf0439e3c12c9045653de7222e2968bb6b41ec5511e670189919c03d0bc964eb09ca81ffbde22c64c7e509bad0d87ba3f1e53eb36f515873d5cda8031eceb51552e5aecd44ab2c6fd7f961b02c8547a3d433275aa85f94f10c815206ea3cdf3e0e52c65c23ea49920ea06bdfda1d4897632c533d6e7f92b70922bc745e875d322cd4b6e86b62dfeed6b37270f954eeaa88e486efbd99e3294bc2ed579e6f38302d16645ce187cb3fd2bdbffd699d73bdc569827ba8cbcdf1128b9a86f503f6752e513253ef4f731d07e461e62068b9811b05f493fba831e011a549163007649c0c5e68acc2d10f51884f484376514208e68479a4ff1832aee756c7bb24caf103d0fca2e4a54a57f8de7cfbbcd58bd5d4ebc514d8aa3a6e9478734ead97728e4921b1abefbf63458927e5a893ea986cf6b29c0aeda5711d7986029fcbf66ccd08e8aaebefcc33eeca6f0dd244d059ce9f292510dd0fb11976c088e95a8028ed55a1a5b8c8ecfb74e76db1f325d976be02d2364a440226e6d49cc960e3087528a86e4fe183cadfa58c173e049712c87bb517aff804a59cd2875276dd45805aaf0c5046654eb3825952a269960bc0511b5ae2f4d6529b7684fb4a932b20d0f5d6b7060c40bcbbbb006a7357177b6295c3b8a5bd5c56637290dbbc0b5a7a18b59c526f6232299da0b9a812ea6b96ab9a55cb49a946eebef762ffbfa0d9e9662e80e006dd41c7a57fb57a44fe4616e0f5ce01c7d7d38f844964b4443e3d1b7df146850be318397a4cbc095db212f3de9b2b78ceee081e15f51988255bf331f305368f228f058bd2e923a27188c1fecebafd037adc799ad8182f4270a81fef17208b9c84c04cc87246141c8e8dadeb80a0ff18c7d1effc22f6d93abb39bf803dbe4803bed65d680e75afdfa1b7db2f8263201666020623ab8e8b456f2ec7e2f43e28f4d75790ab430b1e39b69f129c604c8b1904a0c2d3cd6276acdba9f44785ad7c5f2fb55389e63bd4a0db90469b7fc34a7d1b4fdc120668375255fb6715a176cc19c7689896fb2ccd39c1d6aacd744df791e7c494724813c29e71b8903a6f2d6f931e6e87f83fdd6fd8464d633948ecf918e1f9315710391a961197d1929da4af4a60460817267451273e516180b9fb6b8b6a6e66bad7936f2f62516a1838b4f930d0f72efbef8a93e934ddd851826f68e150b18358705482817496f2a5aa92ad2ac9233902de8d505028c5edea50c52418703fa0d5d06e9cc513e903e52b2f833e1e138e2b1766681afc9abd211d843710e6ded95ceee2395e4607ea1e72dd06ab1acf9667d27a6b1806f7aa2ad38b930b90bccbcc397bd4fdf36e8c3e127287aacad34e19dabf3f444dd9f812984743b7760d2e9e4a71fa2f41583d821e6914a5ebc056f9a90a86f5ea1363f6a42d04d3da6d007120bef35602cd838bedb2ce082cf65e4ffd61777383c7ddb96e0a06abbff51a5f59eceae358565223ed903dacfaf70fca2678e442d33a7af6a17d67bbf1f0a7dc984a579cd8b37e9f00672af7df359612cd6b0a90d1b6248b0b64dba89c173dc9389337572840da82c068d7d675bafd73a7c4d7f9e17fab3a72ab6e68e8c538854f08f0e847261b246073ab85d2ee5a7c119f0ee54fe0cde810dc6b0f8f7df1baf5f2d6d4410ad7fbf2bd506412c49f115a9dae6d20a4fc3bd3597d9518d3b95ea16be2e7d81c4dbe0409aea9006c52f609ca1904bcad0bd04742e60785e8b1ec308acb35336ae4ff8dc6467a9006de0d64dab6f255d209500c406755af50a7e5e6ea140c6755a933cd5912c83dd84b260749f24392478c7a960a06998c7129ce397792a5bc535e4b3d90ad880ae8f2e8d2502acf3334b8bda299a7511cb953d4101f48bf05edd3ff915b9cead676329b34a9b51e8cbd03c719d407f018d2270947a7f0a853c16542f8d9761b7107fe4c1b2227f0276421494421835dc437695ae660019f40ae475c6ebcca112b1bbab93758df8e67a3954dff8b651d6821adc09e9938392655efe749610bd9289eef4a76ae0ffdef7b13924c2c84c21c5c573f4501e38345e260cd3c2652b350a52c458ca58a54422d29c1cb6b91ab563383d6cccc3ba98b1641f6071b3845a8a19273deb414cbfd20cd55e67d8949a29c1911c7a0c478108bf5956c67b0d83e78af60f68277bea523f91b0f3cf93c6f53f955fe95a051f7eb4947637b358108b5deae9973290706fb335bb46391726d35ee8aa5c5c80e5547e52904eadc11e689558f8e29581a8506fb41af02b304e39fc2a9df63521906a591407419e2ed509e5a5a4b2d4b6c7665ce78bdea062ee2c450606632176ea3db39269964e551f3f466c4e79e1b52f3462735dbdb51455ef0dce3f2b02cc9e749ac4f18edd50866c41fcaed701bc8ae11667920ef5990bd4c07d24d11a5e30087d13b0c3e193c6eb06bc514fe6bb26f3cd41bf539ca4de1215acbf4319b5e667d6ef5c1889b1fa706dab18a1ac207bcdc490dd1fe09feb90d78bb1c6964a019fccd84a0b6996e5e5a469e0eec66a3859df16d6a41662ad56c47aa1003da7ee64aecb41cff9af5f6758a95b34ebeeff819859d18de8a4210626d09b9c4c64b4ae02a3f7168441253b583ea8b92fc0e5d06b33396edc42af1edd85169e06330673b7cbac6dc9dca24d5420d693b2ebcb27ef701848cd085cd70d27eab96cc9186e224fb0d11886f490dfcc9913255fb9603e271c9a74dd75e3a78b369bdcc5934793da3f830c6f998323c70b076202b356443fae1261a8f64ec2459243af504c0274358ca302e5c586fdcaf474d14fe29628e5a601fe4527fd86842f04e939ae92d1167c27dcaffd5c98f5affd7f1f02a92c05a53900d07397f1d408c64754251dbba062856c2fb3932b9d2caa81e006f3e9cb2c1134b5adeddfb7a189ca24c7ed3cef7b903cfeba639fc0ec55a2c1ed4ed7eb9b5e75623d0c045bbf1a2b01c91e46e7dce2593e7c539077697156cbfbcd25f6bd72cfd4f402dc28fd500ecf38c782282f889a1e10bda80ce7497b4d87c77cf905bdabc507b9abdb68326211634d384f1913cbd31d0e275faf36b04d6384410a00c0b9cb09afd5104b2c7ef5226e4dee5d6de7246fb0e57d3cefcfe395093dbf18a9bfde4980e6923464fea9ed4f422ff93341c4daa157c710de37dc1e2a4a9d089aa69ee4bc2a64a1dd04328ed313e60a615d612db063aee7751655ade90693fab8c25dbbc36d0f3e050ee633817cbb25d51ee9b78dd66f0dd650383fab0c8d7b1c078a37eb23379de48b052f3570ba185a7d770177abaf665b982607a0b2e622ca43066bbb801e93bbb7720b119ccbb1742094db722975923dd3fd3a434dd1a41853cc8a5f4dccf1bbbc614ca92dbdc6343331ed09fde05e123828e93194a0b7185d229e910956feb51533aa73dd6379a750ce4643d5105591349e700cc1916400c1f9c94e80e9f1457b971287d1f2baf13440dace61b374a382ff741ff8641d2e288cbc8d1969c1b123b75b39890334334d759a39688a84b1e11a4b81eab5976d0d1cb04c1a6ac1290cecdcd7ba4b7b1322ae21c473a5190d2d524a54d6a20f23cdbd31e1e219bfd79b7c9358b501eadef314050488d21f91ad94439c2628ff7d029d77916fb9ff287f0bd5cb0eccd98eba5b902eaa5088cc542bb314b4eeafe52c01a4970d7bc8015966a7e50c016880a6e4c6fce2ce45d1fa236f504d111beb36484d1d270d0a04f644977f76156c8305c26cca5c8631854da8873955fa11c4d92c2fd71c4b215d9c32c8376dbc60379e3d54b5cb9fe1986a330640cb03ed79a399366c94ad039f8ca42444e517c8445c714c7dc2edb23f44a66f613a9a3e0811d39aacf700e4d35e1496f3dadc14ee6acdd2e3113393c341923ccf6e36c34566f96a7fd1414a7852ed75460d426d144dffdb54d7513906e19a08c812b9d90dba73261a23a743d6b5b6096c8e144639afe601506bb33e834525f69a318d096e3bf9148d5206214c302db24d8ade6ae2abf41391bd49adfcfe6b2063b2e0bae976882e55ef85db86a2b5bbf720cfe83c5ad4de638d824250a700a25f5cd580d443b5887fbf7fd12d517663c560fcb1708da4be3f59753ec17d8c766fc29e5599f59c5a68a628a3210b05da1070b35dfefb6869e2c91e75b0df1f75629ea5762206473d526ccd7b5c25b12617171588d6256d20b38fab94ec0a0eb4776c60fb7291379f791e2018b935188efbe71fb5a15cad0efed6f69013889f47b8badc6fe701107554fc367231eeac9fe126684bfbcf8b6b8a025beea786fe8e98846198e0d37c14bded0ab80a845ea15c1e6f143a3482af13d600527e94f5edb545807365f35c05f838cfeff8c3a04ebcaabfbf23767aa910fd40593790b079933122c6d50d424413e4f1502bbe61e5a54e6647a13316baa8ba81ba29246f5fa86254b46cb3d18eafe86d5b7df88ccdfbb4ea2f000f8e44bbabd3fe97e4f7a67090c28344da9eaae753bb3af7e839e3ccc38d6b296376b1c562a375175e858e80c95e68363227bfd253a5631f568fa094e8e07983fa76445121107f7afab4eb65e092d9dc918e404944a073354a0a79d675b7df960c1dbc162360bfacd95a2841f4a036df517bc0a044989fefaf7e6323e0a3e9d1ac27a9a14a415986d14a6aca9fc4c63f7d086f505732fa2d0cdd662f42c0ae0e2375f55b3214001ef265f51a6ee03dabeff9476b3cddd822c186cbf06dcdf79c9e669abd18c6c3dfda27ce5c973bc829ce8d2dc8bab5e7384da192378722cb40626ac2945a8f98b9dab35d9b73c4b0000868fc51e1e2f55d7cbca5060d1c54e349e7cec283117df62f3f3a1a4976d890a61c8e8575a3d369addf00cf361a939c6a24769cf47fa379a1e7bc9826a1a1ec65f31dc7d3a43cacb70354d8cfc19cfce1f9c2b7988e5f6dab61151a7ba0034d162847bdb54b7deba2c089badab1e9d41f14534dfa93c1e331b28a73955a90533e1bbf6f1c23615b4852204973e7afa3ab5156354cf6fe71d72234a2ce5c6984ec19c84db68b145779ac8ec0bf52e4970c7cf319f4b7f18fbb2f6b20395ac365cc17b2bb017c4027afbca2fe7e750e55eb31284f3b64a74cede624d0ffb05a3b9e7530c4907762cfb9bdfdac5dd38121b66e84ebbb0daaa4562ee441e5a5e20ce09fcba734724a8e9ef3b7a91cf77969fcca7c2c6b39a1889e00c717783f0fd0764caf1a624c8ac9f604a7062f27bef90a8ecc88bf9e22a3d04d00b017aaa339674fc7cb41b2fdf9bb030e3269f2ddffe21541e86e69879a338d235088ae86a6216a30d1e2cf492f19c403167c67a73bf129583d218a38ea70e5e4d40ba80c7ec476110d2f72f098f588dece7d691691cd4cfe5d87563b2e916c90956760225195997f8dc9b866e15cc0c879e463d9d5212572acc981cba2a8c8c56711ec08d1634281c5b4528aa343b3c7a24573f878c275637a290b6c3aa5a22d68f21be72ab3da9fe4551405db9819aaab856dc00984c2e127ea221feb97025a7b81ce57ffb5d4e59355145e7e93e3b5dbf047f76652b0dfdd93d467ad50933588f5c7d5d1445c55ff6e975a7d4cca4a572478bd7cfa83b3b7cba3e27ef44e5f2565b34626ad05618d2606913dd8cbffaa9a4a3100760f5830ea7d86068dceb837f66cc1915f10b6f3585efb7dcbd5325e89ebc7f3417152d5b48270e07d0720f058879c77ddf8e09b8ff383204aed6c43e2a4f66ec7641854702eec91be4d60652e1b79012f96c60d96e8c3de95c3e022b3340795a5f0396e2e07d2b4bab92a0cf8850478b638ad85e4c0ce45458c071d9588534b926928d6f6b0a0a9703b263940a108a5c8740353192cd84e7f5bce3bb0ef33abc6418598a00a5a92251a5328ac9bec7713444c8bd6ee1e101c387f1e772cada4a00e1c1ee8c6967dd3276db783a3f10e0261d8a660f26f41f14b221a333fb5300b55f01999c742fcd8e5315f7cde6b56ea486ce9bd41c095a3014af09d1b4e1a2525c21a47e3331e0c62bf00fc5d9c53b9a33d2a5d6309431ce6b8e51eb9d00d7d8450a8f6e7455dad7613199f29bae9bb05824cdda69dacecb7020f1fed9858699b2c44fd6355ffa4533d24001fed20a7f8583ebf3b888b15515d156e99409f30f439ab95d55c2fcb4d3246438b9d363f54af6a710496e251b4beda62101198eb918ea7c5073e88ff7e38c6f3729a28e25ea4870e72265f03fdd4b4539cdfe08e6dfc47b6dab64a0a543955bea2560d58d315f0414f9443027b72373703aecfa9d962b9c1e6bfab3130ed9a585a2a57e00fc27928569cc38884d831f6ab6141413d2002aecd9bc0cf902c85df051d0b2b1584c950ffd1363fedb0aec14fac07f273d04df70bb747bceb1fc24a583fd306fa4c834f040f6d04690441a51365458fa7813a762033c85daa42f39ad5724d6dfaaaabda9ed74bf19780b7097658f1aa29b259a208839335163f0d3ddbd74fa3aa5da2f281dac4665a2a6dd0087e31bc6a0a4730f7804d2c2fc3a21a3ed409eb8d54ef4f931fe4acc541a11dbd2f5c3a4f0b9c6d6779f346f46e2dc8e29c99f0f3eb2ce051e1527850061ff5b84191dced1bf9fd1c1477adfc61d7b204e2eb3f2c160e4c15466d051e44395d4a267b881ec86839e487f31e9ef1d4c701aa30947bb83031f2775fc30c1f575bb07fc25075c93137aeb672a721c5d8c729264df2741085ddec2ba0dcb8b9fe6eaccc45e686a471a13aba18baeccb4b1d423203cfd8add34921a532d2d9a681524f5d654c6726acdf1e06f673b0a18f51c8b7baa257368ad69dfa57934cf309bbda1d67f28811f721029a1468e1f6834e13cf6fee065241fecf723a15c326d010eb7b4937639f3b30e37b5948f42ce95b2a1c9c29e4c6282ce18296ebd4fde79b17449d5cd288a6b7e0e056ab0bbf43973c60d02e6f0dccd687de9b2e1429db3e2d8efd03cd64bb295f59f493423aa267d1943739b517c28968c96105deaece00938790ad6d46f53f3372a176e12d0ac63e4b6082503ae61ca9ca6e344baf0ff3e1da233ad3e716e037237284773ce7a1fb0b03c35dd6a6d982a1bad5ab16197c5bcdaaa69c2b3bc1de8941ef809ce3f5cf70220fa755c0f5a8bae2401f7547b26906bdbd862fcc650bae7506b240a433d3005ada3d7db4bfe64019f3792fbdfcbff3eeba91a987ba54ff5023d8c892afa96e735dd9acd53397519dabcd8d9fc047661d3ab8cbee9d791442484bb9f9634944bacde789bb39b3a3f09f0f719ceeb07f191bb2b38f6df9c5fe711311772637b0ea94c2748c6e1de8eba1db6ea4695fdb4edfa35a6917616e6dddafecb770b2786a75db15d363b100e594a2ebb8ad86e0ce9d9cf43878222cdc07db0b86731f94e9dd7004b8ed13c3255e4507c7c7fda5326a5992ec8f276f37346e7a0163572a04a141c4ca9260bbb51753c804a97eeef6ac334b6bdf015df3d71897d4406b8295c1092c87a21378aa5b654b30dc0b9e8c697c1d4098cdc1ac7d4d8a8bd2ce156aa7e5445ed5bd7682667be35937a8a57d0fb0c1613dbc215ca9302ce5764b1c7b70674c1e8fae4e0a66b6a8cc1090306c8d733bfb6c51668fc8636cbb43c088c727f56c586110194f05d189ee715c5419d0bf66cf123e87bed5c01cde6d0e5d5ee41ac04c5e04b3c5051f2e988b6544235177fccad4c6afa35ab5d92b8e41305e4a30b4ebafd629631c2f0f6ed0733e5cc0303545ef3acc7f4520242564fc4c9b6f54d944da0f88e7ba313cb85801224634a06da72da32fbcf8ed1e53c09bb46ddcc78405700970b2bc9efd5ccf5ce19b9e1a27e10508df78383d051465493507d5a1524ebe72519b4cf40ed16867e94d9ac35bc50342fe5b55936b2e46b6e7ab2709273452daabf549d6ba9dc42404e9407eccb3184919901dc581a9a9fb57643254800da37ff2b903e46281bd77ef9fe36f1164f7a8beb507dce1ffd541ebe9ca442bacb1d21700b0840079713cbfc69931f1e5088f53a06f50874b6a097f958a2e89ded43eed413184bfd1b3a5773dc0148eafaa2afdc9fec55eb33116cb5a56bf3bc8393f841b8060c31c7b539ebf90a97cd5a100dd029c2d87def2aa97c39651b6143de811fb9bbe7e861f6e1d8de7cfcdaa45ca4320aae62616728539487573ee72ba75365c823f9160ae367ead06225dba3557e5e7121d94846d98172695da13a03b0618e8c187dd0e3543bc2720b5733ef1465ccb0a4d367a00adbc08e66a4c7d1b7d8431ca0168d86a248ecdbfbcb0407bf4cd948cbe9b9d783c0d58c129b8eee6fe9fbb7e27a0b10b08b333132dfb74a9804ca2491f8cbf5252e889f0810f5c45a957ac9f563ed8d3abdb18ddadd1d464803c472dea5055a32a4cbd5bf063597871f60dc35c697e7d35a97203bcb2f20c19bb22930897a5b5c24dfaa90af0b26efa9578aa6590cf9856d58d87ffba68c8dda88c5cd8bc16b11af764fc52da24a88fe91858297b4311bf04acd98eeff5d198dbef28dceb49424d2f8e5a35074f4ac6a2246bb348c8a292fb17b43f08ffcae637f8f6c83c23a620b0543526dd7d45c78fe0ec8f7e134a73dca0d385877443e52e71f16d2c80304f895fa51e41ffc7576d8c7aaf723f25cb97c38baba01d13ed005c5c0a4206eba1342b6ee09ef4cd1b337da7c5db788fc2e3e32965f4b5d363821847f54189942f3cbb5c27ca7db06a97abd7bd5649284b89a9cf8859bbd9870bf80fd2184ba115d8c8df7ef7f954908fdd08013268b448a0f6641b6ccd9350db350de802621b5e0c8fe2cfa044322ed8288818c01e276de3cf15dcd8e979a005a4ae2dc47c416842db7d3084b7e48ca0481ca59272011635e36c1500699c00d35feecbd5fe6267a05e9bbddac8780a87cf0f700cfcca5523e72a329be9c712a84f5ef8b9a78a6618d4d2d1a4d4fa56709d46b90bf93b18ae70fea84014aec2549a8c5b3ddc5532e8c540643a3980c104c83f890aec3683afc66a9d7faa40c9e0c57f46167e6813083fca551f247fbc9314e67796173d76cc05c7893340afc4d301b92a8353cefcdfae221ca0724a73e688139aff3afcc52d8fab18e9ea3af166d20ab81180a0b01a4189f221ede416d0d3f224a7d8819fd44356209d5ad70cca2076734ff9ff51cc7cb22302abe83fc6c7fcd06d214c96dca0a931887a079d7043636170946c24205515ca7a7406a542c5bcd52a98ba49fca685777801bee77fae4ae1e4e758764a5e30243b6a7deea3fd262371236a6c86aac46f7d56248075fbd6ca3184b827584814d020d7f56a716b742058b3e90970268671f98d905cf82a9db2b975e2fdff462acd790539e5d137fedb0a992848d6a061bccd70169f7d9ec1dca13c3f1d7bdbc895d256faeaf6b2b26d6ad692b7f9d183f95f8285f2694ed80f5b5bdee04510797ad2263d9fd0d33184aeabcb14eea6d69213b7008a5e318c0ee0fb5df52f7bc4c5a0d1b0c563720cb7399fdbdef60524395a483670ebe53eafc17099b4c00e94c6260a805ccdec90cd3ca1f54fe33db475efa8db2b1ee8a2cb8d8c72cb560deab097adc9a22714b3bab7827cb47fdf5fdd203340c9eee7137d35d8d1f3553b76adca5b489b05f60722439723491c554850ea02e588a3dc6fd98924f56e43ae1ccd23a62cd8315e1d298e86b3cd8c239e9e9b23e862e9b3319795d888e43bab14f5c0db9b4eea3488c0f87b5202aabfefebc3e0e6455f363318699e241725dfba0da6c47dd4ae4b7b76ebb20012ef58f4334fa992771feef41c66995eb12ef1fcb16fac23b51d0cb5b2dccf91b3ab158401153ad05f65a20d4477085aa2dc1b07b655d81f20cabc339e0fdf4324e26daef8ac14b384d84d636df5e8390db64a1e2502dcaeab6b3c689cd52cdef2bd4ae264088a780cbd50a9adddfa3432030bb9af3d9e723b4c61f5ca3e6a5e63ab3730e64bdc2d5ec113fe4122f161fa6497f2a7d65c23796be94bb9e07cc19a3d325c783fa49061ee07c7319e1beb537d58a60f5a3bb49f014ab3ef6043b17c0cb35fee031cb5b9dd7b43e3871494292c3471a532733168ad36602a8029f098ade65caa286758c300a7d0e51b016e9e91e859e896522cac8d2139e3d37d5652302c6cd7369bb495cfc8f81281fb54f908ec00fd0d569c440c0e84b7be4aaf699bcea6b6c9d4168839be7632b7cfb81bbff35add7fe9717b0d1d1e2e6ddde8b3bcdb33a902218db4ec187a64e6445741a937dcfe2f27b06d51f4bc6a0fa07aacd3a158902d3ac80ecbbc6e92d0ef920184b9cd7bbaf12e4f03753676c4c41c6f1a00c59cf3c59a1db8125c80c7ec16415d40db8b98bfcb676d6379336a8de688b8210ddbc732f7f9ec412390c32725940e3e0d1337828c8116621adf333a75a96503b80d980c7c970d2cb46399798773a769441f167f4f5f984100c6374fb23f4985d4b77cc8892fcb4614875f8ab514f9e71d60eed82ab29ce843f2eb08fa7dd97f8e69050b6b96e815e0f7efe5c613184e9413574c25d395f14372c06e231fafc8dc05c6dddc2be021dfb0329b21e5448046bef40d105ba3a22ce04dec4e8491e103d9c32d72f474c29cf986d5e6434e93c55a93223b3ae6879b5455d22abe032b540e86d870c882b9ffa438e3ad04d7b2e24e4de6c51fad113653476a13cad1c7228cb216b2e22ba82fff141897812bb1dce20625828fd08c0f1f9950be5c28c5e6721fa1d41fb0afe99335bd4de4882f79c3420c5c6378f7523806ecbde60665ca6a9df9ad7e4e7d6e14bda655e57000b3358fe0d536ce1568838353e53a74f7511fb0e9ffe7066120b2471676e07cff28ce03af4e94697c5858d42bbb7257b543112dfbfd6544c7b89e55d5461d4befec515037840f198c0482e9e581113b24855995ed6234c4be6cdf147e84dbd9ed9e1df2374ecc7d6ef8f698e8b2c468842a5e2d53a3a00eb56170de6ce02305e873fb2d3220c5b5701c5b25e1d652f8e1526240e402eaed0cd4fe83fc62a520fbc890e548492560d8a560df888f425616971004ca6b7a0cc08207d81bd624f996493aecbc3abd1500b40f1933f1b3703384320c7d92da363195f65ede8f549a7dbc8d16ddd657177eea57d6a4aa920dd312e46ae25516f7e96a10ef8485de804898375072697f4f65b3302551d717aea68c3cb73188ad9830f2ce64032313577a578c02700ca96f116a29a168064bfe087a0f8d929349778e4b00f0a4fd4cf37a987b01e9ce538fa62b773bb49fb8581d1180207412f384767773a4d598e35fad3273be97fe89c68b6da50eb0c22158b56993de0f3145c83a3a9569044414e53b0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"643649ba80ed23fdeeac84c02c742703"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
