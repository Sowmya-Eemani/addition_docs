<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5f2b702180662d2c4da765af80d2243fed25415d408613d7efb3d597a645c6cd9b15d1c3c0c95bba9748d65b09f3b6979cb048a521a4d1c4891d9fae78dc8eae2ef42c251ba8c8704b9a429e18f28c4fbe656c436acfd64b33a09bbeaa87aa26505403f6a6ee7c26ad49726831e119346e4bf2e26fc4fc11203dc9db753ffe0ec4edd69b12cb7f214c47f622227903af3ac7df487ff007e96f158fc1ed9c419de035b8824a1f801cb32ed4790fd5a6732196026b637db3a86a1100456cae763a008a6c69f8b121a56de42659310b3db1c371cfe6244ba9d68c5ecad4242a6e71cdee5de6e87b0b95807c8b84a71f93b8d3c88dd575675cdd3d868fa687f0369e3c5fe8705b7b097dd093f6e86b93d4bfaf653daca1dcce020db69829cf2fafe64947350fef7e8d5f80a8f803da4f98603caba33c9461b802499f6c4ede3705ae2218a293f9daa50fa1e05fdb4ab89650fd9ea35812da136c7dd8f668fa1f344a14b2ff6b2e9c8d55eb1ae07ff9d60bea90719a042eeb768f825899c00fbe3b7dd60ba15ae51a9da469a810c2dfa287e9339d2c192bf30fcbf5d83ed4e9a456b8083e3fb84c09e2126f605fef1cfb2eca9c474a05a51757853aefe6b63a7d2f39bdfb790956a66ae852bfc00c05ac9323a1784a0bca85b230c9b9586c09bf7a88e95ffe1be0f60bb669e6644580b9279f4cf24bea7e4614170bd4d9e17942ac4e211dc714e2781f778a3ed36358e456d305205a3859e182d292da0f183b910a34d93eb21267dd29962957b2223f4972cbb2f4e8217ba193b0ffe2e6aab50da37c6dd9ab6e5607a54abae22f4b9d567c81ce30792a442429572cc8cea444d46791e84b8dd97a301b5a01a04439d35a40609fd106582dfbe467ce6dcfb1b73ac01b256cce6d5691e3bfd7a15a94d3241b0921b7aced5b5dff7cbeb4b79899fa6121bf45ec56c0654d8aa3346e68eb658fd677cff3b314aa6a037c6c586a7695bfb7005a433683de84e1489bb19498ea5a579788ca946501ae19712c098f5f8b775396be156a33cef13c8fce11ae7ddf626721a21d549341851b3c31f531d5010c087cf8a933fe4ee955b214e3cba9fd028b60606053ec66a5b4ca302ce26a410cca488553462792abd25052fce2019769a5ab99a311681e6b45026522907a7d322283c2fd4f40122c298eb3ba2a5973b3e752f44804fb4627865df9d26c498c2ee36b5be572ac0b39e9b875f314c6649fe27001a7c7358b67c29e43ce5370559c8ed7681f15f7d6b0a584378015f1036478cad1dc93a3b70161e4c419977f2b1d98954d2e1c26b010465e8e6b0add07309efd956793c23687b9151ffb8656a4d65a11efd66de59f24682f5ca1a2855042254ad3b99108d5669982dd7a0bc718dfdb8be045a27df7bcff1032ab3374e19778cd0edff05e5b9500e077e65aaa1624190a3a0c559e86cc2165c79253e29166ee66496d21521263ead85344ba3e336234c4b758bb8f4c66758221e83431814652dd54a191ce9ab01964ed6d7a08bc4c4ff341bac00f75391457c436f0be485ee14262ecc3c800240bfe58512599c8bf3b3644b5e7f5a6078afb16dc05ab1fde5c185fd725687fc4cfe1ccc077c089c6836f5bb2845d0e6c41fb359d297b7b8534d8427dd8015134bcb6985692e0a9d2b0eda9a2811b8be24f9ac6a4cb7ce2d4ae8846746cafa65b6ac9655e1d91f0542afddce82a558bbd0e27879cf8612eb6eee108b3cda98d78d1e043db62d3bb7be88d651bd3dc14c0ca77725bae731924d46ea05ae9f583f183f00a9bad698e713b69f708d7617ea5ace6cca3d19fee769fd3d655bb7cf5452e0a440c92e0eb6a113992c52fb1b623703c1a8d823da4b32ce2ca93d7d2c4e6e298694adb8e22b9c00315e3e5c34fef54783f919a4483516297357e69553113f0491ac58e3d45c53ae1a91cc923535e268b6a4296df9d2b9b6b4944455255d1285b496899de559def92dbd0555e5d332010e8e28459e8ae11ac1090fd51b60f2894a01de18656a1583d190d05d214323abdacfdff80df545e1e2532475dda8d8cf7c9aa30eb72d61cf6892cdb4894cedd2d29713a93e70489b6416f10987ad226c2cbd77067fa174503f15a02f3cf463416a7b316743bf98b131fab0c4fedc5ecdeaa0b2ab22380f716a329cb82ed586df49c9e76dd88c93a83af2874b48c312ff3d9d04a38bbeff114f052d413aec5a08f6e6f4412619800471f3e4e067eb5dd318d47c8ccebbafbddac99f35c6c3ccc2715db07c04255a8d16cad42fa0e2080040e19aa26ada1b070a3d817dfdc195bc175d98acd33c3f730711d5d63ac08def57b004a6e0073e7c850f932ff4bc92bf53c778774dfccc047c92d19fec9a348873c95c51e45f8144a7b787c1f0a08945ae336bdfe62b8aba6377e5db145ff1899262e5a9e7d1cd21958dbd9157873ba7743537e1fd3dfc63161300c3d7eaf655359dfaaa0dfe974e0b888a874753f23da1c5fa6c16207fe7d1512959a8a3731b548707d82161bfbeee5b09bcaac90d06a716d738a97f982f6d5040134a98a8db6f53591d036956a209762e922237c00c179585e95b5efa4f12addb5f5debe3646ae1bb0fe3ff4eb844d5d80bba7f98297b4f87b2a05ad9afb43169e442fad8e2c409842d1d06634dc96377333c82adeb5c19fc7608336b008b0496d73eef57ca15cc63046ffc991014917acd396e48ae2ac61aa6161a7417cf51c651c3217fb797802e944f37f922f2daeee719c856e2556737b0c11a22a13b99ced681c5b59d0cdf06e289dda0bc8f4a37c0c7d173a6113b0332854a5fcceb561b5ca5c69a8c991cb438fc96f883142d170cd92d7afe9bbd75920d7da2ea5d0da345bfaaad83bb4f2f57f4d44da0b9de242e6d20bd595722f457b455ecf55128e94ecf85253a2be260b8ad64c77bb964c61129c99bd2801a1557357c8eb565e836707772602afabda719f65c3f8e291c11a2288a0971906f0e91920a417686102234121b5176dfd1adb25fff03845bded1ddffad33d777c26f2197b45cd8430066892fd2346798e3c2c575f3025a3ff114a18df24bb3474f6947a12812dd1dfda577fe2ce7bdc6a362a0febd17f1423c84a7f74fe50ed852f2fd7995106b626df587696bba6e92cf6d950a00f48ed5d1a4c7f9ee2a7b21bfbe792ea6257e132244be0382f31903bb00a8d9eda0d427a063ee171c001c7c72ac3814ec8794dcbcfec77d540c8c67277717d12f19f2dfd8d407a2ecd139582e783951160af909e240e9d60a8e75ce587861cf04d85e458dfee3684cd839960d815264965067266b3405a1219d081c495a5ab80e8c40352d4918af9e4219c5ff44b289fad33fa0f2a8f592d0ae439edd02544b6551dd28ee7ae2f69c1de5584aa742f117e3004a21e43eb15fcaacf062cab3436fdec8434d865f0f652c400d904abe1be05b574b6969eddecb6a004b006fcb7b99f0a5795a244220fce240f4beb13edd85514dbdbe1c63111ec02b5fe6da5ef20e8d67da126da32892b02b66803430a6f5224a96974beb9f481db2bbc9b8c58c7b77bd4b78e76e03eab148723046f2e19f1d6fe4e4ff790d8d2bbf8532a682c343af693b90e450f0a4cbe2575dc08f93110a0bf476e78128c7548801165b91a0aceb2978f732884d0e32b2d52512893dd736fe2d88f5677f235d6ea9c8b41b15b770f0e16e15d062aaa79839f9d32d399b1dbfdc971fdc9413aa184135aa50d4a090924e5df812e903fa2baa27155ae722f2bdb95af1102bc1ad76c3861ad6447e78d8904998dedce4f452fdf8c5adddcdce1aeb55bb6751f3d08b9e749f7315295d0462f16891ec1475f3db5730bb5b3c25f5279fd387196c84b04661edfeb33afa13bd046188069ad7c9c096ea424f2a69ca35d6c4c8bbe9c6f6ff776ad845465194c8e595b6824f25360ee699ee076037a999a8659ceca3c0014059ad5af997fd550f5f3d04bb4cb659c549e2647c448580b0930d51d4e0893f6c4dc1fe066df54233625515f16be4743f4afc2599e56113336bfa95691edea5424d1ea093150e586224007231825908ac7a85d075efb7a8e43b693c21ab8441c096d3d4b159a6defa1628ceb45050981dc101bc127dd3a9878f128d5b01cc3265d4e9d26ea57b1aeda900839c848d6e19c1641dc12f6ad2d0e2181f1ae9f239bacb694c8d1748e295d3e1d10c5373c93532bbb18c254f25fc488d4cd8a0aef83d695025cd821534fe625eb31398bcd536dd120fa09252f97f9dea6b543df790b674aee3e1339e6a8dbe15779a53aa60e11e0aa11f09a5e8d64ce809351ede793aefb7dc06b52c3cd907a53323102f005809686cc9b5d4d64a8e6aa9b0048b4e98d9c0b1c50e58435fdd8bc159ef71bcc204b3990aa70b446580185a17b7abb581498b2877863a2bb11e84ff9079bd629d75f75092ffba854d50a2266fffda1f48121b9d8d35e255c97f585a63d72db86d2764e1759d21a8bfb756584f519af0b43241ada8d7c9c7ad9a09e2509eeaa70f2eb5cce106c190035be5226e6d5e600c38d746b1c55ec232ae8175d7ffce32f25148bb8f2dcd2394f4be470839c3a9760c1b2c919a4d6d1446d0e44d74cb93d53222727d76b2e2070be8909bb88d1f9b10859da5bd47351575d37f409a657a6e2925068ea6aa434a0fb9f7174cbcaca7417c90bab92d285e81cf20be34d0d7ac1f07f89f91d8f6f7a3c0a78ec5333e58ab9f40b8eb1b7f134c3f4ca8dd0a9c9aa540b5e4bdf50e6320f7c38b36a3af13cc165724dd6ef0f76ede75238dfc0a1254c2df1812f1da00a93066ac54861f06b4d46480694f8fa11006566b945aebe082f7334d78761e8b1995cc12d06889920640d41614285b80dd77895fbb7a19522adf5c3811d3db049b01f97193b568cccbf76373ad651d735301c9720e9f938b218aace2272465e267592dd55ea260d2793eab412987b5ae6f4ad8753a7c76113260defa19f9b8f7d2424bbd398b814fd9d48bcd4a3250a25451fb9653eb6a89ae476650570dd56f9bada39c4def1c816eefd1b051f6159f01cb89103a4fee2b72de445745c02e5216d0f9bab61cb2d1ca9e84c599e0b74b9821e74524099e190610b50a803ab49fb9aee4c82d7143aa38efba834b84863f881855e1efbf36d8519a5ceaaa20f4bb1ae2ef9fd8ace32eb1821e3631d2f75ee6b4018b55456321e7c62429a92dfd871ba504f66d553f22199b812846d899859a1116c5f8a0a726d10596d8b06e3b05eb26a41a8aaf5d39497f4f6bffa06c927fb86abbfef04ed290bf98d283501268840fcd942a3b26ab8d85e14e834d8d1494461e661f6608888aec8986ce467cead6a7b6a551d20e2e78fb8cc9dff4b5ca47823e589fd5935dfa3e82f511e8aeec9e15edf7a93f4c57aa2ab20b285a0413e3725c69c6864913e647e161af83fc5612521de2107da0a4eafbb3acac22b1be7081480000b723ad2a772ac2cfacec9cd60f8b519d0bff7c0d2521ed43397bfe54734c71b767eb518f2da63fcce6f2b6243b782fb887c38254f5eb9e350765c5428808f84790cc7110df0d4a534c9356b2e89f3bf94fab30087f00f70aec5dbd972cda9cf81a6ffb924f2e3937a98270aa515c0a702ce49f828fa337edd30b4904bc6be68067ecea54f16370a69ed8aef762734d26dab3716b9085a9409315de118629961733459d7d0980134319b1e68cf4d1deccd70944c502be074d07ce6e76d200e861b6ee8ea98d4a1c7ba919ea0a729be350c17967bdde25b9ec4461c75b01a86db82e14178921044bf5797d895df29a2ca5e67199cd9f9d6a578566b5f54c89c4814699f396f906082c7c49141135f9980e3104113eca57ce169e3ea6de76f22180d7ba7022b27324e74f92a8746a6c6c2cad20cc27aaa52a9b73d9b12ab6d52254d157b882ebc8fd0713253007ce28e36dccd562e78bc95b70678161c7906e527c2a1bd4162b558712abf042c6cb1578c03164b76d570f99805e473d35e632c5121f8f4b94ae6fd711492d62d15f8749e107ff86ca4138dce96c7e16562c7d05478555883b0efda4da692b6288e49f58345be5462a992cbf341c2ce275ef7a232ced5065b6f635030b00896331c859d290bb93108db36b5d8869a430bb87499fb71a5205ee5453af877624a417f12534a932ad658b44d0ed19653d97699442dcd679af6b872eb472a318d40446d5d118d4476b9897106436a51aa175fdf24b13049523ab2069276822840f745ffb62d5ef75c938735cc605fbe54e0f2b4d99e9cdffd44f833f30f7616167cdaf8cc161fec35065dfeef76bd9acbf9eeb0308b2d5434822bd7ff83b26852f2e29e928cc239cabbaf28f18722807a13a530463f50d6e5d05344c1117690df45b77872565a93e6b48053190260f46474f362a0355736cf31ad07d90aab6ffac9dad22b822f676395347d772cad255665cb8980d11aace70b3acb489d05b70bfc7e1d9fe56b73a2f005e448b58ec6c50a022b8253c93bcd3c096cd76349165d7ba2928a9adfc5bb84b0fb13262dc3b960003bfc59099f29d0a2bc702759ce4345702b423b3eafa577d102ff93fe246699c499008a523e795be02a069b21573da5fcf13ed0eaced5eb577de7d944970cd6012af31bfb4fe8c934020528b2d4f69e26b529ee42021aae3657a748bf5e0709b770d5ebc8598c90f7318d519465e2bfd8b2bc1a41084406dc0cad2eaeb484e55181ec4cd20b061a5670d233bf78ff0becedee3792268fa2fd5d98a006ce9d3da43d393c2829b3be04a912c77ffb49513ca06ebf5266cf9d60adc347de32c43b74fe0b93034238d7f633b40d07b7015a0ac4706bcf392f084ad59abe26eb4787f386d9aa42028ce15a2cc54c7a28ce607723b4639bad1683ed3c806e657a28fe3bf24d0976d8f16fc2a57c1009e16df738c4ece5db753928a087e86a56b9b03417a4a6290f534a29d0f591ded83edb020bf88c889eb0245bda4b9e1a170a7b007d8887a109f8b07cce7f602c6027824b96f846cb430b2a5ced4c5c05bc326225bf16ff1e3a8b9a4f864309306cce0452b1377964d11b2e504662eb97c3cc426d3955a15c645b5e0b32b92ca2d771b522fe29dda4180d9480184a051e8fb7528882fb9e604ddad173d95c458b19ac93cd1ce19bac256aecae5b3bbd092ed6cee7898ab6b649f3c4cb1a0ceaf1b05ed62396ac8323a9448c6d61f651165073c7788b8cdb33b1665cb6fd2851737b4f76871fc1117c5c121cdb71c71ae3bb39381851bf1000f4a571fd792badccd4e1c254a1491b8d1767818c1aa8a762faaa030164e86411c1294adc16a4c6adbec6eafb6c46a0d9942cbc9580901ab9012d372dfe91363d42de9610885ab513354f1461669f111f1124cc50f63736a3e0e55fe8378589aca50cd2e85f32098b7a86dd8a38fd363f91a142fb523f56f285b4757b766e3a0b4a1d9818eeba2acd02ecca2d8422ae0e1b2f4ca9e7495f957e677dd6e8dbe7a114b9b7cccd25b67614fb322a31e1372b9a8648e15c302a7edd3bfd2ff388a54292dba659e7eae2bba7ca6f60768fee4ae07bb050857f99a1f3f0d4622c34754360d158645e056aec9e6d359a94a60bf4d3de33dae951380f25cef8bf3b81b203132db674e01d3875ba3ffcaf0e0ea6830bb78ccb6bf30fb403e2351761d3462203ec0a8f6f546105e6c7e753c2f884a4becd3b8e7602d549af05b3ab97947eb63037e4f3ede68031c92cd18e8f8a9bbae13d683afdb284b3ff6ad627e9e36fa604adca8436dfd5981db1916cd1e457a1312993c05956f06b9c03d09cedecefe9c32c9d9510d97aa574ba8b3ed32dcf3e89fa682ff985fafa743aceb56d2a90fedc3a78c49f8abbbb8a0055de5f69eaf20d877c46368238dd83d278cd3d53243747b5dd5f0d2b81058a664dada5d3a35fb364d91d7c30abde9b7215a6e0f20b36e19be658a2b0bd3d75dc69a1dc288e6df31ee4b1e5ec72cca6fca53e25dec2cfd444992920b20870054fcac672dd6c5c6848c16addd271cfa6d10bd5581c425899c0849a92d96ec9e6ee16d55eecc86fb9ef031090e79e8287790edff39e1098072ea56cada6e8a5979ec61afa091220b92ff7bf69a27a00b941a0652f8ff8d341d6b9fabe37e78ac3c0602b5bf80eca9f658d88cc16240bf69b750483cb1220c4bb134191eab6e7b9274b21cb1c284973ce58ddcbc78c22898e102f420c53ae0b2a9bcc253cdcb43bc7e4b66c3ace01ce0b249b9c23e1e30646202aec8c6a16a67d1c5ec1d048b18f3457959ca76a8621e74ffd78add05fd0db94999c746e4d8d273d5fc0b116d970c0e23e45e3cad39fe527ca3a12be04265bc9f8b33759a58535ecd752221d02358c30b3f1b34f78a291e662df5909994081a254bc4df37df1efddb0693f253bef81f26b7b88fb96d48834556a3c3e4f19fcfd450bef5043701e1851571d1797476fb80f1d2af33a7373421c07dbeabf151a5b4358ebf69eedf74461c37b1b76cd596174cd4e75a5746b1e204688e76573a9c1cb87d0e019287facad9b008912dc3f2e18968d85fa2b0dd37615bfd96cdab718f88e24cd87ca4474db35e0914ca1dc96d70320260946585be423057a9a6b0e9558a12b9ce4dd2f62ca79bf62edcf740d31f9cf2b65676663626f4293a97f24ee8f9d1c4a1f12a6c95d91627e26db3225dbe710adf66e12b150bec1be9f45db8353fff44136b749c6a3fb62911ab84a4d1bcd0088b4dbbfb3e8ec2ac235290ca7175f2f0e3f7b7b59333886ecbd053560e0ff4d707dbf8f6584b8c392d3e10322c90e163bae575f0578c31e634c6d0434905b746dfe137e105707688ea086705741dc80999f6c9a6961d3485774e25b3de11ecf77345303f76f7c7127d38eb9ca5f7411aa1014f0b7034d4366020b179fb50ce50dcb4a6b062db464cf3ea76a7ad9ce2248564f072c9f6f987912a884c529ef85d85e9e34ab939a514cf869772e09c0ac813a241c18c6a298b70561b6b6e1bd23113387465585f241fd15ba1af48ce461173816c593705bba38e3e8b719e536028ee7ea8db0f7e8cee218cbea63a49d0f9d67df1bd0080aaa3daf10bef23226cb9cac8335d44993f082c9d0780a4b958b9132f5e55c9862251f2c35a37a5f946d13dca76bc707a5d9df2d1d4da0e6f22e9e898d4887e6510ca491bfb2d456b12ce6e08c203f716d42121c27e2713eebc6275ada73e9294a8fae5025c845770a3d3614203d0c7e9a275fc55808ecb552c529705d594d619090e8532a53398a9e777b9bf89a73db40ed4b9cd640f143f4b6d32e23ea151943f0db7ef4325257d6cf85ded54de2a369c1eac49661f5272cb6283cff5e5c2aa42ec099b51e7f60717e8d2ee7c8810bdbc094ff104d44957039e5b3cb8751c6632cd5a101af7ea8a7736ee0f318b92cb9101caadf31c2053364fecb9a71e1c25c65775eb626999ae9e537f959317d5ab68fa4267b5ea2c1839bc051f9c3031422be06eb2b8ccd12bc1c535a2412004c5977af70ff7f1636a99df5800be8894dac14f1745de2d567031fb0835d9056c932d1f5d72f7223a7fc40d0264cadcd04b04cb94aa1ffc96afaa68103b442f0a3cd37b26eb34238b8eb02a265e7725ff94aaaf2fd87d5efb5d22312daa799bab59e83a54ce0189f4eb664b35f8e5777479cc1e6e88185c3465fe6e0252eee38ed77d717d8cb0b1acdf5804c0def5212aa857e3d50de404b06298be80f616958775fd30d7d2729026be6c9cb4d428621b9d9b88fb0ab1a774eb2d1bd133bc8018cd4a682c97f39335e180f44a5c7b92a367ab05d863a90a945c307c4f5aef5ebf2e15cebd748f4ffddb20f0389686eac6d957042628947511e577f5156769accece6c2405002b841073081fd65774157e5d7ddd7fb99068af6141c98444ecdd379a00737978a1ceb5502e45be02d192369755ff05c7c4909f68eceefb9d0893f3513d68be7a1012dec91fb30da2ef3092cae3c3ec41380862b9d5e321e7879a16b7cba9684fd3e94da38e5f4c94123f44d2e68b89cd1991e12f4bec36f9dadfaa3f58be9bcfd66e4b80657bf6739cafa9e1faf977190b10ae5f6ca0e9912b8a96103714ac23166bc1ae7b364f5faf5cddb6eccf6fed9ed01f8ffa1a117eceb7f3d3419b3e2813fdba20f18ac9c0a824da41d7dc8ed8a84711e4d7133ec9ac84f05304bda143eedbfe8b306690caa81df01b662c9e523f84549e2b571e8ca5d640b7349d7ebe67bd4976ec9b1ee07827a30c350d8ff778ece4df71345c696d07cb883fb9c5dade97f09dfc8a1edeb4a6f49528c7980c3a10736800f44df08a52668a80e8c278d11407960fc6911cc3c66e6564c299f21cb5a7432acdee4da7a08374479381f05093f7b817cba49261aee6bc362152154742977ffc04a4ac52426c9d9a8449bf230a44e8b9ec9678aecb1ac760f255dc5a781749f2185b0df6b9dd59268b601eea17eedfe3b8ffb2f953875e0087f65e6d9fecf038003dce6b2256f56ed538571585910fc7803ab4a118d0e92e246169bb48b05b427b17c2d5f0c8a9446dabeb0e9ba29c5d6f8d18ad77c41a0bcd0026737fb8e901fea6f080a4c604910ada1355b040e42d46a42bc4775f9316279e27525b2dd1222c0ca842a429ff1cac4eed2164f2e00a9cbd0db0c170492ce76112fc5dbef1a6af9125b95aeb88e695f8bb278edc4b807e46498c3739de0eb00eaf1d35cefc12138c2ff367da04d6401685f9123bb20b87b7ad6c04c351f32a3985181d4ec9598f7cd6a25ea202a6608a78fc903f6833a2fb7865afd6e3a7f2a8b19928e4a9765a18c80183f79b333367c1ae7de5eaa09a5ece5d51c65e268788869fa30a328ab0d60cdcfd9cac4628449b712c59b181d1e3cb137a87d9684d94f56dfb095b090edf4c65fd1b154f5d636837ca46203a38ed7e8efd890f2c6e28859dfefb314b42f7ca840528199fb8204efcc531e09189269a166820af2632beb190b962ded008766addfabee4c50d2b92ec81a80cf93540d05ecbf5e4257cee783020f31a3599aacafdeb42bb2553a5fdac98057623774713ee2d41550a0dccd368538b548c99facde2bee5b8e90a5406bd28a65e069241bf32eb37611ddbbd70984d46551e06b8a9b40fbc42d30ad51a8ed335ba6612ef64ce813e68197c29960401a5cb7cd372df56b388a122ede0569290bd372498f24fab4838aac5791d439187621d8fdda5561a8d2caf001c10529eb4f74daaa29b07a64feaac3a45bc7f133a5fd736a382f43b5854768a68a8d257753ecee3490a2335d0ff36e3f9baa429d44b5ea88f71f75d8e81971845698bc874cf0d6cd15351940db98961ea203d16321797f3d594440ed44f34eff30f478fafd6e50c73b320821771e3c745b54a944bb2554488c7e0977cdb6f95ede646d3ad1cbf87011401e630cca38b6969ae5c43ed83525cf59713ca3a5fa7c1b2e8b4adbb4bec857596d98900dbcd42bc129969a7925c40f9915cce11cd74fcb0e0df7449a787953857d3d7d43a031c18a522e076eee1bd51a0cbaba28f30ad71aa6df216b2f5a498f2a2a8cd43e2a912b1eabe20788670481d20c3f337a29362fc4d3a09c01f224f3c96a840246aa6878bb02dc3c92dfbc067668b7aeb36ac2f3c82fe002f422c75395fa1e3dd2a10d1882519b7c7e55529e35ae90ec67be650257156830a953c12579ef5dee7d1cc6c8c5fedb329a1bd00fbd83badf3d36fe0d0294ae7c9706be6b255d4a5d067a41289610aaf74c10d97288242e6ad3f0c5bd6f7febe72487a5df4e532e172d1bf92a2d3f9dc96c46477c6b6ec2445719cb2c0e620cb7bb0ff984b3e3a389ea90db7cc6984cc884adb9ad9568b2ef014b168091133363db66241740931026c1aa5c6c8ac1fc84292020db2dfe9ea4b24b9f8ed8ce47ec31613d2e234d4092684facda25f253696227ae2a3f3c4a588484d04101183db8a72e5ed0ecaba5a6427740f15365fee06102da16402afe7f86d4acef53c8a3653e2da7eed703ff30eecd757f83dc950bbdc8a089e3507e7f5174852b131f92a00a53d7a739804ceba284ff21d2ade8ecf8f611ee425d50cd4710364584f3fff12449818fd48b0a7e232cc24de77acb2a8a5385c26a1de93987da98113672198a26471c4c9ef16d315ff67a60141745456b8fd6ec615330c9fa7f850303c5762f685198499585d158ced59f96dbacbbc07a25e3ccd7a3b8ab1157336acc73fa687c03cbfd269cf4a402c7d40587588ee7e7458f82b8e778e89b9f269c9522c7caa978921fdc00dd8e259a73b162e448e494888b700b7ee74c744aab741cf7ec451fd62cf157d28110625d2f4b43d853b629bbb5f324939414d333bee0ce9a8fbdeaecccb3d037d16b114c1708b033cfb234fcb9ba8f74c855c5b936b97606db1b2691a79abbe02950167d62287683d53c2ab2200a67bbb08fa50691c22c68975646b0ae3371bd54864c25305228237f3f3f47160f9fc7ce08ae25b152e72aa2acb88547898359484e67944b979bc4a3bdec386e84b73cb6328b73647b1dbd891820cdd47b85967b4eeba875c25976b48f324d04dba528da6aaa16af666a3224996237a4c367261a3471a8259427e8c4320473a26376758ae9b77270036d2980ea7894751cf165c06fb9078176751f89a41ecc44eb5273024ea7b40d2a9bbf3f37b0afdd7919164eb01a55e859a1d9c4635e53d3abde579dab43cb49636742a8cd441751cd70d8beafd259ccc78088b71a9a345c6dae5e3eafb5d4422f2fa5ffa5ad1013de017aa678fa1534f807376c622d679beb860bcda852addbab08b044d2deb63102a4d03176bfb4f6be777a2fee04e098ebb119cf082ccd724c599f5042e5d4ced82d6f87823c19033330bd71d8d160f791bd16d7539e556f0f15f2d350d88ba87402b2235e1a73490d690901bab6b994202507959a7b72b9d183f5417bfdf52e4616d5fd2b658305ae475bbd890dac9b78ae4e371882a02f5cf9e67f0c3a1d9faf79f7c4d26150d538df394a39e0dc4b6be750885c4df13ed00d250909d87bfffa39c99848c5e3e2860e2f88dcf451b956d0ac30a8faca459e4006c3acbe8d5da59606063ce41460505369b0f549548f36004040e5e3e0a2e18fe20da690eeb64624dbab14f8bd4159d2212b59e229bc7542884139c91a026dfae82eece5e2e553312b860dc3c3f15d115402fc3823e83bfb8faee263b297b8d7bfc88b51502016c3c58568706c9d7a5be219eecb5068b9f7513c84f7c0dd2faebb68ed738112b313a1cc9e6ffd4a0a770910664d94e84f4ff8879c5a4f81b6ca67a30f2242bc71a063e7848e04c37af5a4f0a4e5ddedc0c2d73df061de2ca47bff33802b1ee6830b4519816a9e08d12b16f79fc42d4e76cdd17ed9d03aa429051c865d23b96d44ed9d0e16350e64ab732415f1f1080836b788cb43f027c7d2d7e4dde16450fcc8f752a203feaaa0cbca00df7334bd79e5bb6700403afd1011261494c469f131278169b92c08b9a16f3a294779e46d819c12cf096dd47c9bfb3857f1034d2b6e519ed169104480ef6e6b355b29919329013839659c273371f5bfca6dfbfd9ac70c0e224e2b836a8594e23775289a56def84e0c3963961d1e2548608a3c6f3dd4aa07fc52216282ab71f7a9b660af7ccdb8007d1f179d3e05c50ef7a8b68898a559254a576fa009b120aaef630c9876b5d33197fd63e533d5ae2ff78b6b259c12268eb3d0f57a8bd4ff6c9c0ca40364086f2b11c972675a353a6a008aeb7c492ed3c4d2922dc7d51d75be37a28a1665d508c3f6bf8c5afe85fabfb6f52daa5ffbc04966cbd5549f600169a2af94c37ec2ac75380feb08b6cfd23bc0287881e9e329f9967c851fe31169d073fafcc53738dc085fc6986c7b8943042ac5da03a7cf6a20094e84c62d65a7e96b9ad1e3b8f2a1928d359cdeec8ac87a005712dcebe31858765e0d538ce38ee2c4d5625b82493d5b1654a150e50b70dbc0c093d5791a0afba8f2a17a3efb5af1375847fdd781885db9efdbafcaa871667425960a84401d559b64ebae16ede83dcca68fde892346117fea62d885c19d5d3af7ba1686c333a0d0c9ad670bc574b4f9b27d1fd3a6fcd4ef1a36327a8f3bd883d770172768c8c6edaae4515fcfda256223b5d2b92a9dc791a89dc8fb902a5178def184fd83cd11e0acc3e9cc8dadb454638b1eb3e2287632e94661e572bfe5792081b839b5006d18a62dcfc6da45d7f4702e65cee419926e9d7168f06627e09553042864032f945b2ac5cdc19ebd1e838132c779148fc5c378fd92202b0ffe7cd888903f08457ed325325562aa19b3684b0a33165ce5490daa7f654db382ac79f2b5b948d95a313018c39e96fdc9466ce1855c2c15b733002b96d184c8ef9c4ed5bf359ccaec10f31f35cd33cf41356f5a0e4a916ebdcb5f9a7ea500b5c5635bc4dc7bbc3ad8715e6f2a1395b483b71c06eb24546c8adad8d10cc8a5be8299bcab46a1d0a0eeaf2682c9f4060b16da72e4c19eec30d3668bdd118df67ba6dc46723d62b5b049af7fc38cc93910eefe3d07327d908b2db8261f3bca6cabe6b89ffe916a46a7e8113614f1cb1bee38586e3875e0a5d1bdd76e67734600653ffbafb8207ec828acf5b63dd9b22195bdd78600c07d3c29ffa7d9d633d4599b946b659ad977d993d690a45e0a730ec52a52443159e087c89c8929575d69f2e8525fff78ca705077d4498d50ad84d4abe6bc0c63b131c9c8aad39e857da37a5345a09a5efc94af1b1e6f03ad71e4b2b80a2a6a80a09e1adc88fd0217e3ad5bfea6dd12ae709e940698b40c89a05d61e5f5919d79f7802f303516414f43545f43b7ae37e5c7a880ace90a8b0aec210fd1ebf7d554e4199792aa691fdf38f5be768dbdf9eb22faa2ee1f9a5bf3698f7410ec73799283e73e7f09c82bf4dc4c52047120693455838cbb166a7748825fca851d4c7485b55035dddaf7db1f4123f3f882aece2506af9a138c0ac5326680356c0ab9615ae911d849885d587ec4b43e72ed32e39d8fdc3928a2e74527f544ecce4d8eb92fe362368fd45d21a6ac9ea22e04580afbe0456c2da53a4c0193c1fab30f7f5dae938ed76d9b1eeab1f67023cfc197086b47c0bc0278ddba0d126b3680994b256854fcd0c2fcd9ab5bc585891c9a41bec9881a6b7b76593025e7e5cc731c7b6522810aac17e157a92a445b59a8dfc1935f7c4cc5efa6e4fed1c76c59fdd4d77b7814dd5f17bbe98cd12cd64609730c617a064a5bdb9ed164d6b2e25a4321db0cfad169df55e5398c8fe097adb2f05e0a7c797dc6523793e5b9fea29cbb8ee2ce6aa6bd8ef8690f6ced687019d1186546fa6ad84fbda4a6713291ff2995f33fe520b93187d02c9b9104bad96b91781184673cecdbebc492e3d25b1cca36d78de0fae2bbd19b8f939f1a73e0bec47945918f3a95a2992208065eb9c4d27a63a2f86b19ddb81b614f6d3309ae411aa8eb83ac5684763a59f04486df41a78b247f6ab152538b3c9ade0bc9f0aec0843ddae7dc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"643649ba80ed23fdeeac84c02c742703"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
