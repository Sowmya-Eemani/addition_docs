<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1cb4b191b70b90b9342035cbbc8d73e9ad09144e4b8afa96ee36ee029b04fb38e81370c434a07315c7e1a0d7bc1d4c15fda0ce2247706bc531cd8150717b3b4b2c9c8d74f34069b5a81dcb1cb14ef3fe6e6cb0f634d6f667f5d41f342758637ed62d70d08d3c0248ca14a8126d30da721f7ef37b2d9fa038ab28a0c4bfbfd180554984a758c96ff80ad8fe7f63dbe522a9b611c01807a5fc2adbe6750dcee7e9c1ac101d6b745983ef9b3de957fd7f223ebab822a408b9ebd231dda1ec1b72325125bd3b1a06bd037990bbaf2306dda47218c57eea7a88f42a7b0468571aa58eb9bbebca885aa9e3e269dde358573a89e9a7f70daf9d3806caa2d71f29fae2e3f2305ef873d7f906fb6342971b428c8a9e9b0a057509e98b059c9382b8d71e42172f0ec68a60b604cab45f4a8adc59c3b7e99f1633b2f092fd4ff1461f4902c95cd99686219aaa2a676fdf109ec49d2f6e19d056fe7f260bf16f533c70bd10017561175d74533702d34a341808db4b7de1ee2f8de830c8d90748312da154870a3e7d48a31f019f218c2c031346f98404b86acd80ff7ce3e6c3dbc54d1bcbf2eaa84e5891f29251e05e50dea16f1e57181e3f6719321e83b16c2492f805bd9a24bc9c03167fe1c180a58b237900e511a57a9075620595ce35e309378e54530c48517f4d1cba9e705080fd174e7329cbb6a7f18ce9ad87b6afdb816cc797517cf2b7b450efb1a35f0defd2415d4984ae9140792a1a0a53a3ca206db20e7c6d660a946e025f70d2810a7989f1dbd8ad17809193cb7263b808c48bfa39d9704e9b95f9430bd244262bed1df9ff22b82e9ed972268bf5962a7847b8520d9d07d59da744acb3f5980fcbec960fc3f94569bf91678f179e400515978a577d55933caffdc65d01cca323b7145e7045e0be31ba1ea97c837218c040b4952be20f76a1d9b77ca18bffe4895c56bf65e5a2e8c912116ce465efaaa63348e78120e94d6aa1325ae5880fd8088618cf12e11187bcdacd15319749467767a1e01f962d1b658c53736dfd15f0ca7af5e2057b9071581645ba2595f2c1938ae9ce0811dbe93976763565979fe29724daeb1b0a41abeb25de96755cc2431a5a8936c6beea25f9dafd5c3debc144f870aaedd4f38da8bc17a3db1b94067d6450efb04459c5dcdff72a8f3308fd2c784f37bbc90f003320a80325fcbb297566d1fb603bf00e85e4272e2639afa9558372a5a3bd0b95f2fb050bf5cba9258eceefadc1faa3782a45901b29c50672d5ed31721169f4fe382d90570da7886147ae6c9bdedbd942f03ba70557b6583d6b100bca6a2681d30ec40950765612cdc6f93d4f0c2c89ee418f5f409baacbb2dd118c97391f6b52ab5a162ae150f6cf0327ba2cef2eaed36dd5c792dd8988730ae549c70455652dc8f10753f59d0b2d99f450c7b9295181258eeb74b3446c3c3547877bbd85a074df969167ba1c7204f54a0dc8dd789facdaefe5fc0f3fb797cc5fd5f16e62e7a9520e2abee0f15cc3495f80edba3535d38cae2685908771f35c06eb65b19db244a8b1fdaeac19ff5e08b333e085eea5756fc53f240d6b68e7f3fed9fbb030a302fbe31cc1e1cc34bb720c2a7a5a28b5a0839bca7efcacd69892b5c60dcdf8eec5d06ebfd855c503991a0bc7dc37686fa4a0f752cd1e55fa292266fcb6c6d12263c67f43dd825079a22e6ee1cd4cd524e99ba3875a68857fc378be71a1033fba459020db86f01ac1b0b99f163b84c2bd2f27df8370d82cdd7b4e0f9d72857955b6e83983b325e28faeb9bbe6e6675804ccd5948167acdec1ea2b058d966d2392f291e9ee7840706c749fc06ba58f513e9963afd2405006e4c3b10399313a8fa0565753848a3a24bfe0f476d308285463eb18e15c20f631801dc01932f50efb1222680b662b2667c7294ddc1ced35ee5cf2aeef0bdd786e248a875a0d73fe7bf73af750f4bfe90882fb879ae60f3eb977cb2333f829df7637c354e52f0aae6d0fff443796b945cd342fea12b44421499bda7d85b7730154800db09fb39803460c3be2ab5b7093af2cc7c249d9a0e9cf034b30a55675cf6103affffd400e0c321a73e4f265412b9964fd23bf7a6890176b1afe1ae53a38801e0afb545f79488135cb34e2260019313724c629ccf9beaf885527222ec0009f5685a08492928519f1055e2a99d885fe43651053fdedc9b186862008aa0035cd04b4adfa2d7deb8945979566ae32de395c28b643972c486ac1d4f56ce3b1a8a457ed766b50dca3db9909e3c49d92abb713254effbe9c534643d815328485fece47556db336972c5916d567eff914c686e59e39837d0990256359a7fc0691a928542e11176909ea3a0142286fa125bffec46df64b1641b642a1d3bfc742ae6813a044abc878fb34ac480bf909ead9d3012290b8fbefeacff5c105245dcfc3a69f166992e91f2a2b20574db80cf60f8519881ffa2a5c96cff26145a65735729efc7d13d79a1c62adcbd6a8b94328e5ea6ed928bf6855eb4776f1a4fc2041d9865df42dbcf60d8effef0426752c66938f564d5d536c2e4914c1647cdd924683df41366ed3332d46d8ef01d3df1db0150913989b5f1232a36542a508d2b4ec358b8ea51d8fca4cbd136cdfe8dc1d1ca56c0d06de0f1b0c4a5dd9d7312ce271fd1d44e0bbe4825e1f451e458af5c7d4a9509d14c090ff473085ca185936c0973e2f2111620f9be5fb820005d0bc6b0640c82c17488729084c267743dd2e3ed22a381f33545e1e1d63409f3b45357c409f586d2e41cb395e8fc8a0aaf27f7f5f1a77e925e85d74fea0cb68de06735a5a1aad4ad7d2f6fcd6600883cda4276d045fede121aabc29fc2436561bb1ac23dc8d0269e89583c96417abc2a73b58532d55b463de50e3c25783566d7f2da252719b3ee59971f4dc34158622e1471fa9a5d96d2502142a4fca9b50fbabfa4cc7414c300b166c74b527f32bdb076c8bc86e0801d727763f494c13ca5f6f27f8544dc0a246ade5d96ac71a4afebf614188e141ff8c42893f41fb5b10fa98b847f779cc47f8209b7230dcaead3c2f40fd72c0a7ef907aa8c47833ae21ac60c05f820ae0d8324b04a37d7dcfeeddcce60b6a98f64e6f8a190e81867d62dd9186a65ce04b04e10d76b21701059d8c4edea5ae92a8338fb88a09268f3e24f58607706e4164582b011fcc966dd814288aebb4d9c313d4b4482a024e8d2e7d334ed375177a38198576bcca2140b0517f1fd1cd257e27ad5d9c4c5bca6778d6c2b69871166ab49f4197af384fe8229b6339ceea530bac8cbe690ce187f392b51d718d8cfd4f726b6365ad87b50f48f8532e943c90436daa6076bd6e7d8ed9ffbfdb39e0180bd32ac6f2c62e1c1143c07931437a7133674023ea5f871e78d13c0df774e5f0b72b0f349ea7221a52b99299a9c93bdb9aa66e58839e65aafaca494b2bd5ea4493396be63d097edf220a7118a1b07e0746de1b17034af9b0e9e2bbc5a5331c7f123646e7753ee96c1b7460faada40f769202ed1f46cc87e322adb53a519e3b2b011e65a5b985924668a81367090bba8936b4a95b45c28a03eb3e8303558b210c4267e9751c601cc535a95899cde133f5da2a42ba6db2e11e35e956f737e04c8a78d647133bae28113fad452c8f54bf1562df50c4827242f7b6af2a02fedc8612d166b6298a32826d56be72900ca776ada55f522e134459d8d73f66046191b4bd4fc46c1eb2cb1f5bb178234b657b4890c16fce2411013e8374283c731d2f157200c54cc75151a3c07f47d1863fc2be3cfd32c21ed6986f851c2b8e618e62b992cf7134cb9eb95a70976735a1c565e6fce5679141450c265b3f0e5642acdd5776fe6273f696275b9b058e1a3bd4310a474d612e01c6877831386eeef85619c2bd56e2939b41192187f3e07d1229766be781b2d65d5770f35ebcc5b0b43e06a8b3ebf7fd8d3ba625003b1e29f197405578c0f39d9ad8d478cabfc9cc9d647db020bef94fea0ffd45cace3e80afac3969c72e0f96c6e9341dcfd9b55ce5454ccc9c7e2e58eaa4f35b36be4ff9fa340a423ee54dc21a9775cfb442b20b9ee5d01c50b0ee3031e01783d6e35da121c8593a9708a6b126227d929f2e4024984d4730cc32a609038f4eae34b28ccb15cb09c5aab55ff6de703bd84656dc87fab87af8a2620ce6bc16856982559bdff1b7d664db980a28e17f61e31340d0e7085f4563ae56889420298f6f1fa5ebfc6ad1214c36c5562545122958143c2cbd4407631eae6ed748307ef53bef351a3f479b398f45c637d5aa3d5c9c75ef09281e21eba3691562e4840b0dd1176da8186dcc33a189fcd0f12286b1567d18e038469ddfc76209005f692f60fb3d064c75fd2cb3ba371cbcb82d7f26572db7489cb911056a52f4d9d39ca9ef990169ba3ef8dd5ac4f1fd4110baf2c3fbb5ea291dfd43812f88feee26a82a727c9c28240cdabbe9d90febd99d5037da301e7afcc250013ae128efb51a1ce6c2ed439d7f13a999824541b997e3e5c09fcfb73d9e68f77d71304251e2a7d0f2fffeb835a35115c6afa2ef85564a24d1d449830cadd8a6b93be1a9261cc09156b3c7b8f09ee0a2034f2ae3156a1daf1b4f8498e48128fe2d9f692243aef6cf7d567b300709ff03d4e2768c572e7a6e8edf91e2e7a9a6299860721a7e9029baa9bf441d32f938518b3220dafd598bcd3a6836879812a36496c7ba5b5d277114ea9a3d04f3732d2c714f0f1c3546bf758505a77595d7a9159681b99abeebf994cc8d5500d0f1f0982d782629b921b28a9bf64961b12082799625b71ce430858701434e472391182877d9c05d0bcbaf69656a2d4d8ae82d57d00e9fcd6836823d6b0314c44540afeb7da8dffcd0c22e95fec518253c0c566e53ae7456b2a40f0c6c1dcc99fe4b471386d3ebc7b5cc652d1f0cb96214063f860e90eb44221887f170bf58d84e37bd17acd01ec66ee7692d058567ae9362eb7a6390bf1c724062af475a869882f2b69c3320d8e02ab1f783d25d51fe5d808f875959ad0db49e9e6506092952f4a214f7493357c0400962441e3126bc8545f044311a3397dba2c861a786f04fbd0f142270d694f1d793cacee67c4cf6bfa64d476feb7ac9208e69c7306b45c469019f9c80c30b5c6eb123cc0f0c1eb56baab2fb39001b91b0f223a818552a76e47c77dbc5500cb8ed986dbd10ba0009504b4c909340e41a7dab04d60e74dcaa1bd00b0c73fde0bb68631425c27867747da8e8d270dce06f2b5af6d2fac4c521f38d1d7b1f1b14940019f5d023f2bd3b84b8e5046b3ec028b13eda177e10584f47300f4e8010182160341ea9d7894fdc945ad0875a5cd6bed6492ff1973a945d8ea5bedd332afb4847488714bc88fb4b00b4e96dfe1ace561e31fab279d765ead566efff1ad2650764f66dc3457139123b8fa94ccf6865f5197e54e7d59d52b0ac8eec17e1e452e073e89d897717bf173613cdb43344ac2a0bdf1b45e34d644a9b824b4fe7549778b3f56628303e8a2c06f1559ab6b455ccb6cf016438955eb451bb293b49d719e38bd90717dc2950b993f92301aab1ae2e7beadd0e7278454c21c201ef771ddff9b9bfbfee1c26973526458ca3f6d129c88cf387a595471bd7890d819b13f7353a170c759f3c7f60872940ebb111c232fdcc97b748f99387bc30579d5f4181608d9c82bfbdde58a09e932873104c36d4fb7cf03d2658ad259688ef302476f626afa35d5423d5cec6ac13930acf2677d1f21089fd3115067d15d82d48fde6b9f2c6eeb7e1eda4d63469d2903573c68981346bb3d03048518e465eeeb05bdf98e0ec0ddf9d6da87b5f02f4908d6659bef0df3eae928ca3702aa7ba944a1bf1f37be28fa80ec9538c4e55e3c6ee56b4fab39812923cc5297e5cc84fbb57f87df141735853fadccef46fe93997e168f8d4fb836a2def4feb2ce41de0bca447df08bcfd5b5205028b5a9c91dc44413c7e8db48c309b3c250433473ceedf8546af95956d259a318b7ab41463a054a6fe0b0bd58cc2e547bf0b9d3efcb849767ff7eb2d42a1290fd9dd34707cd54c1f5ec12b8de9a159099ce66b6b62200d2a8db6256d035d029d841b119b8e80a4065d3996792ca252b401b92a1a00462fc3014d33a0d9be0d759efd4d1209f498baf60200e363e780952376f34c5be85c0dc0aa6f9e058d9d3b1d49d76952fe68450bc3135c01b759a9c3022cf3d903b78e6b256be298853a42fb19e0a159701577065e19efd721ed52c80671477cea21f5a89dce0f02030e56e34a8ebfad4e0c5581c3a8897c2f985b5c8531c176bcc7b87b1b0743a5e691495df8312008553a546f9b1d0e26caf89f6c189a6023071373c4eaa770d89290a681e0a12641b473d7c2a588641ea3b4d1b5ac1cd02e9edfb7e39b3c44947394577de3e9db2b9edc56cb3638bb4fe6dd20d43cd2d5caab88eee2f89f651609f3883f0bda4cd9b640da22f17a6dcbe4e09adcfd5710579e09b2134fff90c2ef0112c714bcd02b222b69282ed92550caa3ef0036fd1277bb1a3ac692a9b4b330cff459e6da2e243e5adb484f7c791d73b991cbffdd36fd8f22b3d10e06e0fd2b2c830cb78a54c7679ac7110f97a30eee89c6fa249cec3351bebe132bebe753be0e0104a88fd2f8ac4f47a28917f7b449f2a2e8935cb4061ef015f04e3bf803dda053821ae1b2688c1f3d7e6828bae83cc95fa622d668272ed47c228de74b5e45e44d544f0aa21ee04f53c258e3e69e53ee2709309c34752452917d9b532fb92303abff9614e66f4f57be1016595388e6d0048e6e4703fba28b3b82a9a38211a2c28f3603cabe51a73d884c9ecde1c8d4cfd8368dc93c38e878b79a0f33c89a09349abffbaa4c772d26339a4d9a21f55dece9cac2e726d1a110922d4d8363fe782836775cf988fe7f26cb4ac4ecd5225eac21fccc1a180b0db7aa333a657bcbf5d9d6f0d130430e800b393e4c0138957b670f6da73e04a529221fb2e72a77951c7cafb397f8bc35b3480583f229a116004ede2e0fc7bb533bb3206ac0a24e20ceb72065ca3b105def8c820b6192b60fadcd0bfa878fc88bd4cbae78c42e55e5e2853877609b8cdff2b6457f0b5991a0a2d4219f1d05afe126c886be69298dc31d6ff93e90a3a58f1b31a3b7b29820ea94d93c179c78d98dbe1cab2287353d57b9a1ff8890625f2e662ed9de8bc408540f56c1c7e11da80234b544586b3ec68c4e4055c50086511b636827cfea55561d76a3382136fe6312980cb59274aea658c0290428d41ef4f93c65f8466fdfd9208953eb4d2bcbf8d77fad0974c68e90a670f66ec4efcb624815e2579fcd683208adc6b8642e9f68069b855126515752d5d25dca7f4378ac565e5055b9afafc28c6fbb1e5acb1a3f0fd0e2ab2f9afcbd0a9ed36d3c577d91ecd83969da30aceb498333fa8fdc778a3528900f113e3b1a1535039af27ee6ca6f3718b7152f76c4d1aff0210441614f76edad0e47dabd508dfdde0015f9927ade6abd652995f08d67736d28008382e94fdca5301f4feb3945fc870fd57cf00e3547b9f48e20331f252a3a8a02dcee7b329c91c90703641c7fbf79747f98d34be1842fff91036c2765990da326af1bca18be7af9e3c8601daac2885824abdbcd1826720c2ca582fd9badbc768931bdbd484c0e7167380bca0ba3270b71d7603830884d7bbe08d546e54a494a8b4a8e173f3c0e82672db1a1cbeff2b8dbbf2fccd890f1987644d05116798fa70f8e848d97689d9a83e10252c46fcfa9e15ac80c5987f7b25e8f787a4d0e21acdfeb0cafa3f43ad06bf3e0134b8cb762656db881a2bd131e27ad381a3e2dcf39ef14a622399b6a46bcf79e5f8a87b5a4a5bb639e8234e554a9820e6493262d78f92011620c8304136d635262e90d7b81427a6c63ef36bcc39e55856f33296bb1d52bdc5537eee15b072339f57175deef76beb96ab4181fb1e4023419392081c246932da4b4d3949192095d94120fa30ee79d4ce3eebb4d692f1d328d20f638d4c67e1a680b454b40520f38b7910136165627cf77be2a7fb99f3b87a646dd1a181db9a1056fa3080592f9cd0295fee4562e4c44480ee42533f27aa20c6ae9f9db97e596eaa950df5649af490830b10737fa86e692320f9ecf4e8953a58b37a65e76e9a32345f70fdc452b3b25e2710257d884cdcb8efb15afcbc03fa729cc137ac0ab1cd89b11dd264e465f0742ed95d208af3e856b168ad1dfc02b175be74440b4cf101bf72cb452c6f3019d5b05153c682dcacb48fd95026a61a0a14d4a77134a435fdb867f067965be6af8d6fb3eefe7fa4038d3c09c97b3779102dce0c0f931535dbbb0ce4e4d8c91b100b08fb4e7a09c03a21502d1d4d6330facd5f1c68aa8e146b9983697ae93b603e5cfe069dada5fe4a3b2ac09e82f777b95fa74051b3c82c814f96e49f185fdcc5b93a247874e7ed72a954316f6670e69615caf562181cb274f95de688c9ecab4198e02b1c99ba89fb1c50adf3b6d0d62da7b4ac9657430cb5c86da824a7d6a4ae08b17fbcd805459bb566a2c20b03cafeb5e02c095f2930f0432ccb124a138abc898dd47273cbbdf68502eb6d76c094649b82817b1c7444175084f2372b07c75e48abf5fe6e6bec21502832d8bace55f7613bc6866c22c04592e906f79922448872aac64d2476f2cd9ffb8ec8f82184a41e0e1f5104f3b4a194feb45ce6c33f37733c1359d8c9ab64a150ca64f63d454238dcd70c5154d95b8eedf69bee7e5a6e5827ae8277981e72b72e81cd5b5d4b1a59506b6f211fd4d82f73b82ffa915b5103ca11c24c8f95a81284a3cbeb0181329c00682e76e68bb268a18bbe98e67850065ed93d74c52a14117088c8b350f14d0cdb65f658d04121ce8f49715656b3018bcab05b9237afaa572e9256c242f8c8bc0ef827faf3204933d55666d0481ded97ca891368ef77f3f3db992cb46f923d086af610945c8f11773dfe75cbad4382197dcd45797f7e2027b09d4882fe9e92ead8d88eb6f3167f05458ce2eb7247bc10b9a542050a51661119ffa57624579a9ec65ced70551031cf07af7e66c76671bff885c1cd2dcd1565ea1e2f16d848aadd05547d1dcf754bb1ac5fe388076c8221c28b4cd0288b5193f91d59e36328bcdaf6d3151ab53d46cf2c6f982c7585c46c2cced01b8e5cb3e674a4f23cfb5f2f8de7b231e844587e9816a89d991198927a3ca3fc3de4197e7d3b9ea4cfe01d73a128f35f9bf77660e110d6f75ff4dc9ee8d8d7af8767a703c8d81ea71f78dac0677dcc9ffeddc3d454ab1821ec147ecbd2318041514633880533ef2d3520338b252faf8ff7268eceaeca2dec293b63a160c7311b4f0344515692fadee6b258ce54d7d16311d8af754d4676175f99ef3757030def43e0666041c257254820499aefa101f5e7a559df68f0e202a7dcfed8859f6abac2fd13c6893e7048acbf725249d29089cd73a3d0a69bb34b0925d548cf5aac32c41f0ccf311888ea138748d09440a04f1f0a8288e08acbcdea1ff6bd8673e29287a47682ba33cf669a781166d86923d713751e52bba31a03b1c3afdc12b017e51a929a459757856fb3c9ba3742dd06fb5914b29c4ab5ad4d66a8c19ca445958cef3805c65147e25393142c2861bfb96f491411643f1139708a0a13e8d6165bff63969884b879167890c37665451e34accf919e7cb9a0c43807603a1da44029c4e0b3926e24c8a81e7a99feb2bcd5d18fb1b3357c5485767d7236a61cf0f391242ad16b166e5177c3b854ed881c1b0fd828b3fb1034cf567a4e98e3ab3d4da12bc490f653fc798ef5a644b1f2110ef376cb87408143135be07fe069e4760707e785fdd1bc7b396e2442d33bece132e3ed3fd961a8df19dfedaeb27ab8d5da2e4554cb68eff68d2da7d4bf6324d38b4642f0d3c9d89e4f7c715e3163dd41c83c4106546ca295c3dbda2b30d17ae4f560cd3505deac8e47d6ad3999e498725ecd6e70424b4028e3eee765b129b282d997b5806a7395cd23835467c7f616718f51d0dfcc2169b80ff2f3c46fc6d4856ef4ce93361c3c6ab40064c4a420f22b41cca41b82bf7b997c32269bd5630f2854c7bce7a75675d6b72cb6b1150c3d462819397bd72f7378f9d371a56d43d8ae2bcc12fdaac22ec09433c66a8ab390af99afd35922da7a8e202e4995a5f74cd0779ce29fcdde601de9067147d052cf531463119fd0fa5a2864731dbf7ecb6ed2544b39e5861ecbf9f5f31dde9ff842a39a0ed8322906d1a50332531d0058a262aa7362a559f623c65386c19accb3203f20fccdcacabd4b9ca01464fb139fd2e0445b5e4ca4866f8bbcad4ca89b1d1f37947b2c6868715d777a2540cbc2813e5e83b8ac2eb0b7023f9dccf51c3ca0ebda2af6efd7c1007f2917de6742ee17993b4c132edffd2769195d93448751b0d87f741b2055c6bac3fa0053f4d938db9f198f60b060867b05f0868ad7bef4e846c85b446e7218ab0117908ca001077fa19ff924f71d4a2315525762efe03d22029c6f0fed69915c0fdaaeeeb66d65c7030a758529ff58cca68503c257c1468fef65d2e2d8b0b8e0ab479702f3f0efb2038f9527730badc1d4fc4f30f4fd9aecce5f70472a9bb6e2b5127cdad8c58d4630d982fc498073e8dc6e31de384554270ac1a0eab0eba7f5c4d96d552f34556ac988fa5f21497dd8f8c6d4dfe6d2dc7e9df1d472a1e479579839abfc340cefd01a90d4dac5b7a75b6b8036e22ca9c90041461c84aa60e908618a8ae1c7d54fac481ea752d10e93d82f493858b16be04fb582556d93a20fefbce3d2b79dfcbba164775f89e3ae4ad6d0a02dbb195b84d57394371f2e79a79cd5219cbcbecb66c805b009859253326dd4008d9427d369e0ecac78e59fddc28d1731f33597d839a40bac98fa90941097731d18d1b2651ee2dd9dbad37c37b02a458bd69c2bf1774eacdf05d11fbfb8813f328a95dfc222642b63723cdae81ccfc0affb9f637157c1086e95500779d7aa92dcb5ad8c731d0dedf5151040462317cf5740555917ce67b308d5c75d92785a85813596af57642a67bd7d4803be547eb91aceb5d142fd34616f5e0253163569a8ed18333aa93096213acdd48dbfcba8dc276a1f6ed518cca9f1f10b166ae00a76417ddc7f1202e1f2fa9908e5cc6a06be7ad90ec442f95a59ede0ac034299ad501536593a16b2aa6fb62d50b11f8afcc0d265556f35130d793640e769883a9d36075494894a7cba7dc368b7b500391a64c69856f715c29fdfe3959cbbdca69faa5d991bfa619f3907a4ca820144d702531fd5cb90ca09428262684afbab5d0790073d6caff31c7040e6f9c926ad3f1304346a9d91c0dceafce8d74d8b47c496cbc3082d29189771e904502d98631cc6ee652525221425e4d2d6ea2d1d24aac24a8a8cca2ad2c184ee9be0408d75f701ed8ee712a803641d3ce08a6a74a5622e5b0a2d34af1441191835f1178141e36666cda63f0f24c8313faf0a18ca0cfc5b53749ca8765ddaef0af74900441530fccfcd9c686203e32edd5438f54841b841c812ce8a87ead5b20e4e7db13fedc7ca27eb4979e4cd2086c6328c4c0b4f4aa7aad75ce6412450770199135579871a27f38b01cc0db9350b28601f95777faaeef04692dd115dadaadf85438c71f721c53fb69a74dfbb33defd4f874eef9e61b63e215d7d180db5db9c4e31229f34a557a99dc65a8a4af913736728706cfd1dc1a685aa423a9e522d9e44771dc953ee1207c3a0ae856374b1836d087f88ea01630185c5cf2484cbf1677ca995e7311df2d6ccc45eb365e2f8c072edb3dfa90ebde610a47083446f2ecf7fbea6013e5733041a76ba04ebb2261bb25727c2fe779f1abb94dc89b47f0854376bf4cfdaf0a491df4bd6f469b07fa2feab32bf255625fd9e14d7b11267deb2ef9c96c48ec94b1c7c79dd33af10abf391dfd4043b7914c6bfdea427d87e8195062ad5a9897db226fb72e2f58b6e35a3ad00081e72c89af596c693992ba6811df983437a69e1d90ec26b3fae404e1b2c7135260f2ac6c2a5fa9e5c8e6f6d92376a426b50fdb3be0e165b2811a96bb1c9d4ff2716ec0781a0c0434201266dbaddd38a00141152d158d3970eee91c47c80a760af33dd1abd8756960153a1cd89553fe5859536de1f0e724693664be5719308e60b593e7453dc839fd2798bec108d92e9b3335eb2fec4e140daa5aba0973bc18c8ec14158b3f3b3372fb3d7535f269361e2a90514d679cb18ce970be3dcae2ad7de370a40016c66860e2eae5cdb795b75a33306de2b1cc1d803645fbe2d12c368d97eb7f459295269d7ec8bfa1465474213b0d5b26df8a48d26b67e2a8b2847c8e0efb9c8c43007fa6f94d6e077567249ab6ea1ed4ca755937744767ee06cbdd9a10a5cd14093f9c6136bf48ff1b37e23bc62b01a9ea403a5e845334cfab6076582c54126771b774f67b20b9d41f6b0288e9882c17ce58d241101a41c73b4863e29d2b44cde39e9a63b61aa3127d75f7fa5e9b7f34a860de13c1fd359eae2e2e8711e752f103b902cdbbfeabeff685e091a71589ec19089e30dc61b961e0902075c6780be8ad56b394df004007854391bfd19d15af6f08d4879e04f835d155de24d3d2bdc33a40ea400d856e3b6f0c5872bb2e7d763dc26da388d2ff2634d4d1d8c72b84d9f6b766e52e5dbacba8f3530a669e9fffbbf2a4ed8c5490589656e5c07f386e00cda7db0d4bf6e71c402e181303792fff38d52adc05341bb0513d1a05678c1fd89e766851cc011a3c302809000c7a268068b6d0d36d4944e14e0464a918aff055706d76579f64786c5ea8614fb67e1c570e1c358170a6771386f44673f822efb5e185df94664abe56563da9c5bf1c31a60184f0b28aa7e65c70ef5794a33d13bd0c274c71920c96a0e6325e297cd9bcfdf5ee3fe3343ccddc89d70b4abd40f66e6e17dda5229596609cde208c2247dbfbcc3e67fe6df7a82d3f2b9c97b80255e882ebca32404b7e76058f0eb1619c175404cd571224f5a86bf42d2d6db543cdc7392b40edaa8f4b6bfef0e6f426974a0bd1f18810ed4364e6129dd6934a2ca69b23136ac18f312dae95272212a702a789d26c8b6d494f0ba01f9f0106ce9ef7609f567387f97f4b993f19a10e44d702c5943e31a5e345b974a8600fd8ca00bacd3cf338702f27edb2a41b3a090db2b4a6f41d43e0b88d061f254efc602b25972fcf147daa0ec0bfff43df0a92d0cc06bfa3650296c099db72d1a2f5d17c53854382b60120dd9181ff9570b79cae70389eefe07c79e56d8974617e6eb42f018046a79997955c56b827e7fcf4d85a0b9de4491204bc7e4397874229f9a1e2f52cee9c0ca545db6edb292aeae3e2c84c2c790fbbcb8eb1b728628147c8391dd2fce2fd7f89cdee83530950937f229567b64f8c40a9a466bc7ff9a1106a622ea85d0231ddcf13039cb99b213a5382e0b0db068d3c5857fe10cb3568c0ecf71361d9c026a01798ac70f3962bc1ca157992496d48779a8ab14e5dd33839487939b8ea8f8152433c626e1e54fdf7c95712a8af14843f58aa822d37dbf29fbe613d19ef47bc65436bd1370890b6d385d0f4a468f4a5ebe071a5440f54c82b907b3fd6442768997520273fbccbce4f562dd349762c7a55b72de34e82b170bcbe17d79289a0213ed81da052cc72b48db0c34ba8f8c2c085e66019d7f1a2fe7f95680bc6e6dbbe7c6e050c02ae4d47c09a1b6e01644e3f647be8ca902c4369614ea152082b5501f22ee137984c7c2ef6608f9a63af463d39d74b57885cb6850c3e1f9dadf217962fa05bb33b72b619487dfe704ef816d06e258686988507a19c7bb2c3df8b24b5fe96a2c1e22b646844b2a56bbb50e86d72122f5885d54c09373dad1984033e5b601ef44d750e13c6a0b26deded0bfc807ee379761ba3fb7a0d0dbb4bdcedd95c3110f1fe434bdfb11c4810780379d3e0c7329ada1c01a12a237f62dce5bd4b2c085422a8e9d9f5b2ca0fb289afc293ffe11ebe16ae450fda12de34e45f5ecae0c19ff8b1a48f8d990a2eb74e6954816ae99c9ca33f6ef3f0c9657145b6c1639bbdea9ba51b2ac9ee6f249c4fdba29d91fe5552095bbafb5d3ca3e5c1c630504e6ba7eb0d88b21abc5a729ba54cdf32522b246d2dc4f02cfbb7b96426807f78c24467d863431d74cb78e467a65148e9fc87146680ddf262d785548a0da04f3abacee06deeabb441c3599728162bc3fc55e11cb8c3ca785772830d0a5a5a7946d56524f11f7f66d33e9e31a46ace4f2c0ab0d3d84085c5f7c5169d2fac8c530630f4430b09ca5e00c9499f1b91dedebf0c3aabb2f45bfdff844bb5669751a045d2ace0c2f54f76185d562d5f7f9226e8dfb0216306aedbef896f479d581899af410305ca5ee135e3331937d96a08620aeb7ff86775dfcbbf56790c1805be9cbe740442fb7c1004a5bba96e5b6099c4f07f2c2e4ea17c5053f4852efc62036c254661f19e12e67b0db5156904dd87ba97c4a11e5eca1325695e75327e522f66dddd1a0fb42fa53937844ae4d808b6defebe5b78ff5ce796269f33fdc8438f0e95aea51a648e5f99dea8b083307abb74eef3cdf85329fa5b69652ad5e49b36d067ec079cbfe0b7cd443b0c6164e13826b5bd2a6011c73d47f6e48c1d918c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"643649ba80ed23fdeeac84c02c742703"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
