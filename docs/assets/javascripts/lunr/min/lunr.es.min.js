<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eb8d8258642c7f354b37919bfc94a62e84b60267118c2fe7b56af024a359457afefed21f35244bea13b318b42631f8665e4c4ea69cb24f65a57d23375222bf9fb058438c68023dc4ae00749f223a3dec755a90a0b4b4e98f5e443f145f30b1e9a53e66ad51484b885ba22bb8fdb71baa13d8359554cd552a1eb86b157a5b3c8d4aeaa048db13e5137c7f1315f8666c883fe95b777e4fa2f4c225d1b4bfaec9459b71e361219093233068c2d629ab62a356e2ee197a57c3a76d3b185234db905676ef73fb0e5940794fce2db43f33abd460bd1c3ef7f1a908a1bb131ca850cb8fdeb6e87a1594253a45d942c7feebe88a145487d7baa2a927be818f3cb3102b9f6fcc919f5e7f1408c5ab13fcaac0cc397db0a0b3f46fee651f9324a970bf347374162c5f4cd003d363d82e3228c08623e087e65ae782422c51e3d445d23607a1dd9872cf3f555ed0b51fb97fd9a7bb6f288f08fb545327b02ab67384bb3a1c178feb2664d7270cb28c068d84abd7692a1843efa60f4e23b5c3ddee290e57dae776073080eea62e197b8f2d25107465793e38c78386e650f395beace479de05fc9515b5dc514a7d7fbdacd8f322af2a78859a613d2791be31fd9d878b584db19049f404f12b38fa7c06ed40f06b23ae5a52b794becc8dcaa471014b13d47d4792c5332ab333b429a478bb5534a8e3d3a4cbeaa77ab12d96fa14a5477f8a98b58f50dd5543a2cf84cc518637eb46a644436f38980f1502ad1d04725f8e0b10722693422466345701bd2a807065e2013e5face5012b85996e956bcde0400f80a766bcf7607df2014256eae3f2c8dcc122600c0bd7d32e2fb74b6ea16fe6b3058f55ff34ef3e95c002d8f5104bcc86d4b3ca86a70df6742b58a80d26c01bb3653206d5de136d22f204ed5c05836716bc25d5128d6231b21d7b341be964a4c52fb53c78d404fac70a13cb107c7f6f0b0456060b21e05b1fba965428b9c109caf2b489992f300bdc6b3b8d6da9b8c7749e804b68bdc30ca7f99bbd26165a472f8b811ebfbff00b9cd7cb95ac403d4ed701d676c7450a8759d422454acfa0364dd3aa46c42f6df363349ed8822baff52eeaf0927f4666a475a3f435ba2fe9b1ad5a7cceb6936c00c2c088aa19fbe8db3768cad92d69353a96097221072b4ebf488e85b2855303e7c00d49c7f9779226aa9d76b2812712a93e2ef7822ec6d1dc6fead352454846db8cd2b4e380ca9fdae178642fab0fc416017674a61ab94ff26462eabac8797efc84114b61e3727cd40d861ae41f5cbe934e6bb24fd20c02bdbf4dcdef6b0d95bd9bd82f0623a46919108d183b76885d6f3d1ce23498c9ff5466383880c6969201ed8fbd96b8ea9b1d0cae91256afa2ba461f515549815651f71ea08ea6328386a33e019c64f18f54386ef6fcad2b6c315f0ebf5aebc5254aec71c99094ef4ebec8bc637031a95740ee82ef129f15c2087a29df6b2095741d36c7da4bdf9f667c4d68b60bbf549d28ba81ba6cf335d8716b6896d6931183ae5ca10d58ede17af63745a4a33165ad0e5d0d4fde2b0736915c1a1fbd0505aebaeab01b9634dbc2d2efe9a17b110d4b7020d0b5b247e74f516f2df86ef02717d7897852796c3c7df06b1785b6636eed017458971f610525815bf9cce275582136b79871f38851abdea565e81b98563b3526915f15c75c0d64b561b1398014b8e692e0c1b435a6bc52fd5ab0a4c81a7623e4b472766bbcdcdf5793e1bb32901e872197699bf8e06422fa464de4188e7b066a1f61cc415fe6e5ec163477193710cbcbd1b6f183538f94a11bb23c255a8aeb11d3dea78d0572e47d881ae9bd817e262d27b08b7b32234c02314854f35477fc48edd9fc54c9831b26ad442206d2414174745fcc4ac82e003a28e86e992182ac1d59390487e2398c6af400b976e302cee51ebf8477c642698cc9bf17b342ef5d1d16a1ddb0f6fde90fee89b7f828c336b4dc3bcc93eda9bf21654f5c231f7b3f40edfa397b5967b5baad2fd435d9b28a1fb1d84d7c3288b6fd0c666ad02a06d03ba6c0d3414b117cd3ab14521300a5820d2743f2e2d6b8fbfc2f8797c367b9250d0b50f4616143165ea24537fd87051d8bbdcaf307c4d4202f034090796c4f4b22f977627bd55061f34318c230861d1ba93e69c941ff9fd8f04fc6ee6ff19c6efa7093572edbe51ae95d49e07ca1b6651200e7468e7fbb815fc2528b3aeffd9a73b7bb38366aecb048a6668c64c68fba11f301ba45221b957cb8ddc24e0c62c9c515cfb7ea0e6070c87f461fab89c6fb83ff8237245c7d65971a30c343c17b84f0bc84000bc807e954dc8ce78a03a58c475ee285823b877e1b471ab241997c9d3b7e8f6ac2a372d6527800711399eea9d95df962bda4496aa8f3a148e35ff55de656ca582f9a3d9f1020a1e250ee7cb3e379fcd9cbe0c6530d49d5f9106a99a3b329e58526710b2470e062fc043717531e59f7c083dce4f08686bc57611e586fe55afe293a41c92f7e9316eaca0451e0df674ac7b15de73982a9b3ad1e4372ce627bb9c848e2ab5e65578d24907cb4295e1b64f7a87b7e74184cfeff9ccdc829ecb2d0dec7b37baa0bf71ef41002435e885f07322473119d6bac0023efc4bc742b485d36cf908195aa8defddf5d753437cfaf457b3effd863c8084675b5fbe33d5710ebfe834386d85292f96270d1d04e7a1eeb7318294ab217fd0c8fce7748b4dde7ae97490b33610c52e98fc6ef1616d9d2aa4e0ac7351ccb88c75d7dd88b93de47de0ace5a00be3d925dda3984af13f4f45794cbd8376dfa95f6925d4574d0fe4f134f8186368b1eb64314c183b4d122dab3c87094de7cd1d3aade3b4da3094650657f5ec1c04fab86ff7b60d18b4c91e424003dd5a3f07c7cdc60c504aae8eba12fbc13e125b7e11e305f367072aad3efc3116c77c477f3c30613dbfce1bbc3e82a60399704006a756fe4b939441bd30257d48fac6fd124130a40830c4146c7940269cd915aa03e09e085e2337790edb3efbbe58aa2ab4cf2a310f2ad75319f86e9b25236bb7c2adabdbf1882522a55b9598538c9fd3a4288995c284c1f699b68baa04fad9d3ae4aa15faac80e8ce9ff2cf3aca620f03e81548331101b883d0b279b2eb44b19d095f656d3e9ce040b9f885990cf406c277a6129550b6c37d406f90450dd841b08a2b602a3aa80a9a21d254aa4e9e3cc95d860c01c8c59f7c18fa89f1e0bd712ce33a7fd82589ffc29916f8555b23251006bae03cee46d8e300b20a07d6565e440dd3f78bee9548fcf86886b6f748ce1f6cc26a637d969b75e220c5c109eab0336142418015d6134cd30651d0e38a624fe7e3254c0bed74bd00904911807d2209dbcd3650a2d830caae94f6c0c174dcfa7daba4129d0aed22546a8db303cd89fc21455467ac28289c66be1a9aabc749e6b4b73c127975c8364df71c24e4394d787ceb325dceb8f9f2fc0e93a503b18d9235afbd7e806161337f64cc2bbea98b493b47c2e5a838d96cf1254f53098f475d6e693c5189af56b810813c666a60f2c3191896d79b3abbef5f977c70793b81f2ddbd45e8bcfce32ca7f098ad97f262ffbed2665e2607da23ef8045b6b1a712d0560c2051cee3939f897b209a3969abe5e550cbe98789a36427255ff05cf1048b73e104a538680706770fa944c0d65da917eb74fa3dae7bc0a565ae780ee658706ce709e4f532cccf05a2e0c8628292c23fc8549e3c8e108c7355383923dff938e1736a68fd91e64e4303ba310e10a0963995baea258b203105c4416773d9d380e584c1002aefd47d6201f15bd06825d71a46827f9a980dd52c06d1949c76b6b51bae0c8294812c24f4429e8ce133d112b4a35bac83a61bd739c89e10032a44a76072cb243d5f4bdbaf391ea72e80a7e930dbe6a0f291f1c5e6703e024a21c35eb539b46246e10ab170dd3ab70350fca99205274bbba8be888a400ce8754343b97a3959b53f52aabe93649d716d4a91e9cb84febd9fcd9c3f7ca5290b547c3e1ef3a1eacea867d505dd0df0864a8208797baa1b4f7522dfb9138bcfdb487b2027460c8eb4384e1648d6d25c23714e1688c66bc5c0704593d474e8e03d5e91e08afcd679f70795187c44c9756ae393270418741d40e8774b193f93ff0f7c64576bf23328c7bc020b64e17c3fea72b5d725fd4befc9cf46ce5917d66eee9585c476c7479f338fa5587f050435a62a5382aa69c61a273604db005b7abb91dc339b2e62b5a368b0a2f328d92ec360851fd7feadc6aee4ca2a1529012450bb55acdc0b1659f16d079fe1558e803700da6ebe146ed3d2256bc48bcae0f2036e2932ab12124fca754a141c633764973ad52a4908465d8a8a348943486370be8636f927ccea3251fa03d3c1111acc22d29b227f648f562e44761c5f6e1edcdcd9e599c5437f35ee48e1a167986f1fc6c6ca4322f0f7ed2e497257ddbb01e91f1c3c788d455c94fcc4dadbf22fbe82fc11fc3a9fdadc0ae784fd60e616f56d49218bb604d37136553ff97c1b860258ba29f5460b611887e2bfc4d042c0329d968d10da3b9e6f1bba5d3c75c7ca8cce0fc72b35f905b09fe3123390db1bf0180de1408dc6d17281e89995050a4fdd77fa64f6dfe92ffd42bd89f9728b49b9e354aacd40c72986cfe7a825c24105e0de25fe2e0620ac86ec762f5a6db868711c4f7e295308b5043d96bb6507f639764b8225eb3a36b530b13304b4229f34ead15f81af5abb186adba297cac7141a70ce8a9fc14302d84099c4b8891006c963ebc27326eb3364f411ccb176c1840849aa5ea89fb56ffa3dbfabbc469f91b7ccdf64dce25af022af36155623a423d21735c7190ace4efb322fd1e1e80f35f266ed4d05db3215b5d82998ee403d624f760ef8aea470ef4745c8464785bd31b9e1ff9f78c9e6f6be64189cd0200841086be67492c58c3bacddb717256e5da0cd3d2ab96f9f718e4b5cf54458581d7d52c615e71a7f0802066a8ae8b01952d40a10b2217c5ec6c07f06a80d9ce320c0f209604af77a9e8b298a9b6a6ed7b28af58cb698240640b2bddc0de04b094db4513ef051813107545fcccc7ce4ac5910c6e1d6cc839ddd427bc67192f1f6ca9732f803a5ac09e768494abb74a789775e5df96f62ea97090128463280c2b56a3eab6758acd5658d98e7fddb0621d8017f27e7933916ca10796f921d133acd8e86ff5a7a070c2a29aa4323b875a5733de45b41a440e60cff4ede6ac0a6dc5f5270b690cfed34143bf871e7a4bf987247528b78880b44d216dd067c5610d001463a9ef1fc340928307492d662a5b31893408de8da279d955f7b3c95372a4dd12d8a0f1d3b9d5d7e302ecd2fb57c76b0fb9bfe73c3b9018344813219b7b1e8c73f04584720d612eb051113799ce851951bb5ed598b2f174c586db0c033c77e6782e20ea7ca07394f8b0ec411f2ff30871d7e4591daec190fff476020255ff551b08b62c1f249ab4afbbc1be628bbc6eba46d3b0db99c94909919bd459061b42f6d787ad45f86de3cdefb2dbbe83abbf5e5fa2842f641980bc56f779423fc3e489bae7b1749e5823f178d35175766b1b958d2b688fe0b87c54386846c32139862646185ae23eb80754317ef397b9a2176dbfa4194b79346ed17bbabb780c7f8aa6e408e5b03c6f8902c600dfced82ea2d8ff939c8d423b6b40988f6d69645c32e0b6213728290c9b39305b71d49252dccbab0bfc2347b3873d7500897d4d3274d7d2baa02f202298544391fcf4c80ef8a6ff9ba428ef2753a8c6f8b0bb6f3e342e8912a02debc2d1d7b7960f5de468c1d8e6d97178cf606f8d43dbfa16291a4f81588a88135bdac7ff4463927708aab9663e17b3399bd37eb61b2445d4470a1fa84f76ac603614256d1cab2c28384a65e666d9916b2400dff3dd010eb4a5fef2fbb01b572f81fcebf430646c339c4e98611a9246458767e48bb6684e3b86a7f456eaf1176ca2ebe205e636b44b4bb00de43ef3e7eaa7d865e69dcd73e7057a146c7c7faa1a77f4a48966eedf088756174db792c3ecee3b23d880282b7e45f06ea0855486fc86cc285d18a5cdaaac097068fa2071b9c69e00baafe8ea908bbdba1e64824d8aa645b79e7d8fb199f77998d4eb4d6ef4284b37db4bdd9fcf7ddc52cde270609a83fed38a4ad3bfafcf5d8e5fa42e555afe5fa878babe474c79dd943105e768ae06b04bf70d05a3d76522d83d219d442971796145e586cfeb5c2aad3a5bdc188d8ab0e10fc5dd9ae209aff0204ebda3fad46cf862f555dcd792594ac76232496156de5774ed7a42f90909da057b6db4efe661700940c55fff0e1facd5f962c04691a1269b758cbf8b7ad0c5e07ff6d5de3e76df74208b33f59432e2cc893b8d7daa3eceb6aac5a319d804457259fe78d77df529e84c3b9b91c092ec6cfcc58957fc75de4bfec986a9dd3aa958000e6314e5614e2fa231f849394473c402e484ff71b037b991b124301c4d4dbc289924bdac705386f34592a1fe5571699ad72c51a1159a82ef771f0fe0e29fc3258367ed283cd828674c8ac76fa8b93cf619852f7228ceb3e160bd7f6c0d1809120c2abee79e164f945f00f2c475406404dbac59349494f81b70080939f533a59858e18bc41785b5a1470c5a1ec3dec4a6e7ebb0eadeca59a365a7a40a1575b9734b4647e8bf8005ca1e0539420152762b67b2f9ccfdafaad3284eab1bae62ab6ac5d3c330c89c9015b5e040d80614e8f6e06509b71c4c82e306e11a8b1e983ad35f864f1e652f7cd9b5e7209e6941aead8fe2dfde169870e631999b8b0e26ba4cf96eab0a63bce2baa97b076370265fc6a814e3f2ba48a6a7660996f3f2454d88ab0aeb601cc2da4702be4d95ebe56e8a4fc3feabda389a261d40f20429f6564fee2f26b6639f495e757191a5ac85c32253032f5c7a263e9bce147349ea71ff780defb4afeba902f3817baf290121cd7fea2b49cdddd2da7f79284d127512493645bef2eb2a70837e2fe220ec85d7762000ab62aed39a1021321ab5ec745a1e2fe829af857b3f5d12e7f5f3ed4a2df7a7cbcf83e34f58d50c5fa44791afc17316cc75028883558a9bc9ee0ca0239f1e26032503054fc46d6cae4f8c4ceb7d385111d8795cdb7373a8309acef1300d86e601e50bf6264b80678eb673ea39631f6d497788a62e18ca663d233e00e2bfafb26c8bfb6f37c33ce36816a89e4af500c2b388dbc566324fd515703bc77e6b8d006aaada87e0f38d42d4a04f55e1fde05e152d1e20e37ce04a9a862e46409e35dd9fd1b087a50b68cc14d484f1fe6241b0b22993860bfb621bca29563d6be5a31877b844ab12411149c6a756054a023f4a6991d61628b2fea9003b37c8047e70ab155f10d9c5dab58205873bf47da2b68a33770c1312b7944acf6fe495bde1069aac35c98d01f3bce70cdd70f9907d2793da9c845a1c9e770e934501358204dc1ce83321a33b562924c1c0426d8c26690defd212b224d7f81da4816a3cae56762b89bcb1b14a76504b654305fa26846bf2e43d813be2b04a39d244954939fef656fd1a0d951d61d6bae3e454419540494c49f9b175b4e1581e1fca5ffc1f8461226282d0a7afec30b7cc315115d54cc335c7babb356efdec75c7bd8ce4d897e1d476bde1d4cd67dc44f0756eecc86890ec0cc3e5e2d71f173d48e7fd822f6ea66a57552df203c5a8f8cedb16a6245487029d822002d5c4ef2f614eafe9bac4aba9758fa130554f6d561434dc455f534df8deebf57c2d99b69ba9f5554002c02571deffc37e9cf7e1ada1c2c708a80ea411d3a2ae02024ca78d4761e0c070f9be09633cb7baa0751e91e9a1c324ae70720f84537d79a02b7a5c5380a51f9986de2863741fc4dbfc5e47d6eaabbaed7ab3dbe9f565df90959e31b0055f4bd6dba10fff049ca0c663b2971886943f56e67edebda3c3ad955a3c52405312abeece03b625bb091b3f3d4d0f0f29f39ec2929e22f81d3a46b720d733f0875f8deb3118fe45f688ed9860e26fad1345d6c4bf1dec9c50d56c2ad342d438081e43d36cfbf1c2dd2bd2f13efef5ffabf60101c86897ed1d8e9ed3b0e627cee3942fc2fe188be7f70221f92a4ab4183ff2965429b645848b3e41501e45b6e2be8777119c779999f946893c5263c3fb0c4b3688afa6884c26d77a374ef99c245664c19c734465d632306f953bf5b2fb579fa96caa55a00cfeda4895670f9117c9220ea6595c1d3a38bbc73a39ef5fdfbc095a6a388675656983c51e76bd2b6c1b5c638dc8b5402eeb442aa8d2ddf6ecf80856610de8bb36e5f200637d2dc7dda0cdccab0af34a276503171f3866a8e23f0162642d6e5011063c23a23ea98b4f42e7222ab58efc8166d662e1fed63da0aed81139c593aadb79bbc6a999fc04c7dde6ed51a883a655e11ba12cb22038d96741912b27b59558d6479d746bdea31a793b594586c4f4ed36b04c473bdb5229e8f7352a3db968b5dbd857e77764fe764a7145920402f771f67686300be0e44b63bcd51e07d778791147ff52755bd6a26b2e973cee68bd3cdac6fbc52c8d3eb2b8a50486d3bd330cdf7a0df2ec73dc5108ef9fb120f543f94673b33239746a1182ddcca9da4c2cfc0c7170df79ec9fb73d33a14386f9143aedc9c432e813843a890e94c9bdaaea62a93a328f1dce20463888a905742e10df05e38f3214e1a6b9079f64654de9871337bb4b4457c7863a9997033986143bedefd9f202fd314877317a931994820f2e6b867fcbf5d8f362d6b77f4de9b8ba10cd0129e4fd15b02aba2bc4c753e7428a995930699c83f84f28fbe59be9ff8f5a875dc5a2f166a9f93a9cb42fd18f96460d70a1dcf7adcb4c9be27c0b86d34fbdc0af846ba83b3e085bd10299b4a3f1dd220e02899d07aaecb13cf9180404aaed7cf6a8c092becea856447c468000adaa820a2af6ca2affe4a65b4088e600c61c6622637dcd91efca914a43f5f7377f1beb78251e652ef5845c14fc7aa13e0d758a84b5bcc5cbf9f070162d504dd26dc84ef5f1390cf11880ede0ee0ce222c0a63956bb248157a83cdf5d81506eb6627c9ae7780ce4a381a4650113806a2deebfb56498768a44f94e2ababf2866094ac9b51a3a2e3d3bc4e1978af3041c6817e3130005cae541b82e5f60c76fd02b7887a796b4a8a44f2162c5ddc726be75d84aa53a67014075b288b4f8d71eff87e16ecc602a3e404a14ee90e88af96f7f400052f94b67dafaf2ef0deadfebc6f36767e845222cd4dcd8ad43c49957ddc3023a32c56cb7b07dcd6107cf6159f7cd70b6ad2235e9fce905f31ed8ec74af3af2c42dbb106471b74b8e2e9f5b8440c8b9dd69a836fc3d7f05c12b56f8ad687d08c138a9a7fd32c46b7e681545bc300f9fc04e29702462252da8e2a1b8f3820c38db0208f7eb0785cb1a6f5acf2cd61e63361923b7dcddaaf808650f3829264d910c18834f24f88c4ad4e30f64570eaa6beb9e82c6f5aa8610923cba29848cd6be7ebd0f1dc4abe58668347d08c12d036031e1750d98dd034c06b8781e2f30e0430abee6018eba66be6cd8d142b63cafd9da8b49a7b0e2aaa4938ee7202751902595a3c2943cac0404580d82dfe3cae83d7df1139ff13f27b8cc83deeb1073178233a7dd6bb6fb66378492810c3add4980af58a041192a9e489f6590597b370a17835cf7da126f22631e7a84955ed528efbbf704911f512b96c261a08da1f1f77a9b74435cc2627eb8b78cd32e3cdae7b2b9cb7cc4332592e2f6fcc37769eb335537d15f8484ba03467392b7f3c683f9951223b65f506fee7e035ee6c5df2877e9b25c018bca9ac668028e35225d220b818b3f4b5a48d21a8f4e82c29757634f6025ce69492f6c382cc75d831c08c669cc33aa9b463b9689342547d3e1eb2d1b7bf660c707f3369daef9cbbf2e3719979abd59406592618e30dbdfd842803de91e234ae25d18f86055d918519522698f4f3d4d7121ca52a6b9155daa5c39d92f9b6a8f047e80ab38118cc178e65a8215d47bcc3a71bff51fc8eb83dc304b43d27f0011d49e40e5cca19e24a5f91c2c5c8b462bcf60d381a0d1972ee72fc9265476e862735d3291608dd925172f8e68b3686f4e0a0d7eae44981f3a6e49d4e0cf489ec7e799e7f7f36be03276813115c74984e27e0f85cef5f0553ebf17f7587a5c12a39f1a36d88ec70da4d79f71a60bcfb8a4d40f5d1d8d0812b25e5b4f68e716625a32ec7fdd47bf9cbb2064fb822379408da5cb5b4685bdfc78d404f0bf2787710f4ee8c19d968570f0b3e6c7c3f014882d9e4cc8baad74ebfc0f877945ce2904323f2f77c371799334ca48fdd3ead9798831e115039cc7274c7705c658c4a9088a2cb5e27a81abcf8562a819d75675b4ea7469cee5f620f1c0d402bbd480a69b4cad26b858571e0fd6e758b1adb5c16a56a1b177f594b8ecdd4b6d269f0ac8e40a5a27133d0778b22cbf27f2cca8713e93c11bdb566e9e36c889fe2ccbae41bdd22aca96745d4a6ee2e31d720e5fc22f84409923c48c2e220c4a4df14ef393476bb1a2b9809cfbe378d6b036539b65a82c415e7619ce8b16e4b2940d90eb19fc2d687f661319d6ee51a26cc919aea01c7da93056975d0e83984608c2033b8a3f3df3edb5aa27b9ee1c67d18cf2045915be579d22aa3bbf2a87a43a0a3efa37c8241a18dfaf7b40f7a39450b0eb501170987fa03af2079e38161694118cb7d333771a225b9f1582d80a547274cb20bb6ec578a6bcf2e7e16c11f4f9c71e9119bf5391af9688e0a37024866137903491f7ec5d3ef86ecd3812924c461999ca03752008c90fc670a7c2a1d47824119dee03b99e05be74fdc0d69daafd83bdacd82c3aefba9261281d1babe8bc7472a56a3daabb0f17179296c7bcfd17e34de9b8e2fba2efada5a86057a2af033623c9bf3d6b94ef9dfe3eb9e359170e6bf5852af89818e8d6c8dde3dca3c01183939cb0a7ff45225619cd88e1cd87463763955ef6f0808cf5de2b09bcf1c44829b1c1889bebbbae911ad6dbad16e31de89ebaf3b5515eae07615344ed4f2c6f389f228f58ce04b73384ca78b56123ec20ce182ae893117d0973644ebfd343a27c3d20b0e68254586d3825c370585ea09c83db515b181bffc8299a99671b259f6bb1e52552ca81e59ee2076e71082dc7f236fec4b4c2e8d713c95cbb53a3725becbbfa2f50edd9cc3f86dcd9d646a4cba4db804bb6e14dc11610295e67990421b671c7dd378c4e54915147289daa62d17d1ee94ccd246adce64eed2a5b2cc745e79fc496c719a1d988e5e09448c72b8abd9fd0eb307a5b777ca8498e7a3ac9c629e320f85198d04cc0fd0c38272cf360f317bddb49189f6604dc682c86f15dfb7f5e0319c1a140363bea48a9bc1c1bddf8faba3049433cde93d83c67c7e6cf424621185f963669227e791e0d79992aa0bce36aa5918b301869721f60035c7f3bbd42fc49b3eb5d8b58387dd355db74eacacd207351a8e6ef65ea70f987ef8bb7829bb6c5e3fe7cec96ed42ba93cd1d504add77cfa1185266883474aee21de4c1ac50cadedbdeb3cd330a915455610d5a252a1a9e6d618953dbb50fe8afe0d82df8d5b9b6b6db55105710193aab71b6ae5a5a4cdb43e0adc7e4df747eaf6d48af82e279cc7c3d3b4338ba66f53cf28ce0799384608314d137c2d70bfae6414735d0bc4e5e1327b9913c14fd98fe058ccfec8e2e8fe2d03d0fcd6196f5bf4d0add4db90b58da124fbb56533ef51196df967bff7a1308096cce3079d7ca2202208b4bcfdeefa81678f6d4950fd9a968f8f69e00b961586ab61ec31446e8bcd6e830c34e911fa5bfe3820c7260ce2018bb42ac9ce4403b2256f0a873ca96b9a42d35fc48d3173a9865654ab51e9acdb8d63fdc049670ac4cf9c59733f3e3d26bb56e0234a8a1d5b203825bb5136b6258e49422f0b649406b1fd9cdbf801f3cf9e772eb3e7f77e406b0a3a5b4cfa5bd5eae87e690b77639c760f15d1dd1a079a9b371e92d0aeaf206bd012f412e6eb5e80150a33dd82fd2962d480f0276f90cc6582197c4ac35387e45191373b4bbb18758e6e06bbcaf6238533e847d3b6182663a1c1d55ae95514c0289e945a97566ad7f3322f2f8c5523f0300a334578fab0757fc2d0973589d1d5d879a63be819a4ec1435822bd74c6a7c98d91859b12613be54195959eba9c852dff012aadb91bed359c3d063cea6d1edefc5567b0ad1ed52892c9a2722d302ba992b914b4b577a340514749663a04c1cb161a428f5946141e85695b1e81fb580e08da6571616486e4520c4b229636298113b31712f24e8cdd01a325bf811266c5271791c98cf0f1c81ce3a28b2481678116179c647920759f123fa8b97adc18640d3271f1ce67f13a557bb548fdb4ca4231b94c1f83406846c42ed0089455fa04ef57d8de364ff2528df6cac54d9eef5859c9c361eb47eb9b6aff79632b40cd94567791339112d0418c8773281843a5ed897f09e6a6bd031eb156b5e34dcb769af79b5440225e6afa0b26b2e6b93fa4fcccf874879c5f9bd3a16c2c664cb6c0621dee112b10c4d647424fb9abae830de1a2040ceb07958b990b7f897caf0b7426adf752df95cf1b4c669027bbcb9126cef918749f053c5272801554e847fff4be57ab143bd4fc625a8b99c1d005615e052d789b10a4495549f0bd4f0e3629b6e2616b5ef8d4fee59bfdb30314fe913c95e8ca3f9bf2b10293cb10f20b00ade8c7992c8c783dab68c83458e7d35ece0b1c49947129c1475799d7408a3b84098bb73bc75faf22596491564c22f055e1cf70821535464a7e29953dadfebca978dcfac63d6e702f8f81a81aa4242ae1c731a9707e07e415113bf34b60b2a1cbb246a77fc9ad844f200082c1e5de2096c5cd9ddb773d6bbcaa18d9e631d0bd2603d7f87005fec83216560637d3dab75dbbebe1308f7347d894a4598b415ce2164a259a8fac8e74e6a1f718ef8a079a335366cde5030fc768a030b2966f63f9ef1939dc7b9cd46e767feec254551a93674a1fbf4b48a3f65a5849270f63cdecaa4650080938d500b9293e2f36c38673620d8898da73fde62ceeb080846d2f309b10bd8b36136beb88eb911f75602dd4a6b99f3605902bef6b832ce8460160bc4e024b56499a21eb75fce08ef767c8f3e24d027c87767c73c725095bdd6e2ba5798b01d72c2198ab7789ad453edc34aa45d256f5faf6f615b8cb50a50dd15cdfc36d078c6bca50ceffeb75e12e1b17d3c3e6ade60aedc06c469a30d89e00b484d9dadd191275035ca51c45a182d8ee6fe224bf611467017927eb7e895d2abd0c2db3bd2c97da887c08309fa2b5839c974014aa52b19d5f851eb1b8c642d11300a85ccb85ce0f5f426c5f4f75e0e0b75d0e8114eea236b348909d9777b3819cd5b388921bb75fb01c1f5fd9b1766bed9a321d2f888e91edbdf3f1412a9db6cba41666cb8bc8cfd147f1584a68a0a4fffb696147f09ab2ebd86943ffd3a987e1aac64562be18cab9b849fb2aa5feb560d0d945b3c5f8b18eeb506f08d16afaba1c8f59a840cfb894c064c83ff479e9d72e6c2405cf9b0edcee8134903813ab80101f29f30ef90aa1ccea2a6f0fe9761f80f28a02c74e9d3502a56c1a4fb8b76a01b77e46150d146c8074912112642812c9e8c695563b065540aace7eb48050fdc5d45bb8902d7498b09a7ae14db8bc1464484152bf8b4d1fdcda28e0003111d38173d95e41bdc3aa7227d94005c19b75dd305a39f4374f41b0d0017d0f3292a67d3d1ab4a805d433094bafccdf9bda46b070d6e1cc6ffb2cb0ef1f6598231d92c0cde552b2189ca1f82305f7a19b8817fbc8f373db4fb6d9df7e7e3e0545566668edc02ef30bf1e956443d9edc4e177ac038724ea9d8d0376a5469f0d13be28012c5676f36b5dacbb1994f721fae7cf71f2036c3c1bb0beb1495c491a713a472e3f09b1c36a9385871214b8431d50e2d63b522cc3ebd8a62b730daa8d68b32bfbadb056951392d91255e6b883e82518f44ab6062d2ac4bc44103b383f5d7b13574a1e64d5ad95eca2f3de8a0355a37b374d84e4b4067c0abb1e8adaf696b89be11f9dc47ebee69835e852fd225048a8dbf101149bd58a657b368df276ab6de99764dc0df6817a1ded956e07fa54f4489996f37e69c9ca876a8671e6a55d1e4271ede86acfb3dcf45700946a706b220eb1dcc988b39ac7a770d04068614e87ae0f81057ea7118c2093fde7a788a3bad3c131ea77652de0276f4edd227e6be9ace01dc91c25edd8c9fe8ecd4aa6070017aadc2c2dc96edac41104bee5265245a25a8c75f422ced220ee6d0b03ebfbde12d150979f2b6ae2609440c00479cf87e4c2495ea33eb8e829d16d5c53fbd2b3635661b057fca00d0b020a4bda01855a7e439a3a18f435ab0c3c8c0c74ad24e44601dc3fab624328b2434b056fbd8e2f73113e001f74fc6e52a0017f33739caec3ef5ee27574aeefd0d3696897c5cd26e8f5d45f0af8760c76ee8e5c0c743108733a7653fbe1e080ab4ade5f438fb75f017ecdaa6816227e7af00560729831f6447a7d55a52d991c478015f60f816393cf8d3ece0a7ca38c207531c403b2106880beb8d7e5f6a01758a62a50c2095db10d622ba378cf392e61d002791b06d346bafa2d9fa21ae8db9ceb75641734b4d719f25f0f8ee4edb90b8263b11bff458067e10dd7c99020f30254b4f70a27f66cf7cd78e178636e8f5c7a443b4b1f503ec3c6b2b87f380b761c232e75cfff61111f3e36cf0a1ffef09de3e0bc125bc22d04466a5a859b3f9ad5e189b0429b21b8e3d398c426516a8ae123591cc824564e8cd0f695f1c21c8610970854e5c89ea9d9ab19ab0bf61c5b1824b48a81ee595136dacc55c6555bc9f6dcab1c632fc6a6acaf81b926fcc4c07c544140e129ff43c9e185bbe31d5032667a5b3dcb56f8f08b09b6831dd81e7cfd6f7907819df18c1e99adc2821438cdc7cbe8d55099d8415a6159505766a33cdf34fe266c11f7e92210f419742f010e4a674fa451c54211d3b2fd5f602d2b3507b470fbf1ae65dd0cbdc580502778ec53311552504782d17a74d741b94e088f73ca7668b29851cb753477bd8a501c88194d7985aed2f535e37fc7eb7e72ecaabea4253dd9d6b6e7bec067f37901ef2217130aead9f49f7a900a1ac2e761453c51ff35b97e78e1494e0f8ffc76bf8a2cc37d36815986a706524e954e007d3a55c724a45a3cfdc997021bb9252ca94c42ad40c1af580a4a11058372af1712976dd80b398c770d57196d93020f26a34e71ebcb6a2e9630473a37ed6a4f5bd341ad2faa8ce0e47ca6883e276fd367e4ea4ae3c3d258e715f2ef582c8763823ab7fe172a416bad9bc5ef2b3150608664eec14364d26b0161cd7d6af9b06085e27ff748fad97e5d77b463ffcf1f88b9dcd23855f75fe2222dd93f323d4415b796f0936117877677ea837becce7a183612b25e8623ade27e057d52625d7ede30b5aa22d95fe494e20d8d1e20ef4febc7a70154c1ca878028598d1caa15addb11852361ff8f15758c40421b858ae09074b396b4f4f83e195858afeacdffbec1b293f289d2bf826443b80fcfebb73802464c2317cea0d45a7432a549335583d3cbc65321a64f0a9bf2ad6420947baa1f0a9ac173b6c57875bb7330ea13bd723957af97cf48d4ef1da3247b5e4d84e4510fa2985085716ca4c63a2224eca6832ec100cc3bbc605e86b5b6eefd7f542aa7e74d131ffb7472970eb4df686dcbd3cd08471f85f09b2ae168ca20bf872f2dc3c7ef17a9ee4ab07c56a35422b8e454a44a2a0c8b7b26f45b90d11bcfc6cf2cc7df2d771c9649953dfa0eeb2c2621a55ee096bf3c1993f2d6f6205e19b8ded667f6e5a1f865a6db18c86b278194137bad479038b58446c56e988ff24161f39185388a68e4bd63eeb0aed973c5540ce5dff1bb0328f0844605b5952657734e04f02a582449abde2a2406482769c9b2716cbc7ece9cb8346d083207a7ac2fe81bf47c07af602f7d32060585c924630e5eb3e7d5bb00cd0fef97286fa7e4ae2856edab43bfc2a9ff327ecc9afae2d1118c35da8623f10da21c34d40dc92b9195178ecedc2963982cd19552818452aab583db73ff19e5772c82e0c3eafd88c46148012bf0b9a6398f4f4bc813a7415407130e44ef53f78afc344cb5edd9ea15285079a2d2ce5d6c9c52ad8f917e284ffc663ce8f4a00882464e8221a528cd9d934a1c8787a258a5ab47f1cc0aad4ddac47d5d159be6e16281282bd5a41466a6ca8edabfe0f5cb21205f87e49ec18b5ee69a913a797bc39d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"643649ba80ed23fdeeac84c02c742703"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
