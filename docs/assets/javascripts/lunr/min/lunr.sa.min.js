<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d2407a690752812e7b01614ad9ece74334896e8d9695c2cea0b71adedf27619f5096842bdd1081c3287d4d3f766778473d83a5c1eccef94df6554ebbb8a9a6b1dcfaed33bef675ab665b13e4d00322e30468563e56f41b83b2a9f6cf34e42f87cb1dbfa32778943bc9f0dcc1ecbc03f8cdd9be9db4413fbcc1b8ca0ad83bc95d3a97524161d943fc8e84bdb2d11ed8f91bf15df085957e7702c9727ea228e0fec37c3b61961e52cb199c0e123f48ef94162ee826c28adbdd38e6c044e0d64c91692f27d37d6a2845b3f6895f1aa2dcdd4ee277ebb0c924b2168217f09f22d154b1dd6f035e5445c86336456006f913e754a4e5d4b39431607f4ab505d4aecef4a66726e5627ba065c153a3a34676e8597620fa5d93f83bc02a72ebfae1329f7357bd3bf4ad140a7204f7dee3a8953b728087f989881c2ef369790943d1dc6a3525eed3e2982ceacda022258538adf5a1a33fc369b9dd14f29f2bde26d093aef2a496a0621893542d22cda5ecdd0c9029acf92119028ece3481d1eba6df52d42812e885290bee0c913a5e76d4c0848f5fd271957c1ffd56f53fca0b948aef4a6ce9426e9a77c4a03dcb431d1da2d6d9b5409422cb348c2a4eb5da061fa7bce32a5ac75e5ee51e009076d413ac47964d1aa2882b704db72a2a0e943148e6ff56c1ae7b408828ab6dd01d7676823f04c3e5b77e8fd6f5414c63fe916ba0e99543ad6c1a6128d2d86d02716c4c81e2dd2eae71df0b5c17ceafabd0c008a19cc297582607e3e40aac271953b2658e173e3f76cf347505621ff748f0d91f0739bfde61977c9848454030e15fab0346ddb2ab2452b154516b0333ddf4d51eebd366f4d8f08b09cdcbab6c38776627d6a6761b25acefcf12babd4ea2e3c3d50a53ec77e87aa1c47e5ab74ad36d09b20269ec8a389a831d0c91e7ea7cead85e08325cffd56928290714ee78519af94af0ed7f36cceb0c5dc214a3dd6b44cdb792a9e3dfaafd093c346368ad3971cf1c4b8fb2b1f7474c3e2444caadc5c290759d1bb006cd962e4d52fefc0820aaba905897a5db4cf5ade58b650205abdf5dd0c4d86264d312dc748c17f61dae5c0cd6947fe5df10fe8857ce4ceab4e03536e447afeb6b55831c580c65043a7498446848a05ac7fec42fc098ff17fb87400bec529d8efa4f0d1267e918013edda925c9d8fa77ee438ba65483d8e419a6e81a0a231bb543bf2ae0fd1cd3ed46c60092988245e77558b6b7a9425c020d11a353b6c423c181812397dccff60201938da7cec7b063ddf17303fe9e0ec52684f1115042b0a8814fb29654ea479b2211babae4a73f1c49d5f7f309b2ac6e9318fc00c3df9111f35017084f63397c736cd57dc52d3313ec9383dd636af42668ef715510f377eba56349fd95bdd678d36b1c496f1c5262bdfecb245968042acfcd5647dcf2cc3d3cd2d0be90aa618a4103abdccfa4ae99a13baa771c977e42eac4479e4ce59f24a8bb02fe9c07bb8e4f5e491a90809f628977b5b6a24123ab268799ea92c0070f344fe97037877d8cdb89368a626ea8b112a088541727a8c39f5badb3174f4d368122b1706bba5188d568d2408643604059eafe35270191a9fe359d7bbb818e8091fbe393be1ecc0c7044a08139fb0b7be4795c817e2fec0dd41d2b9763b60038093af5224cdd72eeeb0bd5b8be55339c9564e86fdb0c1b882d616a7a717aa290e5a39258e1dcc178c67a534d43f78e0a5f2fd5e9be37b1c87f0a236d9802003c557a1324f7e39fe16cf9c4d3cc05a15bbfa7d329ed247fb2463001923d88fba2aeb18476314adeb25084f6af225cc295f18be1827287460321a7c0d7b13377139c67e784456df2566c00827574bf8c1cd4384f96109aea50475e3b301396aa3d0874ee2cb5a960f3e627707abce5e9424692f1700fb2c8e0e60e54f15848fb9fb801c92dcb7bc86f1559e4357eb5f32b6d436d62adf4cd0dbef029175f1b15df62f63a57ade2ebe4a2915c6faaab0a64229c155b42f948e84619f6b00e2e767713b28f79bf71074e6ecd9ef62d07f61c6ea536046b5d94a91482136887e6b5cb1904247201d8c5c345776c7376311f6e79d7ebaf87e550de7cf7af0c0786625da45067e351936e7790bb3360ee0ad418f4a8e6392ce39306169d504c44ba548b904c597b988b5f2dcd595692899fcaa4934eb8be58e5b08ad0553b89d91818411049d1ae2c17c7ddc758e7d72d2095595c96351fb17fc14409dfc9110c4c4aa92ee4c1c1b2e2000e869f9ee22c274a91e4f29eb8ad2acd36a87e21ec327ecb2b075a8d1349c498983d924489f89329dd38d369bb05b6e0ad20a70918e11f2fb780a41d47ed451154a74c6b7baa8fe391307a6bdc3e0297e2aa027455dba82381c4e1aaed5f673f2f88d09eca6a1ed634824e14799651f41c8aa56373109076207a3e7662d2111c34fb44c3cc3c4f741287e88fb6beaedc1f7d071cc4c2e13f15b11e46bc150849e0ed187f530099727bc70088664a4f5dc62ffee3a9c95ad9efde5ee2d828538de078f7043a83423b6224a5aaf5b45dbf2af2d58e8ab0c36ecb8642adb8218fdcbd29b90ee6f5a22d6f23c8ca337cbd133c04f0710dfe3add42938ca89d5d8da04903df6e433c8764830c1fd0bc390118cc98e9a23089dd2b464a511e96ae7555b4c52ffc82bc279056eb0fc676feff1cb4ec5e40770ea8fc5c5a98545e4d7237762dcc446f94f0f841cd70c8909c7781dc9dda7f5876802541b0723245dcbbe46685d1fa1fde3f5765f1e6280af4cc2a13b18bc409cb3d76ecc79cff6af9fcf468aa1a1e7c03cf4d8c5e895767b8eca9a4495863629c8666778a3e7da96ab8e42a3b5db629cea681bdfec1f0ad66ba0bf5a9c362a6f8c144c495d833a351b1beb9b349b1e195141f11bc824c78ccba417e0650644b2cbcebd572573942127bbdd1ed20917044d4f59ac8ef07e6c1ad23d5f298dd0e37bf166b8051e5658db016a0adf760aa2c770eb929194919502f828f3b91384fff976713ecb95de0b920dd0b4e5c139892f057aa385de52bb34b3221908c9d2d5a2dbd28710eb9edb789738196b7761cf7b66da6da9cb948e4b6757de7d65d978dac4b0595b3fa34e1ee9c3e56617feb476d2c34a5c54883c59103f3d75caa1ff173b9d614ccd9373e917b2423f5d1c92773bedbaebf067493004326d3e9434d3e82a2acd314cccb3446678a1bdf6f2046f3a2674ec4c913cec796b720a5c8ccfbe04db9a1c0a43b0c962bebf34ea40cd9053e94c14f41b3b20b11ae09a10a65d43623fe1e50724728e4c72908ea403365b2532491c097d47feee47f5442956082a52767d6138b055bd92eab8e0140d05e8079040a8fa0ce5a738be5b7443c04bfdf72e3e8ec6a5393c6a4ed62d1378783f1d560d3859fbaf9a2bc4d5c52f0a526f036c6e732ccee804f7b1b7f435d83172b27e2c4ea0965fd9ddaddafbfd3a507c0f5e6b069e75e944fca7d72542081417c5198a9f60672744bd6b60150a5b4f188e1fa2c22c3b3a1d6a5adee9503d628c7f2b6badc6c3493fdcdd4a21b58619e7984939e509f23de158620145ceb0367629e3ca383c0739fccff0a5f2ef851f42d27f0b5e1cb4751d6e708aad3f0a789b570586c7e17b3ad73ade9aa0c62c4481d545248eadb2c6befd16282c47601d9bbbc6da771dda517b5d3f2c2ad1fe8aa6f69d2685e5b54ca9432cab7ef48306c20466b0c554e5b2dcabb7844cb21413a6adafc5a99c9100ffdf0be06b86fc81c6e56cfd13e5d7ebf3f0530d038b92e8df0feaf8fe594080523530bc6b80235941d991a8d55cc9e5acb689f17457f9dccf7400981ae3ee692ffd26e7c20b7e50ce4ebc556bc0b79b0f60fb76d920cb9788f2e11d3feed64031b614f37f37fbd4e38bb86fa06413ccaad3754e3242aa8655ee588418f40a78c9757dceae0dc4b6e10c656ef68df924805087e79d14d6b17b9300147390b0980d38f060f15750a14abfcb21f688bb166af2c11c7d97ca7cc2cef93c7c950fce8f877447296990f64cc6af4e181ff39c41d5fc831460ce5d019b68f2c9c51f903a713f8b95e1c0373e809ac62fbb91fa721aa50c133a750da376db20b279caf003ab735effd13dfb62c882816ec0e1c890dbf5a7ea4ad32cabaee7e8467af70b355b8de49a2fd53b549123d2bbc2fdce314f74f6cefd958fba262235f910e8815af1b0739a27f473a9eb0e35e2f7c7f614061d6f0dab73bba79b9f1d32b4f408845b078e9d86594477793a35cf6da4a8a4ceb25b445b57ea9d5bd9c526ac3c4df8587027f33006baff916dc1b84065e25e411299d9c09ba506c6baf05d3b00bd0d3400849319d05c9198039ad4cf1adcb0df2e4d1c94317c14ff3405c41d90928be15dcef1d737b7ba5153d6b10bed6b6f937ca75e0ff840630dada88cfc0648229130fda180c086f5a29a5f8e7c3897ac467d4f092e8c35ee7eb0bba65b50248e9bd5a5df2933876dd47577d9ff42f810887f03ec15d3a38c49396f358ec698d8cc653a3b93795fe4c3addcdc53f5c36b492a5ac49eb6e25f3fce895ab385e3064fe63390b92f210568b4ba172d21b94f2aafe93fdba5eb576a4f168bffbaefdfcae93927d373c3ca78953ba9947b5759cbe6a58b476e7a0db45755ebea336748e8d76e3d4518d9fab343f527ecac9fbeb2357094ad37e57146c38c277c770a7cac0b348fa95723a3fa56d739e163694073d3316a691e7d9e5ba7610e3e640496f110102341cedfb737d8fd264518b6a9f7fe9092d3f47d72d5d04dd44fb759f202ed2d3bdf36fb29da675bb7b5067f3c3a2ab023598d5c64e641d72bec98d7c61765fac650e6bc43996a571ab37a27eb35b9d942d662e65059106a73886fd738aaaaf895134af154caef81bdb016c554b5792d4ce99005685ed9a1146b6f34c7ab89bc54ed5dfe37fe7907f4a6e0f40bd6ebd67d249ed772a2028e8ec7d8c1792953c3122f1e16ec18761d18639244b7632763ab71442f8341ea1e1850f91e3494bfc861aeea8e65e4a04f3c9c9fc760185e3a3f66a582ff7644e45364705d1672dc2f41f4d8f6dffd87d4fd68937dbf8c3396401fff67840e620a40d7b9a4ca99ae64f0ccfb6809961863c8be9360cb1264181197d9621b411f86583140101e31a976b0c4a80b946222b890fcc4ff9031378057e92c1a82561abf1f0cf92386ed11d3ccf9eddd5e0c43cb99a63bc30ea908d0fe46dd456c0739fc7056a7c0ab0245f9588fdd267afb47bc22f4aed0f6c9b349b753b3a532225b4e9011ae08dc28ccf47d10e603b06a18e71994ed806e49a89a1908ac3c6b4e9c6e9de9649598095f4c73a4bd976b14ac28e7225ed1e143360a4e0c604dbb58379faf56c4c086b8976737e005db479bdd0dfc43e40658e25295b33a0736e2c0d531bd6b6907244f30bcc5f51209a865283cb1583ebe345097f1df66e1c0e5b21eba85e5350d374e5abdad7821af4e64515ee219ebaf068944ce3e9cc2370782dfaa28903a83d888664d5dbd377bec180e7ba9c21211d537cd0637a5678dfc650d9d363d91dbe64a6a8693b52c9f96939b8db2ce05ffe8f8747378e34b9b1261ad6855eadd523b18cf7f6a61747c509369315ce2ccebb9929ec81a5bb8c7627e39ea1f3a95b0f438819c1d6b58294c2095e206201ae29bf3095c35dc0244b950c4427379681421d90c7700e092ed87ec32310495f1b84b5db5f2fe9d935d06f2496fff9522eccb30258b787472a7d158f6f8514ea5666963bf4a59afaa610a75cf783180469b85fb6cb1de75ed7cce1fcb1733dad63746ef7a263a34ade90afef402981424a15018874aad59e0f85d718f7a0b45e8f401a7c2a1dc27979255af41ec25c9ff7fa4fa89fa7b5a34157e84b846e771b9b5bdd80bb80d6a5bd59c17e126a031509c3e9d5461da6afb73bd5878ed3fe2959ed11d4d48387c74cacd4fc461ad8b9b85c565879a7e308f42db9a11fefd4b1f094d258699ffeb7358556f6bc97383c5cb8fd4a2260128e6c4a282ebce365232fdd283f19ccf10e1c80c08c53a02e6a46ca7f9b95b2091526984df90bd1ef667014e5eca08184331d0c6924542929702e8915b80b80202a5f76956cbb3acd990c50ff2c9541e6834d3ba6e18228819256814f2ff769deefa1b766c9f8403353a155657f4f337c316e7be80f7cdeffddf18f6f80162d736dd461f781b7b79cc1aecb67819a1b989803f5c246ce41e8a1d8105c3a7f6d93bc2d1ee4289f32cf21927d65e98c79f592cc1aa95b070e7d047e11e3d58bef2b31d60bea63dd8373ac30700f2d55630cd9edefdc7bab3f0adbc2fce10b4dcf8e3a100c56f3192d30ad0cded938e57a9eebf4b2037b501021471c8e9d773c898135cdf930354dfe6c825ddf5f72a46ea70d4959112ec461fa5f07f68e0bea300f23792b6f876415f8641e29401aef77f7f684f58c600b2b9a25829019da09fafcc3a91cf32f11b63bda8294950cfedad6681b9cfa2d86294d9e173e77272f68b36fc167dfdb69d10c2a23a57a2ed13550ad4f4103bd794b422e49e8b5d452f1af5ea38499d8587c6140f6edae5517181c9267d20b298d965610d380eb4ecdc2920f3c51782529c022cef4026f5a195a22538e34a47caeef558e5e62462ac7a653b71806ed0384c90b2a8cfb88c6d3a555cf1ccc1e6589cf254ea56b880fdfc8a52d9cc4aaab5095fb122ea54f2da5744a2c46141c29e555b3bf3ccfbbf1530ca5adf28d1d54cf513ffdd5ce93022d62e6e43339b925611a35a89a01b178a80437b67b1ae0742937991a646685b8cb793e5cc778f93d32cf71017d6630554f4037e6cb362770c796c180d326ea1b608b39a7c2de5c0b8ddfceedf5fc722c2f740ae5ed8d04ee80fcd5a37f84b88c0b0a854a5f6a9907936908a8c8127fdb531b5dbec0bf73aba8e39ed262a6f962dd7f1b8c185639eb7a1a5d7c5eb0569efb9e8ef4b6b0410eabfeaeeba63b18e3e6d7c9d3e41f9b0366f344","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"643649ba80ed23fdeeac84c02c742703"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
