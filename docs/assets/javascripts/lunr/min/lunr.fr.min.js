<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2115073ec6611be899c6c0b5cf82cedaa5a89e23a68ad30b93232d17b27f1590308ee7d1e591257a211044e5e93f8d1703235f0d2a393ceed8c81266d2e40a6ee3e3797e3178b8d7cdc16e3af72bc5a7ea5108ad383657aef3de80204dbc8e26ea654767ad3cd68c55417c0c9fe8271408fc8f811bf5df1836e55f844cec5cb7770f82603f82f837cbd1980001c082b224db6bb9a4b84e68ce35720dc5e0216cba2aec0ba1533203c581b3aad4b51306c67a7915a4890afd0ba75f465db141ab21769913573c0076fecf8535c077e35ff3a30ced96cbfee356d33a2afcbfee57a31191bf2f105397e329d8945fbb1c5995e9b66fc5ef28d3985c448634dbaf82ec57cd02a937c274bd163c704206782ae29f2a02bff748e80582f61b25ca3edc6bc7c8b8c903b654bbbcc92fc1467dc356dd7de0328c757fe1503575ee1c7ea619596b1d72478b7384e1b3b89d71fc3d40ea064a2ef93bc35bb1b6f274bc4f12f1d44ca010dffde22ac1a0c3fe37d3fb4b534f1529a204492b3a75519eeea0bf2df651dc9bf3daf9c84f8e7e24de3da7e769dc29ab602a45aa09fb4b601618fd04b7716f25ba1cb00277edb13f8bd24363b80c80817fe4300fe910cf037e115f264e1ab0f1f877d8af9b34461876fa1f7c794770d27f56a453e691000f435258866153012b6fc0a7cf809a4efcdcc525b5000b7163faf6e7ffb178392887cc274b13fd1aa64b9da0feff952d78d6a4d41aa12336709240a6af5b6633fb2ebc666cb986ef207fff3e316725fb4dd54aa0823525d0b3f815048cca77631432c75b4e3094f29c2a87f2964283290b77ef7c50e89305fe71dd1f61ba2cc3185af0a8e440a93a0da5c1b572d26e5528b81b9fa50cc88e904c287749e11534baa7fd37fbf3179089eb3a9af46995763500686f5b19652b3056344a4ab0bfe151a5f7c53ef19787c57930a0e165f76f0733e3c0455bb94a6a68adeff53b7efb0955d1f9fbb8ab9b672a0f3a0ac7e2e00e2abedf6533d40b78aed29e7914731a98225f74d47020d28a74ee4274d8283c51ab7bd095cfaefbabd26f4899b1732b44b484a04864fb61d4d92cf55b01c876135e33d3d7a79208ede79177a0397b91ac63e22bc24d0813d73f66bc20dcd2dc22b1d0f7d24bd104821da9cf361b0dc768fc44f11fe5e9380a1a4e9723d621bf1b404ffd89186451e1d9727770b697dc762875991bc8cdd5c0870588a098f73eff04ba43fed31090ed9b8712a06b279ec4a5180efc80855d58392f123397be3854ab80b3680f8177680b76b252f83eae10e2c1b35bfeed01c18893bb0dd4b159ccbfbb4689f425776f489176c4047057c4dbf669aa0ad969855ee0275897ccc0b4651291128c2e97f9ff6e0e93b7bdb728b1d84dac2720c698216b72eab872d83f2f6b548992e54604f541dc6c71bc8cb883762084acc362ffb22b93b0b69c45f7f128140cf94e59f8f308515744ece91fff91ad97ea39ecd27ca0db7f09a4fd0913c52e85db6591fed27656a73c31f835871f35ba55d7c4320db9f1cd27c2703c5739adfac31c644ca124718a95a07f5abdd869919916ebeef1bddedeaa4552321adfd6e678e04c5929b5263706c6eb8d425bdebd9b425a955d5aff3e9970d6658f2eaa89725ffd2b593da4e7ae3e08bae304c225d55dadb3bea30ae9e45707ff66bc23703fcfbbb0802c832465d2c1ec28491709636e9ff32a6a9147dbb27cf3bfd75f382f5d2685363f1783cea2cdc9fac2175610a894268e2450f57e6e9d1703c9d9e0a1863642249965c5048a7a256ac7bbbb9800628184656eaf5fd4da8ddd0ae4c72b5732071c54b0e3e21f57ff572c7daf8ea1e6e153549bedd70c646e6d4a71f2f59971cea02857c82e7bdaf5e9dfedbe302477bcfbe741f12893a168e69ad634697056f28863aea7bcc521a44918180c0596a116aa664004b51b1214ef8ec3e678647f1cfb77324248d2a8cf4d45cb87856c27d5831bd11ee28f2c80af883a91d227b0bfa7b0b8969ec5232fa99c23132583a600486172eb161a37dcd729a01a359d8369f9d5451432a0d7f384981e681e32a568623c77a8668ebb8941c40996361819a6a0406b3b36217bed55f6fa9c58200b75da360d1205dbfcdd56eb6087157a662547d6f77974a8128c5e9aae69ad7d149c514b6747a6885dfb6a7cce714ddabd20241ae43a5440cf8d0ca2e9c9819562b622143a7e1351b0e1046ab6c833b337c09094862541d813f931ab03d9934fb63ed6bd41bd32cd2da17eb9e871d5cda235b4e3071042a29dfd5a5192f52980e70342d349724a026ca20e274dd07b5930723029245ce576c7de6145078c967c3f15a87ef8f8a53f45cab14a18cfd8889ec804cf48c0632a6c78e29fa11ac82edee3bb9c0614946834f882043b272089e16c1e3bbd543ebb718eaba288d95c4f3c33ba106cd596006ac14fb89dcfb62a1f95bf1ebc11f5e057584cda82e97fe60498319f352e3a75addf1537da4d4691ea61a9fadab6623840742cb47629cd4ec97b9282e76317268c17f451c3303bf2183568650e0dfe17404847378d209036ea3168ae1942c9273aab8d1c6eb347240d1dc61ba5351be9f3707908a5d7cc3f9a5bd9e93473283cee15cf8f82ca8045f37e0211e4093d1b000b86b6c539a2db2dbef7802b1656b9f389014e108bc7eaac53bf07eae948845e9350adcd37fb35815b786e1c8c66601748070564d7397a8e892580a9eba3f0d31fc89b0c5396d89b14fd56d97a83d998fa901ded5cec60b95332e60b3e9f24fc149806cb777a1d6bb9b950e3972f0b703a3605c9eba2719337612e3a91022983b563ee41cea08053d402e2331a2979ff211e78f9555fd2b7b02a21564ce6808553cc68d51f9bf5d66733e7c301730caf5ef91a18ec3d45db4af03f82727e909de7e9c51197a0d4544b7b1406a3d5f52bdf226ab6f8d7f3c310232de24fc82e36b558417cdaed6f296f1668cf44cb380fb83abe7221a04419f77152c6e6df1e14d01e089e3355a2292475a8a414a75cd309ebbe28f9ed8ca5997a0e219888e684c12cfcf945c2f683f4d8e190abb6d45c170c34e221067758d404f690a8c76fc09829bdf28ac4f52a80aa578f71aa4e5481dedeb41ad6d203938d3467c4521180941ef582f33f85ec029f2c333777e5e52fd666ba86c6283db5deae2bfaa005bee4509a67ef15cca57662d3dae2bd5806bd36ca903ece01379be179f8d76ffa1799ebab729517d24b948f090d1e32d905f79d77e2f982f35533f8a65a5d12df6e94e504eb517ce7703b1ca92c443b5325b58a1aa9144c367c9b5d4cab6dbee625a7cdc86585640aea06cb5115dd64e3860da943b12f14650d147c542b17f2f62350558d8ff5630532c00236a3f818f0561ffb4a45ced8e3040ff0c197f0e11205a0dd89ef2228d6c57302226968c7c70a9c6668bc319ad9ad06bfb290da1b9ecfffe463e24f45d0700ae4805244682eb7d8dd4838742467ee79360b633a171118b8c5ad06d493477e3b00e4a0ce5678a5ed832f4e5e098baf3fa34e7ab2373874e63a32b12a6d21a1c9527dfcf116375e6cb8b2ce40fa1aef42c4b786b204b218cd698accb0d49ec276057473fb3d742498ca93c60a219a279cfcd600e91a61558f0dc9f44933ea18a3f3db0be764106aa11e77f009bdc7504a55b67d7ff6ff09544fff94c785d702acc74ee783889e5628798b015fd8ebd4b45e544de48046f40ef71e20f7dd19e4a8d0f92a02a6731391aefe81d2861becf7ff112fa3fe0083033863d15171f527bdc562ddc4a4889a5750b4b3adc3902ee9411b981c69eed3fd3e6a8e382db120603dc5f3c1b3a9fdfaa14440cc7435fb195d58fd6c3bc831ac2e70ce08caa33ae3f37eaf2286152d84aa32e24f65c5688987c5dc8ac6a436aa9263e4b4d68176065c461f26755ccbc6b088cd81e18609a576a6b01f3567c1f4a0c311db4af04fef33cfcfeb439feff92f45421920a50d24dd96f012cf3d042c898ae7147a1da1128f5fbcee856bb068ca751e25d402fc46bcb244c55a7c851cdd6f8389776c3e8e2f2297f26a879ae0048827e14977add4b372e11c64932f783c3c7235fc93389c2903ebe1125d645731731d48b31a0edcbc14b758ae4f58c1842bdffb12cf55c7ff90c5aac6bf2c1657b7150042e54c7a58010703f1327a71d7bc228238a6321ae13ff1834ac89b7290c8c131b4d37359411fa66aa1634644b539ea88e84ef3d3a22da5eeb6386c560f21bcecf46d37ac134d98973da493352f84856824807f85181ce38c96ec471a95a20617c8b51b00929e7136a718742428fe955337d5bd866d99a310da7ea1cc9825bdec421cd6c4d0c40c4dce05d51370b0c28e13fd9cac030bdf648924e95b0acc941a7d9581e36600ba3a299c603a413c5ab0a63ff6d0d5a224e491caad456ab34212594348216594f56ad169c1d2a0256ab008e2eae23dfcfe49575211592e4658032860948feb2db2131979e8c96500479849e66067d300b2e64c1a5945baa21174ea5d2a72dfece002ea6b9d777d9798f342a90745dc44adf86f0e6a94192ef5e74151b75a65e738def0ff086e91409ae9a359906ffb83875c105932e51ca9c2086163ae943db26a62de18d3aebfc1fada4e705e171fe65db17f4fcf43b3a374061b08ca4f00c0ebd547c1b73abbff36ed4c31becb5b38aefa4c0d538a85058a0136f388c29401724b4b3c963bfd61fb9ea52869118c19eda0c97711f566472bc880c819fd1f70e3ddd733f1a46e76695860c1f9c6e9442fa8c7682ffde6a31b3817f9869cc5cf96a27fedd364cbe250ad655be86f4cc3a1a992eda7a3959a65e706faf6844cb23f519f1a43325cd21cd6e69f231e421196350bd465dfc1e3afadd843598f2471c4b4fb9abb6f8012d8348101da839326c2d287fd465f18007bd0d461ea935a05b48873082c02b14ce3a418572559029ba20d0b9c7b533e840e7a9fc4e431aabcc552c99c13c98bea099dbbad4636d9e95c17e506ceda429112c8eb9a0b4591d40e1c36a1f481ca13beb48ba10cd6db6a372f0115e19b04448d50ec48e5bd741ed6cb6f03d7fc428c63c268f50a41941b0bd7fb87c796dd85a5447c334bcbced90812365c2e511bd8e1e27d03fae95631e06fdc87132fae86f3b58b5216321f98d79ce9829d2fd48b760709099cd38989a1ac423c3031eca6debb42a99d36bf7f19b797c683c6006344dd63b8e6899499c128d0106306aee35c3b16d8f131eb9725cf84cf22238c66ca2985ad86317619391846572d14bdb0fa171a09ca3583d7050ca864b0c1cfa4609e0088f80a181172ca762021b3791259fde714e8d87cb9596f0976ed6bc631f6c7bcfd6907a5f06570bebf8d553a8c953bfe75bc88b324511b0ab13fb994cef12cc1acd902f2473927ec21557cc886fd7ba922470929d9897fd5e2799f98e242206f08a29373c308b266698e6c844ae662562afcabf1abcfae7193e144ff5ff5309498798ee2b7f8257f6ad18d9a2ae54e5389bba715d975a3bedf247386876a5f6b35d6e9cc3607555409fa5eb853a4d8fa1f253a05337427decac89c8dfc39c083109fe2bb98f14425f1ef5cff10b71befad17e73616105b39f2f25d4756b45a9a4a31a2cd2f221ad71da4466ad4d4add8875e0d3f6260b0caa5ef2542efbd6e00b5836e6a28c1f9f73b51811af36b0156120a721e7e520060cb470f801169353ed331022e6e6b2845b8ff16768448a209e456c804b6d03ee588f9355e5287b31d3aecd046d6449e1fc1c2aaf748d17a70e1adb7edb70e132441ce0176f32c2bc64c5e977837eb555141144967fd4777bc77560f5be6f30a3faab0e363b9deb15caf4fabe606f64c65bb7746112e958060957d17a2e6f67d9775a2af1d8dc5419f1e78b83ee5c1577a68440da761a16853afc1f45848918c39eb10d8e31d8943c2178b7f1dd3b4b8e844bd3715aef38cbfe88c5940cd153928704deb0b011b23ac9aedc610c15757cad31ae4100fdee9732c2be42a966f3797a5429725d4137d61775b778f9b2ba99a1f0fc09d70f3f705422f24d0f5f96188c8103da2e1e7cac4e9bceee47438e7ad685cd8d03d14613d7148f981e3bbf6492fd59bbf17d1a83a9ce748eedcb6765cb18a32a1a29005447aabde58879e5ff680fc11d5f9dcd857eadf61f8a971469de5d1ce6e823ccb5407132de6842719c8969afa7bcbb094904b534011a06d7bcb5ab5592fafc9e86ba11f0ee5434af8e12370d6b3b8eda4d340b7427dc3a63b095be4f8f82eae84e8f6265043c0a9b6bf5f403c15242b1647503d8fbe17b7e48446d05bdc84a21d3f1c11ad03ceeeacee51ac29893a4c594f5c376489777ced6a6843cfe75de9825104211fddf957b64f5db16eb849aba98c3eba43c6d18d1307904d86bdb3d5326b2b37bc24c3c1d3e94b88203aa4c623354229b215b71079de2a92e18536c43b7a0efbed85285214d8b209a3a0df86c2b751ca72e8164f6f8ff0beeebc1bbc680e3a9918df0787a0e81a4317b05704d41649fb2ac0e4e2dcd0cc5b2fb47f7d96b6d0845109eb4240ef7ec269170529ef018b98a17d03cc6a5f4a00046730a441ff3e4a1cc75f77d28ac5d06c04c91604ad130168f3d8f3c5bff803fe6ec63d64614d476c6162dc25126ca4e279d820c02a649918f227e613de3c2f8249e3ed45f75d89fcc026a762dd3834f9a108addeca091af665b9d8f72bf0862129f9a77d0763141e598933032a298b133b8599dfb98d5fba5bbea4f58d00773918b7192f7dad5b09ce725c7cccced6923d804e5e1adedec32bd4ab92b17ade43b2a0db7a70b58bfc3e1c88af4fb630a000bb9ea11ffb48af2f5456a277148636582421172f47b332c4a4c55feb2f4a8ee577af9700dd9d84b70b9be34dd1ed3fc9f1d1cd1a1783eb64d071b0d1e63ffb9e8d3d48c04fbf621f4082224b6d64d124f1d62f44e5600a6c205ef76769de2359e7851df981b3b0418c4d83503ac9ff21270c9987fb37a9f5176c75bfbc6ac323ab6952ca1f0691a7aa33df607d4fc28c1b920e15fb022a1f2ef236b771f1843b88731a143682a8de2e4b9be94ed7d85cfd5c899403053051bfb676b0d7f6294a246fa495bc1dfed3a43f44ffb5d4471c8ab5b145d8a76feb468a9b5b1e9a741e38fc888192b7d16f6b54d27906482ccd334b5966891129662a5a559127dcb03bac622f550d8e05f85b94c5793abd7c155e470a15b0e4e33ab606436205c8ccf18dae665b7d16f4ff5485994616ca9e375490557a0de06247e8d6d554fd84c76537da2f77bc00904fcb529d879b5fa6062f101695af7ab68f4539bce5588d1abfa4228d60640e0992ad5acee281ec0781252d31ebab5aecda2c596cb368a6e2b38e838dc23a1a8b643a92219e19edafc9d246f21aa5ad082dab3c86a9df853b0d5ac22781150f9e275b656bc8502c5222aef25940b58cc1d5e21b29b5fb3ec215bb980e43b7763cb9e084197698c26aef30612e9ee48e52b0dea962c53e16074386a850fb583d284d6e2a021832f28cc3182dec9c30f296b54648c9d374cad3f3952170458dbd4de85642095ffe1ee506e8d15da1a52f363b95669a5119f394b743a716f53927225c4b1a5e93386d66e10ecd02ae30afc9cd69d3681b4d32856d181249830b5db460b53fc53d929019f046d8017d9c8b424c58a2bc5fdfe5ad431870268b866fc360b7e95bb1b85c0fa9fca6c4c711b3cc06f8f31c448fd534cb0fe4abe2764e80640d9e5bc315d327ab87a50c7c621f7d4828780fb7569b15a02a8bdad7c3ac05ad7dd26dc68b4f0fffbfb076077876b0ea692a06a112a4a83b72c55baf68da2abd62c4fc8868426473d2fc1adf26db159286ad972fa1b9df76d320498de3d9f766447c68b7316f2c9ef28e179ad37f8d22b24e3d82d25a0e9f4fb6e84f99d724d690a022742741d17412bbb919694319120c782c16a844a845257047b074420d36b12221a201d2e108d84fbb5aa9b08a11054eb465ff91a76becd7fbd56b236d4647b756020c926a937f42f5a3c8be1641aa61678e87fa13162d8479d275e14a1aa1d59e57f135a54adce0fa3988505dae3a835365f578e43ff16d36f4fcd851477dce68b40c5c3d5b1687b5fe85fe5b8e09772bb8d6afa5a0ca3e38c937b233cf14dac8764541704b9acbff25e159f11b9378ef8f7929bf0bb9ef723d025793d85efde54c3e9f84c30e9e1b0a6868a0127074e08eebdc2308b218c2c51f4020c08c6637adcbd6e7d1639866456ab0e3cff5b01bccd5a34a3b2eea2f137eb30de9538d91a5145dbf39daaa44c0f5a34b8fa2c33654b882fdd62969fe28ed4b6a6f9706eb44a51769269cfa91f1c7a7a2dd850cc7844500b1b9870d7556b8959f3dc7267d66a4666e11bd2ff78071a312e5c01e1abf977960ef5baa62565f378ccfd704644ef5bf5db241be196d3ce04107141fbefb6ad14cf7a108322152571526ec92b5bcbe1f7b51d00d5f717117176d6233f5f8c7c4a65a3fb114b2ce699fd78e1880f27c0dc4895abefae1e2eb17c8fbb2170d096ee06e8e884e2e8449b68a3d3a423f961527b7db51768a0d9ca2f85117f3a7f2a445321c9d6a8ae432c9a008f51fc4e9a53b097bfb5b0dbb953058ecf66b330126efcf83ed493f97314fa55e8e526bd31812c9412eb8c3909f61b2d29ab2f23107f804a2b1a0614a0767b93a8265a44e73022d5e403e6e3f35a81d68a714a4f2c3a3474bd6d72d82017ebb5482711130af5087f3fdd654f4bd91a709a10a96d118642fb43ab41f443f89aa7d3c24fb3a853f42ea890ecc02d20e45b886b9993b1701754835dffa61f221239a0c4a9177076df0129f4dd67013d6bdca131627ae923e5666905a27da3e47a9331be0a79ec872633187501b0bc27902c4b19b6681780dfb335f2181db497bd231da0f60c97967ecb6e5b9973844b861cd1b7686b33bc474b45824571a7513df5f72b64702c1500b94b490baaa03d9a8b7f722a9800c254ba31067aa706c15def4bfbc7538e58e47d68415c16a9918127159ffbbc68943f9eb31dedbaf86ce81ef009d3bd1be9ad4658dd650cfb20a0b70b40ba00bdb80cdb192343ed4b6f676cb26a03f58c9a357ea3234c2c684355e301df3c917e606590a13c2ca00c8400d7ae6be6b273707697af0555430c8c8f740d9a3be421b4141a259c6227da1aab78ba50bd14ed446c1e577aa6f8066c23780e90586fe3e5af1cb9b460a4e7c70bb71bea186bfc4124a6b843712c1b9f013f397b82437ff4d19b1cd399b6f522bb7c3a937a3392336ac415ce8f0e5e52a26b8383e82e764b1e11f4fb4e61054d8f35fa88a4b91baf6697476534798e8186ade46338a3a4639feca3b1cce32bae4b5cafb6e803a7be03b3eb33982b48e6e567e01369d0758853863b0490d50af2b741ac0bd5afbda0e6319fa7c3e41b2eac13a42476de78e53758e5927ac793e5547ec998c686db7d27a2fb5e95dee0ac62138ff66730c70da1c6f30d298ffe0c1d4cc75117926d4c35f19ae3743f0105e49599aba0c457a722eea37c782d969de4af5cd1796d97f7479c0bca3d6de4885ebc5aa20e164fba505eb7558ca6ea31bac38166e60ae8ef60d363caca1161a7a07a3a47f3253ba3fcae31c78894f641c15d09fab89db43bf3c38ae298783de6d3032e44fd4cd4147ac072728579b882e9c6af771aacd5b7c34a5ac9074c9deff3cc38625a6665b46bfe633a2976e5f2793d3adc25081de9df357ac7acce9727698e8efb3e210e4818f45611f1d0dc5f435fbc306f8633ab6790c819e9ce7ff4fbc4a5acb5e993740428a6e99bafefc83937cf53e88c56d663289287e44d867ed754fb1bda3d0dc609be1f212a1ab93d921e26f574d4339df6222ebbe27f31ec7da8e3dc559748f13735eba5ee4ae3a1789175f2c429be53ccda4699a80a74fed438ae1c695cbd8ab954a922afa7a57b6cd43523ea0ee634ed036432e6b8ae536827db5853a1b70febe63770d102e74df0f9a8a5fc6894a81d56ecb9d6236a20034d1fcccca19bbb3a6b8d2b9a832050cb4bc137020bf74ef35ee20f05d6c1de1b5bb066b72bfdb512fc706bef5ccb4eaa27a9ad1ba147060b7ebebf310f3153b2e6738e5833c44b97e37e34b4a9e8cd9c12d2f5a0c5ecc7a402ef7e18fe2be21a25ab3469aa2b3c3c0a80264c612ce1e724aaed0b515e533774203299a2585dbbbd7ec695cd2c2934f6564757a32c9dbe4cbc51c6ca208c0acbe54417a00e87cc7b91548564779c8f2b5a6d3c873f1522e0b3b5d125ae18db3eb3b2790a8579b38135e8e90de9e346a8c856566754be6b0ccb5b936f9c3895dec5fa2f634b0d3cd6c136729ef7556b4a62dfe9ef5ffe28c3fef74aedd4ba67660fff5fef3010b786c98c4e4914dd56c8216a04c6de36456f404e1818047c32a5254e2112265877db67d4ca42708537a41ddbf360bab86983e04bb5a525080a253b11c9b738e793341b4e0eb1e32260eb0dc3fb468590c156e7d0af99900b04592a3c2eec9e4eae1b6d128c8208005521c7eda23372bb351e0925867ad0d6c6c3998ea69acb902775dd54365648d10e002ddfa023fdfa6519ce200fc3b1e4a124d648bbd3bbe3bb43ebc0b54d26786ff3db20598cbff7cf302550561b672ad4a3bc6ecfb01c52bcf61255ea6f715f274f97b2cd20651b9c74e6087d7dcc532562f78b5fe6de1ada9f702e7abf3bb952b9c19fa0a7c878320e6b4ceac420296630b62ddb335fd2d23bda9c77c3fcebb0be5a97cc172a05845f1b4220f332d080f07cc73f8059757959e6d34a9f791c0d68fdfca901cabfa81b2b0b9981481f1d16a93cf3a9bae9c1ca3533b8f17a353c04c03496ec49ebb8bc1e8661357dfb2eb7110df5a55935e0c31e50695d3e45b218c8ecdcdaa3edef52713c560543d52b2db0181f1e248ff30914972c9b45b55959c0596e8256ab5c5b0845d4180c4fa475c610c451bb11f12fd297af69b1af08301e9c1ff7cf1eba777330292beffd02aabeb22c9f2a3d041c94ae63b5f8df820c3e700c69e98f5cadc36d824062518d848210020faf271f24ee1a956731286f46efce623df385da0eec2fc3b1da79161b148ac0e209238ea115bdc50b144526db35fada0163da160e573522ad0c2e871aabcb544885e36ddf908570415bec7c701bb4b153bf3a6b863d2395145b7152d34d7520038c4467da5e174a8215fbc3be4242da6a30cd9b5573cefd91fe109eef14904a719fa0f1b95865071c3e99d61213a6480d4d4cdd6561aca30e5cd59e63cd4b9adb89fc5bf508f984e6f9398ea2eebc7854030bdadeb75259037ed50fef575f563e8778a3255a74ecab22797aff3f83d1d0bcb4f48fc7e5025ce2926e3014637ba51a4f935fb1825d9b98f0b6492ade682b889e582865fe9fe24703414a85f8fe3b4df9d91567afb0c24f1b750ff769cbd2c993b68d1313e2a18d4ed1c00f32c495d1ac5514eaf58adcb5a2c48475917b83d8d59a11ef5443290d2daee355b2b0ecc7fad4bea43e92800986d86312324f9a243f0f77fab6937f5a1dd29ca0ea3d2c0e9585a673da035570aaf20fb57a4005c23bb8077762344f572a0654e9232815cc0c192cd0b81961a19926b7619ed2de9377a3e3dc10117111c30179c1517c563517aaf3311a8ff5055b1649004746280a2c94e4052af244b27cf3cec4a220c28ca9dfab476ca747ea3ec639b0fa0ace12856bc94a4f647d4fb6e091b85a8a97ffa13963689d3eb6955aad6e01ba4484edf33c2b4f8854b88bb999dd520c046ca65b92cff5f6d4e545395b56b4cd3c90390ca6c28e5213483ca3b979191327af7bac57c769718580f2749007b62368cea1ea39d2e06e47e747a785de72bca0e974c374dbe6536ddcc1db951350de6a6814eafcf297e9cb70b4694baeb2eb806372b5715a7a87845cb52da571028a82b60baf2a0fa111d909d0fb3b97111b0dbe9f50d211c128e1dceb19c1ff5d31f226e147dfde66a791d17f66000bcf6d1b8d0c68800c070aa26a05f03bcbe7f9243c54537d0cb1e56c4de8e23e7ac2d587098cdb6bb301a7eed99aaf53566eee85648b5f5ad9f9abe4adf04a916d19444a46c4b8edb0d998ac78bcbb2e35dfac8eb7e241ee94054e757abc6ac3a7d583b116d3ca06f1768e99dcfc8e6fc9a4126bbc446387b8c3c767a41ac33f4758a650a35784aa31bfb539ca18e975f8e8ed99bb751ab38e6155550450d7fcd7f17225e4d01ab718f899abb25357ef2aafd99925ea8f2761f4661ece71e3aea531d4039d262d16d06f9cf843233f1871b0e3b47c2de276a84884d31f841e28c3c2da85787c489c6e368d1db37a8192a6ac952f55020474d8ab40f6b8d6d46da55b3316fc75dd6d01fc66fd97745990a3818b7a30a2e07233cf24ad4d27583e8ef6bfc09ad783ad65e4ed7c28b8c0cfe659c0fa2033ab5408c252f14ae63603a424bf39aa3556f56057d8f55623fd1c490ddccdbf91dde5629b91fc769cb252a3ee0f45d79c39fcba73cea0029fdfacfe5e36a75f463a27160a5b506610e7d389975fef33bff772d91148021cd4018cbfca693e32bb5978be072cba368433fcd3e8d5083c1ae0f0470caa664a53eea06e451c4282668baacd6523beb2ea358a05866d920a0435ba64c8ff55f0f393a1dd96ae0ba71cdcd36951586afe67b52436a6257f33742e4677ea3dc36cb6c07d7618e229054007d439228aa0c126ff5b8825dd24311c7c80ba77f58687197f9450540657e55711188767b9929c33657928f5da67fef097b9f63c18062a6a23a0035873440f8ff82244727cbf2147cc214a65b1922d76672cb5dc4bf658444dc31e588a8437641517c93d909daea6474a53ee93870fc228c1e37b55ce2e6094b53cc260b48f034ca173e3fb76e84cb96022628fcde0490172c2885fbdf8834bbf12ee31fc8d1ed6838bbd1f77032a4ea372a02c869055737cf3e7b8a8e28d28e003b7612885b025c0a7202cfe0eefa9efc95b319a77685e6472395d94ff3b330ceb0c76af706d57ba9430806c06c59d28f336b88a845d787cbb02f740ed6b3c36f5873d80e047113d86d5eb918b918ab759835e62a7ba37266186a2cd706f52e55188a39ca12f929a622564b047b0a3a7e746f06b69e88b34f3e9a53b8473eba0d6a415770cd3e05c73096827853020178a3c3543ad369480e49d215befec8fa6946517ced38d24288ee4c117d38752e471b155379250fd351a378587e55aaf096b8fc70ffe1ea28eda8bd32f743238254ec038206fc3e632fb25de38c30d67e2042972bb1a678a8c4d49e6b724803ff04921b85d70d44034a9ae434ec369bcf0362c895b2dadade63556668e3f63af676ea771058b08c9797707957721173e8e0c1c0a21b01414bea05e706a3f0ad9eb691e5a1175019e665d1aad93e0f1766e28a66295a7227dd85b587fc4cb20c53a397b897e9d63f382a7440efa1489e57f2be653229337440c744b84fd04a2389963bb1f66f0c24126ce42f45b31ca7cc649ba4d991bbb391267f06fa5c23e2052c635d04fb0045a5e6d5b713cfba7b97e9733dba6a95432b25326841d740b7f1990a707b9f3f47c43c168aeeaf75c6ad91e3895cbd68d645fc133c7718d63e5b0b47423e5aef81de6366a91d45db32c75dc7743ad4b82a65fc62be163c9eb7f824d920975e423897f12f8b50556a292578332761542ee16c2998f84dbfcc1fcb0f640ad015131e34a53175a2e8ee2218f824a254e1458a90834e670238c1d72eecdf14db9b955983ab2ec19684097875cc6f751ab2db3386a43750964f72a5cb8384d08ff2ca70bfa206e643304c7dd3c5029861ef6345a65a85dc6790a6ab8e06f7960ea36807570a41a3db3c25988a368233fce8338fb0b447ad1a8c01bd1d8f261a483c10ec28f4987647ecaebef5329cfdf54e0ee82872baa2b6fbbf7c7d26b04456a89dc8c2d8f0e38f18f03d7474a6dbbe45e91a9f7d61a4a8de83abe561ddd412f022afc7d79a344a6e63930d4d262f7ce64612cff73006fc66c7c4aabc0659f109c2699ed4032ece8f87049b050338fc78c0543218332902d59fdec2e17c713e74c8241dea956fd3850d6ba65d1dfcd8edd9ce350f86e044a920f4be528d45b19a75e18b55975a582b2a3b534bb72bf938dcc398cb35038aba090faa832383718feb3c54d5e8c13fd41613c02e466ebc0c5a2ba407997108e64156361ba1c29d1e8ae86c749a1ec70ed87c12f474b4388ff1cea9358709b9d574d5849a8f457abac7639784dd949f381ea9140a44eec54f715037e8d2fed4cbf18d4fc2f5b680c435648c3719ea1d75e587b7d0fd7d7c6581df56f206c560590b230e68e04af2237c3f3f166bc43cafbf4f24efb84f0c6bd7ef112eaf8bd217c5434bffe241faa3dcdda23ecabb01b3141163a6383d845535592c3b5d00a5ceb3d996392c11d03650ac302ac1d566b42314a9be93b9be6adea480f2817705bc3788f7b6900e3e817278bb5baf9641c0645d3d6eb8e49ee1de586b7bdbd34cdb99fae7b0ab93a2d013173862e47ea62ead7923f27728c2b058745a456b4dedd0eb4385fea9f46eedfd5313be891e449b3cc9232b707655fffb67e0e0e104e0a35b58faed520484c1cc3ba2e37f2dcba4929a469db701ea38602d44092958534189895b48a8696228e305113312099e8f1b5bbd70c2d17e1a6ad5112a87a2b19a8d29bd7a4fc8c8e8e3036358cfe7d8083cf9596efc90fa444f382c96354be6c07dc8966b0ac9371f57565bbaf4edda60179b73115c92e6255e9da2de3b07b13cab7d92b67db829960a670e60bb7dbf36ecc9b2bb4d5f104de79dd8c56ce6d7b987136c248152b1ce82bc2b6aebe04e8c7e0d480a299150bc9e715f781b5ab7a9d2b0914a5028cf4c8c0afbb51eace4834efa5915f509db36d61a1e345fd2e14069435b0f301c09ece8c4ea798c70ce5eba37817a1fe6524a1c5275fec8d902b69177f86fe459bc12a400e9110b1f658dd049b3fab3a1da7e08375bb13543af5e8ffc153bfc7e1f3254ed73167e7b477477b38af69c229480c6612e962cb833939783fe4d631377a7a3fe1b01908187f27f24e57ab636","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"643649ba80ed23fdeeac84c02c742703"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
