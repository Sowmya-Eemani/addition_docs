<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b5aca9e3dc40ae33f883b7ae8f0952c4b06e4b964615203c8a6f45abf7e09d15c341607ba4d1ed0fb6740c4ba562facf8b732bd611c6c566ee73e039f6a40aa306321578fb96b463dbb65ce03af61e3b976f94b4fa6dc013bc98f5aa360d11258d14c53524f2299759245c911f85f93946b9daea031e5415b8e4f24bbe404f7626963971932d1e84fe8b7d4340dae3d462512ce042486207d6e8c40117369bf8694dbcf886012440329e1d1486b20f1e1ec6c339b3804bd437c300b43dc1cc0b3f84e7e3f562f33355ce1695e3e28d09eb339552ed4a9f32bdb67f2c691d3b3d0c797f618ae82a67309c2bdb9ec518fb7cc5de098a44fc75325b5e8e3cc6f0db3fc6f95646bb54b9b53f71051341797669a8121bb62845f010c6a09119ed97c185a67395b55e2cdf25669d83dd01c13d7a4bdca412feaaa40ec2b0292c1318786023ff6474387a720bfccf1f2c066fae1380cf0d9633b4abdf57fce9ef0672ea607ffaa52a7922a15a80804f49ac5db5ce3021d642f9be3a0d9b9b248ad205428b479d546441887267c636ed2cc420f7d145fe6c816b92fb9736ec48af528ed02a8684204c70d819b4ec3f685cb39532bce6d05a39144ca35145f8d87946eb50b70471183137367ca920ed3fc4006b4a6de2a5ffbc64af66cb4776199bc0dc6d215d8c29af9030fbc5ff97291c4af7ec58beae5345a5e165f938c8877448788c8f5fec8820215e507bc9630b873e057dcd95280816bb0acf740ec1eda2803341959d35920b657c8e5a29371c751c371bb35ea8273e09452d32ee4a07827db8be69460efc7b4244c2032eaaa9848f9c9f9fed07926a899d7dc1a478d5fde752633f341dba760e173a8e93adc00057d67cdf6776b2098040e7a51b08fe7aad1459becf43510c60e9e3f44c84a16c60c87abc399c7355d51b41844401d2264b37c565ea31b4b5c3845b0830d1f2e0918a8c7620ea408f48dbaf36928f0a229e880be06089bc7c9637e8a45646ba3d49631eaf711c2c2bcaec987d5204cd9904eae289948f9a8a677209be76a9e4c1ac24ef42b23231a8259368bde9494481f549fe6e35c488399b8c9f7ce25ded8ddde45517fdde2e5c7250e8a84e3800dff5385b7516310d9fa1f399fcf17b713f8096506c4a69cd8781ba857589c693868d23abf54a94d203702de679967a20683be92777fc5fdaa621db99ec06058632805766e96de96745599aaeb71c2d97bfc04475611f0f857072ad5cb540798804c519319e8e0f9f3970bc89baad98cdfd30fd5f43c15909fc9229fa259788973fde63021ad8b78c4e666a9bf5884400c8f525576a5d6799172f54f4ebc677e26896d3e5131f8f6269948873f61a3d77dee91fa39731d23b0c788260ab9296f8861756b4cf384c688a4192756593ba15f2447f51c6b2ee8582b8c8b36860ff4f916c126793a244a6946568b1e30befb108ddbd2ea56860b9bd93ea125eb34e0fe0aa49ea251cfc543a8e32cc85fc55439b8aca6d9d76fdcbcac3456bd08a876da1526c2fcbc78c619f1ef61ac162fac8817b0385fbefa3647dd1c3478a5904bab3233107384a4a322c638b4f427f1bd5e9956ea83af1895c3cf69a3153c22bd0e73510ffbb9161abb080c0374acd538ef05569ec65e2397f820e8fb3c6bd7cd14e70a63f7224ae110ac0e18aa195fae5f342bc8dc523d7e83e48adef7d2af627c1ea197c4becaaed9f7a7e478e925be8fc5fba366177cdac79aee169322dd0329a64c60268c954b05c6eb962f59f4d55d66c611eea537fae58a58f30513d52fc7d64bd546f286ee7e3421f2a49e705e499a5b70cafba8c4795497f07e0639fbba16400479bdca5b659164d138c4a962a5eb144df6f846435eda3abf524061b0f21b387c85c7b43fcc61a778ffe2dc055a38f7a73844c9c1dc909be5080129d7fc157113e2757e436f007e7d2c34ddd5f57f4fc4e25cb8bbaa3f8492f5e5ddc1cc1b4e0992b601249f3411e2819002e541303359958aaea6bc63e343a05af9564dea3c9341e7a9d195a3808a013b2db4defb896269fa80b6055a55b003f53fc5c790eb06cee51c2d5598f76c0e56d58fe5140101bf452ac773398ab81e4087d7e3f496860c2f2d4f0a114934315ab349398f907d7b03f137c5d8253b83d4d0b6d8bc1261573c29b27ebfe899430ed09af0ff089841f259a78cbd1d0eeeb5f2e8ae318ecb4ad7ba1383ac258ca8e277f4aefcaf35bf40e0ad50438d6b0c26d4c2e49ee19322c832dede67fa2d4cb7b0bf54ca417e89592647d9f2203971f73df4d3a5d67ba866208d24f5cbdd2dc2fcebe8d050ff23c4c0f511b95b26b7e2e47fe54a6ff7c9d096608b128ee103b06f45551cbf410b36591ffb32fb2632267c8b08ed22c370916cf9dc924c0c5b745ecd807113cee7e45650a4dc75925774ef1a8966b1927e4a4b3116cb7663403a916ef24747c2e38a40361dd416aeb9b32b0b4aa43bafaf5c2ed3422089f828829df42e6102482c6d62e2b31d71f6f85e39bfb820d412495ddeb9a7f9feee5514f7fdb444d24820e622eda37d63313854eecdd35c742400e93f689de66b5b2d7068a9b95d8c4954f27f6a22823ea569770c4f7faceeac7920bfd037eaeacc555ae3d2febdb6ab35a6456c3d37f74de5d797049527ffd159cd604c8fd2275f8cce67e582b1e4fb0cc2ce8b1f3bcb8759b6df04aa6dee303c44a2b3e1bf1b7d4a1c745a8251c0182a751f57214185b79c40c7e8a1be2b44dcd74a84d618d1a2c0871a150cdf70b0e085e4499b0783ca351b4fb386866107f3ef08a9191d865a4edd9692aa106834ce68b3e968ea500bd58fa3816dad3345c2a2fca308bcb70cf6a095dae33980d029cbf737fca5ff639c9e025fef8190ff9265bca4e2a5edb2d9ce49379aa343961ab9b646e00cff16425f3c3eaff1688a664424f6e684923adddc53bb3f058f99cbc8a31f554e3fea0432ab55d22833a726fe706b3ce2c7fe426bf73d06285bbc1f05d288c038164917bf0d63f57243405c99966138b861dd3a80e7f3bb45f3b0739884ffc532ff7c75f0faf4ac9f91453a85ffec34626f7aef5c820c6653bf587d2b94e70882992d327b8032b384211964e88985362544defbcbdf15d50c10754a87356af539bc396920438c12d9dd12821ef630201f6ec4c053206680207c62ada2ff50417edd41a939cfdeb87d4507dbf6662ba901569c874144c622d37b4d1f906a3c9de9088698a38b2b519a3942ba98e148634873c88dbc64913d075333763cc3cde84f6ee3b317eb064a680c211f43a8f9aa3c22f3025a601e7bc22855d6a801ce5db5a2831ac96c8544b33ddf7f2d8d38885806522f9d844294d326a8f27730632dd069525a40d93176d518dc9a96d812816f8206f080da7bd750e365b5ca542883d601e0b85584cafe4ade8142ebb0d22bf7001f728f0d29ce52938047fa1473cc603d44ee8e8ea04289859154bb1875bdb471ffc8a948c50480b81a9dba1a5e8ee940c62714d1b6b25563f4e4fa2208c85fc17e27991026d1ee1cc6b6c88722c401458beb91e17e11d9209903c92a9446240fef3b005d354b9a4f1f23383bc10ae3a853a22aa9a09dbe4160f20846fc024ae4a9c69848158aeee743cee602403a4891d0b1590360573a76314ecfab20904131a4ccdfa4111d56ae21a4d07db3366950dd0efc0aa2aadeb16a5d9708d41a7bd9ba71fb8e97e03b86fd576ce93cb3fd8b3e2020eb870dee9363ffafdf67348289741088ac123acc79252aa0fb2a0961c323864abfbeb476d56d5782c4664d6ce5cf9546214b7df780dac8eb81a5e070328e49f378755851ac6dfa443348a6f5f8b35128e593935601878ee461934ee0e5ff1e99abfd9273cb4bea456db1c989c87bcd104cb4cf2242ed3d3c96e05023e5411bbc5c2afc24ee68152b8a57da266f19d599766b9c6137011119a08fc30e26e57d8749b7487ff0f1438dadd24c35103f3f4894acfb97dd020bb5063b7aa2b9019c150dfdc2403fbe5ceef987cb66c035a61ab62508dc118e85145545309e0ff4c93964a73e4dce5feebbdd26d126689c84476663d1c04b1ba832ae52772ca8937f91711bbcd247701dbe474f90f60d4c055ec2231f590617b297ea752e36d85db9b2815b4289f890159de96d9366c6b3b2a9ebe067391ac4ba85d62ac5aad960bc236e9db001590c8037a22c5f2ba2dfe7d11b8306f6a8e9413f3b874c00f4a1e8a5852972aba68e66f8c36f4d278d3f19e7c0c477963b5334b42c1be2e2b58d32ac0554f94689f0f7a152d70c9f8b0f7bc85d5721652de1957a1584773871cc9a4acd02e95feef8fb0125c790aabc7779942e35390de48ccade49b059416197499abcdc61223ecad1ad96d0b783b633f52f0416f6564f3065f8c42bd6d23b14c00c59ebac51332cc550da8c57fb00f3420a23816dd0bb448bd1dfe8ef0c3a0ed689d5588a5e6a49d209c3762bfbcef0bd7a8c2e6ab7b62025835caee5741f4e8663bf697a75c7f89c190c44e439798da26fd29ac398d92161c9947bbe52ba1b2b5a4967a53ac94a03a4cc6b9b599e894543243d5fc72b568acf1421bd8619efd3729a04b09430660e9057d6ac4b4b3537b62f9fdcffa5c744d3d0ccb83761577d33e8dae03db786caa24a6d012bfd3e0d30864418140976bc4b1885bbf560a258c0f2fd1dfdae30f5aefd84edee60f786a3c5163e0193d8ce8f52e906150b46c277d632a295e41d5b7367e04a56bc9062bfcbbbae17ae3ed4b7b19786a660013b0d8e96eee127842e09496e773625a047de5640dbe487ab5adcf3d2c2fb31da2ecb340e6ef8c13b8888ad0689da43efa4ee15645ec91f69a3052d472cf3c2a06b4e22fd85598a0b920698fcb039c8b7de1a0c97a8f79dd7030e3f99b47e7a00ee7e5b7c94151183d548f92a6213e6bc8ccd513325087e5af4041731d8ab239f734b7b45bd624385189325f8ecf2f08cd6481b157c9d743eda4d0d40f8ead4c396657cb1661ee0aac2e31511a881c99ee73729498519d8e759ec9a2622b238cabd3038ddd91c52ae7ffa532e9c2f7285730ffcefd185b22f9012cf1ec918a8beb1337844eec0f738a0cbb6823e0326e8efcdc6e5c1fa0fd12fb5e6fb753ad03c93697ee8ed968cf6b38a147e152411c5a381b842eb0412b9b4026bb5b35d148e148a264e70c030772ad009401898216ac6ba1c503c8c4b1fd6c93680ebb4257a9afb7540f4452b32fcecaa1d5849df4d16eb59c5d21e12a3403a432c2575fd18dada77acf829d59938f57538b821ed28839ae18ff8fd37aafd2fb5c85aa4f62e43fe9923d32aef92ca52169807febd6fefa5f6cd5aa2555128b62e5ba3b102670538e9775e0279df783caa50e9824e1a314143c990a0658a67960caed088fd00b841614db47e93e909e31950292dcbe911f3b7a10eb2b02a5add24251a4bcd8170559e25189b0aec733401c16f98442379a8c46f5ee2ffd0f46159fe5d99276e2b8b6cfc4737f7f714189d95b5cfa81026cc42e5654faebdefd89a4506c838b1f2ff7f8f16c9470c7c0a5836040d499f7042a84d290ef25da10670ef15888dad20633893a92dce615bf9254992454421449243b453009da6772aae32beb44f1d84ab483dec11a0c6fb19624b87ad1e16afcaa82fec6771942141116294dcd655ad226dc6a5de6da35c78794a90d26e6653e30f41d9588aa4a67c91da758242f81b1411431a50c48401dea369d941824577934c11e2634460ec02854a08280c95ce33303454ac92f8871b2d1b532d63df13e29e59740ec929231aaa3680051159b23e1646414f69fc93efd48585186c5de54c4eef3faac10aff83fc9560a3fe15ad809783939ee4bd3fe8b1a002b825578b59bc2fcf16f51e29ef899ee7d236c5243a8a18d10cc3befe74ea151c25cd51c5d37cea910b02d62fbf84327f3074e8082a4a41795dbd0e26841c2920fa7354c7476f56b1cef1a76d4d5740b334099bc0d7f0784eb13a0b3ac63a7c9c745ffdbd1f30efbc1f24575b03f5d14c594fbe1f3c2dfef98319868aafee92532d93c2b2093fa7d8f37d0cc6474bceec3b64cb23d9cfef40a35d2ab3e8ba12a51c6ada9912ee2b883cfc5971bd0e2a45f5f79240941659eb6b7b1c438ddc6b2c1f9ecff43e72c8018c51988d556e66a6d69cbf966e6a824bc2a736e8a349b1d408fe646ed1bfc7bbb1dbfcaef31e902eb8c5102d4db6461ec0e132af5ed20fa62ec8fc1971f276b0bc505ef055aada4b77e0e0d513e727d744ac4efb527e3bf50bced3e521a7237dce6b2d639f9161d1d3e75fb5d67ccdb9b434450abc4ab69022ef0691a1dc64aa607fa2c1005bed2e998acd0935f9dc314889d88af1502eccf5fa82488281f67e97e7df8088e8b819b7c6bba5ae5995009905bef6ad56c24beac85cb9fd6b81603fb9f02eefe6e53a82748313be81ed46c753358bf8eba83ea6de4517e7be09064b8c45aaba53c6476085e891f9ec93e850d9e563c82613a1eefa128383bcd545c0dd4f1cee289ebb4b6456de9bd62d37f4f176d709d1e54c3ae27845336c5de56b3328029db7f11f7168be79a4d0f99e51c0f85bf5053f4161863e2121afd3821ec621d9c07178c799c483bfef6674b2b08856fe5497dd1fb21edd1500bc78600c5ab2110da2438c5b7470a436dd168fabf483752d4ee9754a42cf1d248095e5c555ea789ea4150b13ed60295f13277c7cb65ea4766923f2cf0ba039fff34cb496219a0821bb7c3d576ead5f30ea32a75837c9c4412adf725cadbe1d69245856cebc0405094610ad351c33f0ad891d33176e208c58f974ee4f56ca4d54504243b48493cfc8f67e0dd2b7ebde3d8a83e265801aea5e7abe9b669ecb93e4e8482bdeb62299a82ce3df5c13bd19497f2048c93d3ffe46ea6b38177e7fb5ac81dc553b3fb36ad57faaf3f67239a7d48c2f4e59f164579911d7953e6507cfa387792e540b846f5da429ef4d2537703f1457ca801ebaa38524cf15ecfebe40a5e6be49be92e420d5d4bfcd8e62a21510fa0a45106d00a6cf413e6930167f610b394d360bf7d6e6bff921a50c7b5d99fab10787ec061ea509557c4f803babf79e206321179e2807c39f6e7377b498537d253d9fd3b0f5b96799ee19ddd9822ce4fd5f46db8d0a1fdb1bf31c8f88e8b258d6f981e9d786fc5162ba1833825fe627bf5453bf0fce4b317f0055dbcd0441235c8b15089dce84056ef4d50762a6b36660463041c5b58d840bdd10632ae228c62d4c96e03545fab405a5977b0d2d44ead28548e59ba92550324ac6a8d08a7eea4ecda401b97f9e4e1319341264a017f762adafcf07bcf03c1ca2531d3f03f43d1414f1870fcd4950c440e8ce9f43b51faef3f35f5d31dd0020f33f372ce44edfd4cfed83e3b484d4ccc2ab4ab7e8b04e4ff6059ce9ca9639fe16677759d666b921591c891a81afad886e16f25664ce6d05f43560712a3e68efcc613c9e6526aaf692bdb93ad91131f594b7b3145677fd4253a0560938725090626f9826585ec56fbd87f9ed849af1945e468275c3948906d8b4544facc8652eba1e9cdf018468a51c77d4990087e364c76d78ebdecbd0d951096bce34cfa99cdb164916d4f1eef859208ce31f1590dcc21fb89f0818147e11139ea9b28d148d53cb7bea49fd4a92447cdfc64ebf388a7b0be5d3668a851a6faa847453e5f9c5027ad53f728ecd730aeb6597dcc6b662481f50b2b8ad5ac845a637f4663421783b354de7cda5d626c2b5b2bb9a2fc0a2891196712b3e258b2b2f576d04b87f315c235dc26c74197b15dbb91f9d1120d2a901dd770a182fcc6cb7706a2afcac5735e3f2d760dbb272c9f0f08a7b3caf88aaf7183a25fc743fe635d4a50230ebb005461e2698462afe038b650a2969bdd8eb35a7d24413a9131781c3b1599be7f610376519f073682b77f745e6924438c6b45569a1aaa03d2cef5f48884beb588e1f08fb77e68d3c9b83d34c17524987efe9357c46f8b0617ef4c190d26ddb7134dc496afeca8378da68df0b41abf52c488825c965c9aef3f6e7ea9be1d5bfb06f11dbfeee94e11d07796590c491a7e73dea7f9388a22e441d1c60f1094b2325ffe9d93f74155b96a8ac7f224f370d5717d8bcec3a77f4e897a26afed69b3ad90ba1b2838a6160ea8ce9d7c4b441aecc2cca2a13a046cfb63181c3aa5ca2d7fd4ed0ef38504229f764bcea80515b8776ce528d451ec9172b8612755aa0cc54ee923a55826ff88123db41c2b49ebb0449cdf569c0c9c9744ea7eceb2c41dd1540441cbf5023b5b76c212862b973307c846469bf4867f59391bb54404d0a8b32777cfcdaf4009cd65b44143f07448f16aa5b37268b6e28cc4ddcc6b1f63e081832641f77d4622675b1fac3b7fa89fc5eee6c6276eedee24493f2d532ffeb98bbda5d73b161f6f2669a49fc7924114ce3ad1debf59956488e92e5d05054fc5cec47f35a9cd592daae4df0a48483ab39b97640da5469b62d44782f6f9b22af9e4491866933c5dd143e88a2f430afe49ff3936f626aa7f68b70f770825e9984dc9cab7083120ad69ad43553c1c89a55a7750fbfe45dc599489094b3dfa82d3fde146e2e5442636a7f07fbe92d2de79450790d21ff8aa8386ca0a450b91e0721f3ebddd9c77dc88e63c459f448027ad86f429dfeec753eda62ecb9c081b460a4036545e4b486bf98be39f74a745977ccc2c6fb09481f0d9b2a7a89cd573745b4e5dbaa1db2c103f994ccd398a73651f8ad01fb5f210574c99279bf7fa46d79d3bca759a3672a361282474509f775157b28a005c3a3da2da8552e6f199cd45d910e21709d162b6e9414fd51f3468026e6f6933cec0845027a35ad0b79dce6022df039aa8ceb5cfe74330f09a34da9714cf591146e588d1436e288163d61d0d43f03874e08e91010fe923c247f92c3a076f18cfe60406ec9565df4f7f8308026836a44b78bebf568e124007100ce1f0fd3f145a96bea095d4c6ebd91fb36ac959e7ad21fab7acc2609fa9c3c8d2c4699c395fc00a28f82e0053c9166ca9da41b180ca0822ba073c7af1f025cdc2ed3138e8d45bb10d33973300a0040319b2ad39227e906861da015e9fd185312d2e4eb4ad8a8c1d6331b57e5c71cbe30b2fd63b328404d64ff2f9524dbddde766c380330daa973c4921e84237801925725294c995470e864ce52be1ad134f44ada9d1407ecbb2caa93266ec5d8f8ed858b8556c11046d6deec046eef266a00650f42cc7da2a8a89058cf1a2ef9aab667173af031fd7be0ead92ea542fb196bff7c9bdfcf89e4537ce541b386f782a0df54f927fc715bc0af55aab3c9ad238549b334f009c5d632c68954ba1fd5262e2f5803a7d1ba890832e08de46ade9f2194d626faddd7936ff59b1b651751458cdfc17dc26613426e84c861e335ddd59ea93cdbaebd6469283c46132fcde086a4369477262d60408346d00fbd03b682dbb8bc565d033660dbbadc0e22305a96606ca5fc6be32dd5fd3b7c0e66c43308db2a3f0ddc0a50d61d9a6c6229d39d153ad45f26f832ec34fa0d1b62444a224b54fb7fb0040e895e6801756b69272149b924f44685d9782cbea16044b6643f07cdbf0ff0a17bb58020971fa20c7e51e28cc2ce2bae89c92983e08c92b02cbbb1adc664e6b0d8e9e6c5a384ef63d6638b9306c02d408be63dd4c8a77d32d1255b135d0e61a6fba16175ebb5eca51c356350e72732624e6921ae435583747df57f22421720e62cdd25ee75bc296e7b2952551be1f123564fd5e96c8e19def34ae71a0f78fa6eaae716be3174850c2dc4e5c152c4214af933b1dd6cba48e1bc34f60bd321203840d004c6bdf0a86da09ba4032bddc233bf6e18b9f4137127d7304d484e883ae5e6a6ee03483bc852f6cceed8b010e5b03b674624ad83f05ae65a126515ee0bfbca7b585c649201ce4f65af3bb08b04b564ed7dc2ed41d080c8d64c9b72456199f552747913b787d196f577c0541cad59022e8f44d3eaa6e66a7bbde876bb86c23fa9382da57944084c1b7157d5f0c94a29bcd7c749f1456822271bd545ed38624d55d1d8bfceadcf43b1d6d133242722211a3e82cdb371ba90998ca38abee9a0050c7e26baf02f0d395836f4172d329639a60bc35bae68dfd33e4ff5e34cd172383ade821322f0b5ac59550e5b70d10377938b02b6c88f0462573caacabdebacbfcf2954954e71b61f601a8575b378483eb6600ec339db0987e4459d81e391130915de6755ed349a5dc398061d5731848ca5d3ce767015b0ec64025ebbeaa1f7e5d37d6db48a4f6c4abc8f7b383ac91a4cb08dbab09f918e6a43caa0477e570dd56a4db224c8c7aa957bfaf4cdfc646560594402b6e02fafc6422d8ce10559db11e750b145a5e40b3c877902b9431ec5259b44264896c39a5929bc618a6d41f2f17745eb89cd8a86a980a65c3873c261f8bc74f87dc37ba4707bf59ab9c5284763317edf68446754839df7c8ae512dbff266756abfcfd039b7d4b403475b0f8dbbd1698081f97667644b9a4c6eb21cb134b92cdd1c4907e78ebd4667ef60bf056b08394028282f7a634d25c60d86b3bffe2f7980e5f312dcb3688b14a8891d6b23f17b550d0bc70b5b4e33da92adb68e78ba841a495ad21b8668e44cba135203c9db83b6e6aba45bbb6637a4b36ad944b408355768727da6e3273242ec1d6aa220f8258a9725dd6d09dd9652135d13b7bd8015afac2096279f00b9665cce4d646e24065ff5a3b65c6fb35fae79f8bf11cce6c54a8681b752ecc95336009bcb03dcf5e51e8c6a486104b5a42841a14bd1e9744e9cb47eee1a43a4dafe3a15baad4c9db841634280f6fd09add9a673e5445f0e593f8c60d7ecf3abe706f08e94e9192e69e913c0efde43310311bd77caa799eea9ab5101e5d77c98ca1da33d57db8c7924f41a40985db5a49a3241964bbc34c0629023ce2f1cdf4f7e1c481b176b32c029f7b35600cc70295c80bc17a45dd2b478edc65e38642ddf8b289780acd0dc9562d55cbe3a6111ca1c2cce7f9c2ef3cc3bbff3089074dac75a9c770cfb0a940b81e7c9c87b271f46c916b7c1bceec54acde29dfa6199eda05774443fd143f58b354a9281e60306a8bc622ab457da71d5088593ed2c1a88d73dff5098e78722bcf63c1763d9af0c5952f79e76ba3a4ec7e9d5f1e46a14e4139587bc652a6a514b3500b3544e571c76fc54b76765947298020f09b43398480add522caeee6cb5d7476b517eae4154875a14e43e61965cfbaac0ec57b77ecbe41fea784e128e8aafc3d31583d005ea86f0e8c51b586c8f69585c34b5fd82355b4d6bb11ef0ac08a918d3efbee059c80779a8c420051907aa125e94327e67dae690736802d4902936c5a9327bb3ed60f887df0b92d97e815ddd18fe1160e4473af588c5bc9ac9f881288e2ac7d3b2d8a91e166624354e28ff456b46fb2597e0c5266cf8fb34f84b2d56e8512ecf178726645a1b817f76fe5b42acb2052d92af052382dd4412e937171a00f4ff0b9184d9901cf5c5cbe87ebfa390288856050a77b76e4a2638b772a623bdd454f52351591b8d92cbb1feb17982c2c45793c280f3abc9ac189ef6e3a02459ddce65692904a970835823a6988ce8598f7206b7236e16cbe0c211b7b8c1659e440bd01454e319b32900f7f6a3eadccfb0df90592ff4c24273acde28231309ef9f45e4f55044de4d1a1b3c11102aed9b2760e1838bf61699a6dd16e6110ce1ce7759adf2b47320b5b3737ed6dc125418aba89a063e767b8faa1a3d3355d514c2afd7c65ef7bc591c45f1f658ab4ebbec6989501f0adf274beea50271f4fc1ac34aebb041937217f8682ee58030c88ebd8adc66c0c13d9fccde7e4bc49a2d16edd08f61609311ddebb4d56aa26e5789d4167c4f65533c53f68643b99f6cd529fa562740e3d83d7b41506ac08592d57f08613bb523a39d854b0153d7cc2b1380c140efb5be10f3d885d43524ada2442579d9609a8b218fd1f297311ee6fe1c3433102877a17874dea8e6716c627d5ff8d24cc87f5a270418a665a2e9b4081b24cfcf0692235b689f1a5fbf40b6de693236afc8337d5da0866a28c63340257b1a050d7f10df419cfde7d1d8b612079801075367aec73b2cf5ccb1bd1096d149ac8f4f9f76cd260d344781ac3416f70ee9d9516fdf0b43a1710dbecd81ebc740903d92def28733d9eba51365fee4a4fdea85b2376e671c80fbf6801448a5609cf7b74ae97e47fad6f30eeb73140e8136838ebe72ac9db142d03b48f480c618123464177bb1aa0608721199c3c5d322f6ee55f552b6725fc49d061dc8968fec9268ebfea7d845c7de346e7c823089be408511bdc8ea2ffff6c6e442987c21bfe1548218fc8d509cc812b41954bf7e0046fa4f75354f6fbf60c9020f4e781b4653988ac56f12a8e1dac209a3a4c034cc422606431e96f06dade00e2f6e0a55704ca3020d335599665759b961f4e33f8dbb1e4f6036618dc61342187b7fe7ad82ae38b8e5ef2c7b9b79edff588ad9d52868398b64ba8f1854e0381cef6ddbeb3b08f503e4fb07ac0d75982d88e34549aa841d4de79dfdb5ae579391c6d425b67795b66acd4334e80779384be9e4d1854f06025aa3cd54de36ce60494b306722f8c7292937933e2421ada13b0ff36b4cab04cc6da76e84f51b122d5c8efd92fe98a79a56c6ffceaf4140252fe9c46c04378acaef67b2b50386571ecb0b95c0d8ed10fcdde0f3d149ec85ded208cd641d39cee320fd523e49566f3bd841a87e01a6630352e20e3d8fe376faeca0a85b9c03303996962e1362a5e6d5c9b445b4063fcb32619cabd671b6ef8b4e4ab8853f1ef5bec781551c69fe1f05ad5945f17be8694179b0b11a707f035320dcd243ef949bc3e9ced5656c9aed6bb0df5c5782807be55c833a8e41b514b2130281d2669fc62fc75d7a847d8858ca6459165b125057634546efde98726774a7c4b575423adad44bf140cc068e2e4891cedbae2c4a3aa4a53202a2e6bac5569b2e0611ca408a202284e7fe97616878e43feae1cc661975914c50c1f02ff93cf5dcc952e030d45386331eb2991916f7caee6753a689aa435ffb35df80a80a562e51c9f6691cdc932f026b9bed465fa4c91827a4801c84c5800a1dc3614f20747200271ba490ca560ad48625360a5ea9b43134f4ff6d04e5065e64ec9358a64c7ce6e76658767ff95083fbbb2a2a28d79cf43297e5bc66614f7f76f56f37d5c63c35c42705f28f9b93aba6d96b2d0609677b8fee6bcc4559ef77ad06246ceb0fe716ca1e1c9798aef6a702f0f030ecb1de2e5e8cdb46f2d59a05780ddccab7258affc6a3cc0ef8326b2cbd854494faf167c78d2318eac943b5491f783bc39d9213a716ebd25fcf0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"643649ba80ed23fdeeac84c02c742703"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
