<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0e30344475e0d4908c9f14be90c5ece24423487d376cd31346f49b2c53193217f75ccfc77eec489a571885d3c0677cd567e57d05d9b125161213e876fa555e2e62964abf4a3dff5a5d8b3bec81aa6b98de7f091540c70cb76c2e12b81d9682745495c33356844655806b599782cd98b61db4be3b44f173fef681bb010c33c8bb118c6eaf23ff3c8ef92b6e5a26df466e70404abc95bc3c75298c315ec2aeb888d3aac3244fff7258b30d7ae0ba479f8e4070f41096a519998c6e5c90fcb8e5222741ee6382e70422232196d0bd10b93b73c740b80ffe3e355a298974295c9d6c71c234f691ccc00f8759242d93fa739e35441b154df6db9e79d5a7a39e03aeb666ce3574f5271a8d6cc984cf2bbd7a18bf2e0e3b36cd263aa4a9476395366e511dbd06adaee646a72d65abf62bcb06a1bdd0c2ea17730e8d2bfcc4e800282548dc6ea86a99b69b1efe9817a76b9ae5ae90b58331a56a30779476464608e862aeffcc84e6e5178b9a6904a2ca2dd592bbdb50b0021eb3cf28c2a52888d80479b40a8bdab350bf7b6b0117f9f3c6cf2755ae4fa0721dde51b1d94995773c263082f0711f868de86a9d5f22993fc23a0f95f6c09332a60df1d09ca8859d042b66e415033e3d1ac59cf4c673c6ad3c620c0475c84591d1dc1e00ce40ddccba2d9f8f1fc4a74e51bf3721108177c40525deda09c3fed72fa9ee4a5475c51efb2c7eac037da3d39c82208135fbd90ad6fa5be49500b3c68bf6346226a7ac04e1edc537694f678105a7031dbf2d2c1add40180247fdec471bc843091594596a65bf6f940bd5a3eda82cc5a1bbbf835a826d921593682020854a32801020cdcb140d459d6611a958eaca60eccf0d7b4455614ad55d787245a2fc5a16c71c80aba0e3633e6e7e70f9dd6d9c81e4f7fd12e279b5f2e5cdc944e8c3b49e84504a5d9b77a4e3091b1bfdbda0f3c2d095b45c36f45251ebfbe494fcb8345f3cb285f8444b0fc285925c74a8c4cac11575ab7011f24e53bedbac8cc53fdb75ab007fe974fea55941920ee36d141ada6ba0841b390d1016a6087d80387a8038a895196bf43520df273834129697969682e0c34e2e6a38cd0482e286ef1dbefe2e66eb16a9c1e114fa144437d623797a6a05eeff4bd2f12c1a7780d9206af17b4e5be75a9b2425a37715cb634f3c7d40c1a58cf86a652f81f132f73388c38ba13027ac17bfab95670a1e9d27ee5396fd7b68e59eb180d740c9a50d49acf6f1def8a5e26d5474dade3650f4d7f0636dfec305979946ecbf656e5ca8547e9327571a61927cfd27043975dcb6dc487fd9f99760bc8185070804897c3014ece8f92393faf3bd2cf5ddb200012c6fd980a266793ed3265acef9427db64f4b49cbabf6f75c28894a50c5afe7067557c42f073bf155c7078bd9b30862dde4ab27123ad6a867361060690c1b4c34a900b9bf03feb8fe66ae4640e4f8086ca7104d33c3ac801600655ba64b6a5e60b037926ba0200f569b6bcce4c2554026879de8d26cbacb4ad649d69bf4b7cb02a84a086057081d21fdd31cc41017ee99bb562675b595c899fda15a5ce1dc5072ba904a93a719ec175a533afee67c46c4e6ab201bf6e275968ebe4d30dee2c39f6e41d3286acccf9bb993033c72124e790dfa4a009341dc2506542866e3b73ef2643a6106d0f8a28ecddc203e2921b938ef3988fe5b3dbd47b0b1ef465073faf5cd49ae37d5787afc43e3c6da0890ed26a40292a23923009c132c18e9509effc2dfb2ce490bbfbce435fcee1c3133d33b92a92c2b4a1741507510fc469717d2dde96bae17911733e49b979e81306e16fff4e571e73ce845f58f52caa56c0340ec55c5b5903bc052f16442e32d2c8c7d5ef333eb1e84232a4df475a6e9fa597e5a8eaeb84bd7f8ff6ef31c88d78a23e32580021eb264cd0adeabc33b5d4cd398abd2e5c5d86034b7138ac18487b867c9767f4f407d1803bb08d9ea6c3a4f3e3b575418d9bd723701f66be9ed5a05e1a56290f622995fa9f902dec12c05ff94abeebeea3320c6a8a60c067f1e180ad67701ae45232c36eb1fd5be40be10a0050ac53b64de129ecce4ed135c3db820f7e2e019d2705fb1bdc2503d68ba85b3f59e3039bb9eaf8c2bcdfab7e88c867b453682721310694ab5f5c549de511e884b0119cad18662df0aee11b203e61fad4605ed6d5eec0fdbf82585a2923d8b6d0f32d3357a92ff5ec4b1d87474e38e5b37cdc323bceee9258fcb2eb6fdde208dbc7983e8136389ed430c3cf46fb91e6f116a40bcb99f9bb703b1f8a82caf8ea39c20e015245f167f4d3fe93514efc4da3b2391f1a3f83a25153fc8ca1469876e8fdbfa08f3209525232a4ddeaa393a44bcf0283a01d954394754b5e37e996b27a858a404d4c86c4bad81d7db88b2ab38a17e0c4f5d91964a8bc3d6e0af68aa27d8c453216612a6c863f2116b077861b1cfffe432ae7c1626b8bea0ae1a0ba3c8ededfd9345b80fb553c366ddde672ae4cc2ef86f0b3aedffcbd0013c81c947e4e955cf278d0631c1615b480ee22b82b90773e8a49284d22204a9b6e7ebeff4d3e4d83221321230ed9609316ef5fa706457d1dc83f4dcecf05d0ae1413201acabed654d08b2eb4530a953f75ac96d8cce199d6ceb55506e3285261361f95b8dd08f7367686fa37f33af37251139e0925df2ceb80aa0f939a634dc5d150e2fb8e53a52c27f28dc551959648e5890aa65b01d995e52f76a9b2543e46cfad46c5759bbf1c0b334568251bc3c5d979afb474ce4b074d96b5f2136f62847cb4f4824edefad739bf7f362f2661c66983bc6b9fec4dbf65890ffc136367549df0d0f940803900524721c2644666705dea4c4e0122b672d82d0b4c3efa1796490bf70ee786e27bf6119574bf08fd27a95df229b56137e7033dbc5b8de35804ad06f9c35048a04e0666a56ef1f76375abded0704338b95f3d36c8be0a6ba6b71f5726347e426a3296568dbaa350575922340f7641512dbf9a1f52a8164808114b10b37f638bb8c1327132dcf25cd55a9f81d329c5fe4d6251f97f66d9c415cc7c487e11026dd38eb94b685ae938a03cb05f5a0c92cff094ce60345a100fabc823998faa6b45994eb5b6f2465553f6c6b6ed2dd7dd38b34242c05e8984ad860ff29270334a36ba86e663abda304ede21b18a5d67f4105851761c69e1672ad2cebe0e096c8df30c4f2b1784b2187540675a2c32283cff76f3d57246fdf4d8eefbfeba6c5107e4b02ab5a74cd53fc0f7d286ce431a284d794e911ad2aee39cdc1619c0401732398d6dd073b6c32c90fb4dbcf4ccdf9511f8a5c1f326d07b1dfcf55b0a73d2d87afee87220919a21e968bbc4a35a3969a1ee5cb69255a3d206fb11b6a1fea7b9ba4ff901d71681f0c0cbe61dcba20bfbdc0fd9091a99680d25946a3283e30eb6c3dcd0449ae35dee5cc75648e07cc59b0720fc9d049b94ff5edb3afeea4d04681a6d147ac78cf3798f1ce9413866dcd1084f28f33d3185a92ffa33f0d481c781015361e6bf230f2a5a03f6e3fc4065c015598a3df19a2916b42ceb07fa77c677b512bc2d93d1220ef1efe5274e73edd6f4c4cf42f6b10a0cc6ffa07f4194e7082132629e943cb5199a89f22caf974a1e651461ddc992637e0cb92840aa1ec0d8dcab313b5a99df06b4e2ad9b8c13a084938354738a8230ffd19d5a5d7f9bd8e63434c9ffdc01c0a7b0399c16df14f24ec90908293b212c7f391961c0b438a1cfbb5e25eff9de3188877547ecc509e192e59cb9b654a120c667e49e2da6d46c5567ff28804d33f65ace6a326c79cf9b79f955f746eadc95a56368c64787ae271aee9eb24d2c8388b1db0b34f1157579ff886a76cf7cbf13167020500e3458ed167b1bec71308610fd55ea610f32792a09ffcb7c997a29fb633f7d84e3f4d720154f45c592606f1d44b18520d15485eb189e551eb9965693b54cef339fff9e922284bb7dda21bbd32d213296e53edf486407290112b7c3649143a5e9d158d70c1d5eccf1a7c63d5827c8c022181c3575261827f33eabda2cc3cdfcd1991d2f433ed02d747ffb4f06663d1aa69872dbd7b978cd9fd69844776a44ea4a1771bef5a1f8d59580cac85e422e8f1bfa7a2d15c131945b2e1d69256c95347a1147f5588cbdbb383314c8f3a0dc6e84eb94ca586670e9f0a89015e2fa9f3e5fb956129bfb8f5f0cc91435e3036b4f0b8b37957ec2404d9264e161904cdf5545ed8852f2fff06e0589d901ad39a8a9feeda240d85b31d54c60faecfc3c4bafa29b0cd213b99ce9cff9ab61c25a2d5688526d83be4b819e2a85bb7aeee350b60edbd9363c3829b07c27bb244d94ae8494acd2952459b14f3fea2bd499b36db5e66faa5359339dffa005c645d69562fa5dc4a60fb9e59b8a8218197389fe72fa5275e9b7c2604c3874c5499b28f2253a1362065ed682b13e3ceee798735e172d4ebcdc8770087533376e984060672bb73da29b9accf1525cb335e75f99ed37989a610e7a37342536a95cfc86132cdb623f7822c7e3d3946c2fed3d1115114b1908a8778c22c64a56d4288f7d7e9501efe2240f34591b617c453942aa16a571a43abe2dc3b3270067607d721ccee385827e94bbb382d68a3d824065041dafe41d02ec253a8284b70e8468449255d68e5aa932143455bfc56f23ebe35967941f668d19b6fda38491763ac4cf345aae5af5d3683b55203f0db72172d737c16e7981aabdb311c9fc722c3b7c5d8cad31145167e71c0cf555d754e135e2b01ad73ce27b191c86611fd75d503c5c6feba291d6e7b565dd596835cc857548cc1d9e9670e54dfb262217a0529c930a45294727ef37be0047705f1d60f4dbf95925b572ee4e43c4a636b3fb827df95cfbd3de7a548754b8b6c72a8c059802e2e63394603e9837e0d5cab3af71335f1a90d9e165c181db82c129f6ba972d9b3e37d55ab746f36c0bdac68eedf56eda6f22dc926dfaf9648e03db460191917ad4d0e5dc9cf89c38cd090190e6d6db5e619cb39f040d5276fb919f78ccec0d6885330eed8056d3a38fde8bb1b86096c475306957d054d5cc6f0a6f979430d972591b51b6591abea63bf4ae6698522abab70ea93cf35b15e1bd7a9a0bb548bb21bc8d143b4a736d40ec0da301905cec9cd99f87a1572df27bee579caa8b5fedba267538f1618bce7ff42538da385f6a71bad365bdce3ece37698971757b14fa5ee4d288ac78e69bb6216a8b127eaa803addc707870498b8b54f0e4cab7caf3865cc5114a6e463b78b3e65207b34417c2f965274e123dec634a318d7c4cad4936750bd506d5a448a5cabdea19c11222c9456f8a58c291259c3acf9748e06e17aa8d1e50fffaf51ba706b9bb70f9eac9d894eb24332e597529ef8c2235c4a374d027162da6296b7e3e3a90a26c485eabc5ae2953d4b26136dc28727436830dd130bc07c023390e1d9269e6face5691104090471b0e7ba69e2a2bbfa67ba982a646cfaaa645b1a5f68f9c1b96464c1b497bf2220bc2fd29d0ef09cabe6774aa23059086ee85a3626dc4969759ae227435a01ebb4b54d98624089fc4f5371335b8281d1cd9d14f6e6bdc624d380f0fa881cc118df953a08a965a834f020a6827d7d1e5c1ca3fe5bff898410d42de3e6e8ece84b27d068ef7d0274de3a25b7f6065148ca5e3955ddd5f3def5d3557f192e2db2b273eb928564b764da662c473d7036006532bee05c0ddbb887b9b459269d23ccd5ddf3477ab83a2a57c69dfd2fa9ac22c7a3445aeedb4f24e11fed99c51da758dcfc32aef81971993a5997d0780bdf70d14c609c1bec1b55953aca22ac6ab67f5e29e5611905b8b454a09d627f991827f307497ce253fbba0d5d2122a9a10e8bd102e7f94eed539fdef4822be09c92add74c831d11b90c2475a71e457b20d7d9448a02b6245bfd25e8c2989a853ccc731a8223ab68175ec12600d9940e91cbe083eae4a0cb83f61ccb706b7fa17c571f419f8a5068e4a95ea8c005275f29567347e93a2ce7f4f9cb536bdccc19ae9d27c55b10b526ae8ef5399b391462ad383f00d0e0cda3075d83bceb6b3d43e58654f700ad4595baf664e7e46a207db69300ff6184ad128c5ed23864d4b6ea6aec689c076684a938f730ae91faf8f4d3bf33005db9a5a032b357e9384a2a133c966692d1440dd60b04e789dc1dad0747e719729554c76617f83581edf1119f01e3f38803edb7c65e23556f5cb9396967135fb32c5f6b7883f06d05e2fc26cf949a45b0a1d9f9fb9bd3779064e7ec3bae0aa6e8e111fa7d901cd700ddfea77805ad9a9bd47d937979187927ce27cb91bee1486c265f53c215fb2cb37712d0c9c51105a80dd78d3854d8123242be969f4b21c58609c768d353f48af4f23a1ca2de02485c1a16c788f31fb7d6b4a73d91c31b9304709cb0bb4776231718eb10351c3b7aa6d3a5cb74ce9f519c00b559100f1258139663bbbc9e021bbb3e5f26d1b39bec00ff858329df325909ba06b2912e1b90cbdbce8f3cadae3476ac47a98a9f9ad7e0653b1eb2bda18af75f29966a349bb40a760f086abe90431818b70448e7a0057b242e1109030f6e9e557dbb0a22dfc86fb234b21d8c4d14081fddc5dae50ddfe75759c9c36dfe64bfd52dae96d428285f2dce8890e045d7a0e2ecdc9ca963a1046ff27c2fd4c5121f8e28da2146fc35965de82ee89fa37d743192dd120e99a6855f8f2ed3b5e34087d9f56d576ffdb820c1ca0356681b636abe34f4dcf38133c5c87b9a5344b69fef4a05cd086fe75b77edbe22d67eca8e2358fb67acd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"643649ba80ed23fdeeac84c02c742703"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
