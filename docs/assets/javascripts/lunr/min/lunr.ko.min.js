<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2d584a67c8d17f586ef896633eb187e94667b4ce24c35d19b757161431c7082ea5defa9f44a1dda5e1d98b9b092c8380c82e773a3cec676956dd4028d3b64c5c065ae5c197f80dd5068deb6b694b1bc8693ff263cf9114565452b916ec66d0aa1d547cb4d4d8be12609a03dc5b65fb057fdf0ec2863939d0fdbaf235c1d5c83a8351755d601269d5edf5a9ab9f6f311afedb3f122662890001dd071cce1d725cb5cc6b2226bb6c62ebff03690d3a1160ff4fb16c12a01d9dbae435bb072b4025d22e816c557477714833e935df62e1bff4aad06a9dc4f656ea49ef2ec968c47519b7c4500fb7466d6daed23789e021cf75d9e023d8088727ed66272ffc2e08377ec4f01bf6e5656a64b31d7215b2fd37fb79cfbf583518623e4868d5d919886f29e83d72fc23ccff2fd23fb5ee1637c11fd6709ec9183895b054e435441394e21a8875d8ab409d2f787f827b160921fd12a5e3a8e5b4e4d15c15d2c3bd2ab4cb77105f0d16ecd3d05640018e402982c980e96c801247f9dbb727eb71645504766cacbbbabe39c7f3384f05ba4b4c37f9e5854ed3880c5d0f714c2063941e716bec65d117a35565f6555eb2aa2e77fe288f03c85ee903fec961176bf79f6da430f32fe2eddbbf4b6c60545b1489dc9faea5400c70a382ffe018dd8f2a538f9cd87948c3fecca7cb3f835d202656251349e0f465792b4ecded92d129aed5d3c4905caa67031ab4e1fed1a2de197fecaf8612563e6cb646e889b0775a65a61c96ef0d71569b5ecd3a5ecbe41c411e45e4d228165a116902f172294364b7525d3d423e3d86c487223ee49130dee62e9fe1d2a246df9502279b1374a8238d668fec4736875937098deba8b2738f7c4fced6abe814a85c0aeec8ba6800b41a98b6540403711ac577658b3f0856c53a610f9feb4e06bb7605f8e44f8d068a2fe21fdb2614f37a7e521a74e9fc4495dd7d78292c05e59d1d520dbea157f134fec4fe1f725ef3aee603ac634e433e0006beeea1099e37820ebb1bbcbab014589f23c6c73275d1805432cdfd81d203519de0ef442a6d8dde1911b136eece4b7d48994938885142eb68da3621ba10ba7ac52a5bf86b679fed1de917647803b5781272eb8defe55560533c477740be21015d78e991f9ecb1b2f2001b4ca4508817ca1d118401c99d880163b92d2c8584d32e9394b997fd21e115c9f41b91af3551d52fe1f37b1ab3e686a56f46444de17b0209d974a6349a8c12ee488773663c890ff0acc9217e7b34f7e699b2f41159b2b86c5599c56fd236c6cb6d75c2374f45d09dd04a5ac29a5e5f1b8a745df67bb7836fbb63417841dba3a99365d88f9579242e9af0df7fd3902571e739ec59da229fb48b93c197aa118df8d91e4244a865fcbd0abea5bd826d6e5d82acaca8e6f43ed3f204c10c8fe770dd2e2548e7e5b84f23f074322da6e02e26911e6ec1b8783d9bbc433564b526e85da70ebd451c6f84468a133db7e06a82156ebee2cc4662571e2ed84457071cce7d335789218bf8b3ea91f7163202140c44cde3708ecff66760d72ea33a0374b91dd182615247245db2ef0de371fccb6634190e3a57fbaf08e64bd0d7de9c2d96247b952f47b89f5f01473c8bb33b6692b28756fc891899a270c5919faf29425eb690cc531e258785dddba513725f5f336be20e76240f22ca51682d84c2213207f19a395a084ef7d8140711fd233a7d4d14c5d7b243de43b58dbba183f087c7b3a4a706a79eedaa9dec231ff1b9ad525b7d8be88a1b83956f6abe9ebdaae7bbb8508dee021fcd822c02d0b34308e923fe05aa6b047da4116fec3de6646d7e22164159b97eb55d225ef34efa2e5ffb8a5f007b2d41d1a80bd653845b70ed0ab92294e4d5bf429a6249480d97b24bf80a0f575af25c35016eeb53cbb807582962ebf82f95a2cd4e2da5ae09158fc33744e1fa5ab1dfe5c24539133bb9ed337fc77d33066cb1d8c99e6161f79636ed5d39c9c4746441856db569d3886c4dfe719473fd758a00ee7b5d3cfea5e19251715fcba97ff8a4d8d373f8afcb720c2b9df44d964d7d42b840be9a22f79975cc1cbfb488e54455c282dcfe420959991fef1a80d53b29d42bdd235e18aa3d567d893fd611f78ed388ae92b8d30d995fdae8e9a983da719c7ed9aa1d29c24814a1d64126c182faf5706c564f36dd1a9d562bbc44f7be151d328a2e07dadbc557ced94bde9617f5dcc351a61e22c354ca1b0f66a94ed4c8eace07ef495dc43e83e3a37f0f9d0985d7394652ee9bd9c71668405f91320e8c95a50bf520b8d16dd03ac9db2c2eefeb7f54eb882a433779cbb0671c712cce7a33390a38819e8c4fcda29f3e217c903e8e9ba583d8ac2cc9fdbfa64671dc372de60bae097312374809370eec1c6e34834f23d19e61123dc20010c3e21d5deef731eb7af8b962377f6549f65d18594d8debd2dc97e8a3238d1b42ec286ca54693017f30ac88641a4df64b45e3e017e037afc6e895222c89240298277c9c086016c246d1475a773c3c7737ebead23598c1d1591820c77db44c4baed3a5cdc62f1c5c85818f09bf743956a677555951df1f206939fb9ea8e6fa83510c72a9cd847c0697c762e48440a8e2ed0e97c03669a1d1a8551e017df58db3af7becc448c6b1aa178e7780f02d56206ce60a3473febb9c404e55286462ffedbd463e80c29682fe3f11264de2a776ed8d874b8250fa08a36a52ddca20b3c0e8c342fa4b03b50a80426104bcda3ba2b2ebe8ee5a44f3226be82e7dbc391e4fd09d3fd0541d40bd78cc78c07ea70fa430bf9c2ccdb2026a774f1a50ec0f44fb3af59a317482d8d3882f518a8a9fea2b41fe4a996cd7a63fd060d6a6233f12d8dfa270a9284326659922d3cc88f1e901376238c2997c637e07ff5ab7d1aaa8f19774531a3b8962f8e386525d6cd05fe8689eb785eefe9143b0b71adcbcb30c21456266c55fc1612f2561676c9644e17f37126bf99c3f2f2b9d960a353b9cc28d182e449b7180bf0363165cba531292f058e9cc2ef3b0da31027d383ba1eecd7fde0c320c0157b14f387aa6db3ec794ab8bfd66fe608825b0dcd915219660329321f29dbfc14fcc926cb697d77e16eb50bcdb56c8f6ae1378a0db0d135445b14dc13820052ffa38f684d74c7eb3202e1358c0e01faa7b3f829eb4ce8282a771eaaf80e6e9f55eb20585f5f5a80873295e75975e216c7c9ab104d3ffd0c9f0a7d2d75ccfbee36a8f8a860e9180123282250c6b0ab8b681552ae306f5a29c3b9eaa3e081da7cf76f85fac32169ee2fab3b579ccccbdf504fe46a3075f3c6cd635e351420c891d3cec95b1f0c7d184975d1c888f490dd237dc8463889a6f50d1796945c719b8d9f4ddbd63f09e69d8b4bdea637fb04c9c081e8dc71bf4de1f5258cd61df9c764303082f3cbfed734b2f962531d235b03d2a4f25f5c9cb2be08f8a230235a2a5d0db41b7bf3321979df0b8187e95aae41f87c1fd790fda207e79fd8f291ec2465b5cc60f658b397b78bcd9493b09d6ad65a3c693f02f6601335a09514a4d39a19e7ac19c560df878cf708ac31666ad81dfe06c338cbbda0ffe4339483b17fdf45812436667eb86a480d36a9efe83864082e2474393fda6a62fa94ccb7ec13e4de312507f696a4e114b6c510bba8c5b44c6047d8fee623885398a322be8507429efd85a47f623facb174daa7c9611f698b1e2d58605f6722eda8e1fe8559b410908bae0f9224b1b2a7a44116a04458337486c7ab0527b28254c1c356c918c20d71a898c816a23752150f3b5c754f5943d6260ebc6a570458e9b0aedbd217c68dcb2f777cee3acdc9a0ba113d62fcb6b731b27eb9d52256f747022bf10d0531cad6ba755cc8a4ea3761c5813d2bc19749c31eeebea0e11bdcccf18eca5a3d2cd91fdc9e38f238adeb856566d8cf247a98976a818c00a23d09cb9d47a389aabe44e48864f9a06c3a6b1a651a32391b3edd19f9797a5b3d1e9a9e333d3653cc42737ada1abbbff82a369e6fc167ece1277e114373ca743b70440ef64842e34bc7cc6a571901d0930e125a48cfcaab62839874315d988925c1d68dfafabfc404c397bd2d8818ad805872ee1c3f18c556d74f9a54c95e61f5fa623264f3e123f22ac766713c6f36c03ad87b5258cfb64140016ea87bcdc4486acfae07e9fa4d6887d10bad6edc4c2080cff7043bfa79eb8ead9108a7ab1a0fb3ae6036ddf324740c1ff586395b79d229623c48248173a7e6bd8b405354b96b35b7ebfca25a6a268697b2de487becaa6d04aa6caff231115243a4c28edcb9486fda514f4d969dcca4fde6cd17b74ed4b552aa9b9a757bf8fa89ce33b88e767c77b789059ebe73bfe801a75fead484a0ec61d5d94187b2be44d85d0dab6df2dd6774561e980bddb79e6f242a944d8c9743516ba0d095f0d66f31d20e387755bb691f82ed0bf824925ff104a2eb143d6ffdf406cf5e4369e533044792fffbfbf7eac6100fcffa2590c69455a0bf454849a593937b0fdc0bb05c3df227c57d6c3c64ffcb30177d09c8118151badf7a7c0ea5e9d0d028dc4a8ee246f753e6453635cd837c87fa7ec39801ec66777f1bec5d1ebfc8d65c31aa66681c855b3806acb1c684c67ec0fdd2c77cb2fa94a1dcad73dd3e96d11caada3dfcc6a094d4c34b5f957f127c5f1726cd55403efaed2a0555fbca6c222a85a9b956a2db1a8f8e533338ddac32d004f5a80899c845dafbd87a7fa63e23d6f8191bbd9cba8d871e19ff199861addc7a50b07acd52383605efab61c2fbb5ed0448e83efd270ea4ab4a0abca1c841f3dffac60c25ad6e3aba36ebabd0cd15d7da79a61689c4248434d9f024d34ff6e3880bd8c7ab65c0cc319620ebd76ed2f030e92df3e89bd3d579ce48968fa8b51889984de383311527e6faf83795233f36c0f4364b7fcb179cc479c9ce51032b25dc71ab76e302790500c5a6989965faa8fc41c0315f80fb20598f5e9da57a9ab22d0019a5fb96805990c2add4d12af8ff9d35d7997c73b948b246f8ae605c56c1c25851293cd0e1084c8468144450ff98e5e40c64f1d419f0d3c478226216a542928735956072bb124dda3a9ff5f7c17a9cfaf629e3dbec5b0807149809566682561932c0d51a1a60994670fc08bed5e1386be679e92681706365d7c5ead3928654e605beb6555e5bdaefd687d67f6a636cb890ade949232652efb18185ea6a9a17fc6c9ad42784b3d8d32efcd566be9c7c5b51b8a9fa364801683fec7483c6a745bdb338faaa59d143727980db569bae06336479bcc5269a362ffc0fbe6591dd40f8dd95f79d81c9281e89e5d56c011c76e8667613166c429a29bed266ce9e385c4a3499d6501144d3cd0da28d3d0bcf966904b0f2936e4dce666721ff39ca413c2a3a0e97fb628b81f6d89d4155ca7389ff1d365595d3c31dc705bcfee65052b0b888029b40f8b1875212e82014fd054835db14ae6679acd8fcf9c544ef259208070a625518e00d75d9492c93f6076a364c8794229f2d3fe41bf257ac8c07cbf3dd25c7a1d6f5726bf5719c44066bd09f4d04277324bf94b6237bb4ea4862974e60614342cb11d4c8836ce18f330b7cbe727b1ebbca9e94c5f433b6d78b843c76c6813daabac1993b1ef1147f213954d835a09f1d73e3b1ec5ae805ef8d5ac0e193d8f1a94184c27564435fad9101a8e0d8401f8676f79b402bb7b0d462845a52254926a02430019fbac7a73b05cd091e8f3da9114ac71172244c41af567f15d18a7113f7a842650421eda6611c70d8b4148e19c4bc5bc66dd7855efb4dae3d8799fccfb1652672f2b5d8b3c1de7ea35424fdcc3eb552716636bcc31f419124bd744ec01aa5e7c3b5507420567be402b7384491be15c3d82d757eb47a595acb712cd6a4f63f386eb21592909da819586e36fad8cd5bf6a4883d0b822ff0262e97254a0828386cafe2c9f1c0425ef056e97c39e95bee445537756de100d78ab0baef5427138cc78ca5a1b2f4e0a1567a2ee4a1ae222b5147dea9cffe20ece1a00161b02f268940bc13dede6cb05a92594de909aad7d5a5c61ea0114d49cb8d2d3eff5dc8d1ef00f23d624d276d4b81b65a1889b18edcaa5a64635a2e38f4983e1fdf1af23056910317e768a6303b52090623e891aef4eadb2ba6692b495c52db0bdea1e053728dfc95e00cdd253346fa2f92f714119854e6ac807568e76d92df8dc81da374d64260443bd06967bd91dbc219d76e2610f05200c76e5a17ca0aa7143b46be90be7b3261d368ecf397da87704846d05c58f2e865b0dbada57f96a3dcef3dfbd95e3192aead0e4c1d9f20874f2c116370863195da1558cf83453a1491c240fe31acc27b2c1206814fb37df8d33402873aa633a0415e0ff7eaea5a69f585407cc83a2d5a3adf194ad553f621e7de15d69a4353327eab9fdbc75f64c024ed011d12aa13dc777b71a8338043fa9ac53bd8705e968c50a56ddd9407fdac32b1892253bcc6cfa26baee201dd4b24b849ffe6e9cc90c787499876078f91f090fe0d11626870517993ff370d96e62c750a8b44b2763d503dfc85503669a76f800e1bdaa41e4c68ef1ecc42975fddd448dbb7156a34e32abde43eb0080f2b1fc77ac23a5e9e300cc87d8f2309f5a38b4c673b925e6303f320718e1d90a24735b9002fe3f7fbebe9c3437f5be9105b967ffb284b3944104903c3cb64d30b77a3832f222aba18c2b7dc9743840121359fd0c2a79304761aeadcdc42f9c9939db77629ff3691212eb9f87f40498700e80ed9c4ae90367ed700d8ec1304128ce57e1ccb5b1cd463484e2af51d72d091639ce26342ff95c3823c9d9bdbd3b3602831717cc22e88e32eaf0453ec6fb5158fb5f9f09bb727dc3f623f293e73bd78ee45db93361e9af1b71af11fe731da0a3e74ff2247cfb850570f7a1baedf05192ffc0fcc658ef2f1d4822f18166212198946a58d8c2dbd9db44d4a4db7fd8c6e2cfd7fe9e8660306f1847a372fa2549887150c701dd72abd9735f220a54d6f48baa86140dc4cdc976281971de133d752cdd4fce6d9fec5ac65750e6c8c70ae958eaac3418da4fea43e68011c9e6a56684a576d9d32281095f962e79ae263f6c522caae9ae0aa5702ac471cf86c44c99ef18b931eb0e8e33fa748fd767d0ba8f2d114c439605d69370c6db6ddf96a5b2cd8bdccc7d198f23f1e1f6acf8bd0985f2d44c9485b161068a0844e6c0d85e375de30a23be4de17d407e0b5a44a7f0dfe092bf6f34a355f830137fbd69f9b3bcb3714488b59841ce23307b6ada07e0392d1ceff50d4a940fc53543c0eea8df85b8fa8fe749561ea18d790f84b21ee4ad1889cca2333e419737f58e9b3086cea3f519c1ce8dabdaa2b009244d997dbe07d89f92bd20c3de06de516548953bc8fd49e921e69c4462f9a0da8abbb6de834109d12163e3819f65ecd7b89e8fe02f2f2e1e46ad77881a962814ba162522c6fa34098626175b533ccc577849c740b3500352da6cc96982571444a521ff0fc57c4dccd5d1f40b4743d7cedb4615061fb36e95ab4c11ba1515d9bcb9c6d58d9a0fc869073cad8240cb344141b004a773e89cc936dc118c7f1351a194c7b73c05054c4dab841972363b4bc6a7d5da802d4de0dbadc73e9c59c6a81b010ba99cea3d805e63bf2b80c85c92d25c060999ab55341d042dd07375b980ad520518c02ca51786954497965bebcd6c3bc2f99dcadff29804384ea492a3cfd96f3e0bc21be582f5e59bde7fbbc84f01e4c652910ac2bf71f67d4b7105348e3c4840eacb2702f6fed5986c96a2324bdcbc02f215db3066f60476ff27bd08339c8177b9cd1b16ca999a5495dcefc30e744cb2fe9badbee3d885cb199eeeb7539d2c16e17c62dd174be872897cefdfe445a5ae7632f2953c5426b68a5d9837583cf8be2218f1e28b4b02f4a1402c184932b514b3d043b55fca723be1c8c2f8009eeca07bc3e978a4d058e6772740a72ffee1a0d35608d9fb5b3b90055d96a30aa046e5e133b53b9c04a41896b053b9e3edbf6c2b1f9d2cacc2f07d5c2efbf7cdf986579b9baff615751f18bbd3c4da48f4d28e21c3f168bde1e33cb4bb646bc7fd0d3e2efce400454beb1ce972195ccfb131051487ad00856180bf0cb91fc7bd4610ed835d71f3e122cd35d4afba26735300620832cd542f1c06ff9e66f10ccc2c35946e5ec6fc27a63795827aad878bdfd24cb7edd8e424dce39eb3b1577e8da25d95daf6dd64bbe544e52525c31c1453d1ec3f06e91cc7f0079abeb6302237f54ef4c2d687dcdb8b327da1e21807e074d64dd895446634ef2dd87b26c9e3c8d5424b21efebc90d6d111307f3f9f8154972a658beddb97f9c40c42c56bcf143244a7f846d92c1fe6f9ac133df78be6231d8285d65cae41aca0e986de0dd4254c466cb3b95670a511e1da15c29b55f407c4dbe34df83133b585738acdeb76c10631025fda1f6ed7d96609d3d79ca5004403b76a39753510b0085d3fa92c8a4a9b711cb4069cf06a67953578cd8dc8efab42e6cf40c045bb301822cfab0a1680ddf9e379064976f5cff18811e3334b8ab59602d0e4eac8869e5b4b07e1d8598ff09e5df23968c3f56936a5830eeaeea17533035eabbfb50e34951cdcd7957d6fefa874351f847a6fe2ae450fde01abe34fb391f0092224c8d1b44646f864403b852ebe432d72b5669c19d69d75fb6f017815ccf5f7067db172c10a01db45536703383eafa2a66422c4bf1ecaa845dec888f93e1fcb031c88eb0b4b095379e5ec8c42268ba8cca3848109ca45616743783ba667536e50701f75d5e9edef20f9ffeb8cadf86e3cb2a0860895b86636c0d60f03ea9fdfca32751700e78ec2f411170ef1dd23d5d96013d49fd64bfa2c5359f8d1c05e4d92e92b2a0bdc450b1f838e70b1dfe074043c276f53345e96e2c303686a8bfb9742a9f7c68020061e9fdca6a91b2f099d30ba01bca4a49576b0531afbe265fb9915bc4018e268ad33965bd527bec0337e5680379eb368d7a0d1e996c21ba330ad86522f51e5f2d1e34dffa0842049a23a3c20a3498aa10b4956da92757dcfa4f8436310529bf5b96ba57c3aadf9b8540a146c4bd0fdc273e187cb81c6ac52b20c225ce98bc55c0684b8b6f80b0e211479e4370602e87c9834c852542c37de77788df82e35107fd9a9bd5b455744d040161c6136f120442b81d9006a3e66877b4c053e85a3a05aca9853a5b684f045b4350b070fea1e32eeaa255af0e03335c889af8c718ebd2d3a3e1d0da9c79f4ecc8cf8e31f683d5a18e45c2ef405ea9cb77bebcfad9156c9f8b359ddd97d180484f445c6993b7f80f5fe46ad2ec67401eab06f09a74c458d5583172ca84da6f11be55ba5f6f6bc0c566763e6a5d2a5c3e4c794961d39ad5bc4caf26f2f2652e62815f715e93d4c7d29b4cd2e7435cb5542fe936fc563d9a22d4e3ec1bc41f5683ed2e6769ff4addbcfe30a88cbe77b7f865aebaf332329ba670acf16c470be4bf914cdb95f6beb1a15f5699af4c390fd07281168f645bc4d811756ebdd23c9a00f1910b5ba710cd2e85c99e66d35511434b3d32812c45135dac8fe55fe18a2a9e9bb3e9a339442b007ebdf9bfe1b19ffb9f8600ca8927035fb8bfb91c97a8684d24b70fa2b529e6b73abd26f88c2d7fb626075b274eef089db262f99b2c1dd97634cca94b78b27cdfe44232c33a6a0a6b4315fa68dbc64da4a2db6d3e730567c63afd0b1034582d2adb42a512fdb8ae86a8932a0c597a64dc1cf7f2663708e83c0fc09317125eed3a235a19eb2a645b7b9e510330e6772e815eda83f5a6434f94d8be0115763edb9746ff68416b0da51b4d476714f165681f76a756ea209ebd0fe024b72d9ee2b50350ce82a699211bfd32b8871837a760452a1eb0fc40fb650d6015d31b069e788226e4898831a3b6a121512c536fe499e7348d57c4699fddacacf8b0b2a2b74525d22920bf78fba2430113de17043eef64d463748e98352b6671f3336333f896bef60109f1f5a9db92f798c0c9d39c8f883f544507bb67c6a464950cfd612195f8a312d44053ae420b632cd93eec550198a0ad652780c1e46aee03f57fad9d02f74f028edbd4b1c859100a2baed513a69e4c979e6cb34f0fc2be1edf6c1b3f3b8bfdb87a29820e71a6e97cb95cb54f4d490573e8af8d28f8be2040fc81814e291e0b3fc21e1e18f0c134fb7e9ed0d4ab5a2d790670d6c9eb551b3f7bb17dcbb23fa5ceb5a5f2312eaddfd739d76c8aa0dbb1f647219027b96c72c0c8ea5237dc1cb3e0636892c8634829422bd9ff7a8ccc515f0889b64b881a324cb593e4faaab19448c3a308d99363dd7dc666e8fa9d0b723bc456f742b4079542ecbb1bee7d320a5c3cb626689173eb2aa07ba2efa99ab380edef7d12bebf28bf4b32a9fc3eaf0c28258a361fbfa397391834b274d18900190570eb4c9ab3653b7aa160de71eb83f9ff02c3b1e6db9f3d57e14e420f45f1a767d57cc60d379f4890c6569e847607ee221e0445914d1471a4fb1ee9f216f6033a49ddc244ebef4b1500f94eabb9310cc24f4eaf89f7d8a9a3d18d0105b3274889f83f65622cd83bf8accefeb5352700ef216b0c28616e2bc075b079119a5f7220789ad769143ba25a86ff4fb4c6d7d204cec1955c4b5e875a608c8e0aaaaff2e3f4cf4e74f122b4df91c0db094862dc6d6fec9b3425489d66bf601200b25d458966173110af08ee88cde04df1b370f5c8303561fbc6fdb15b89fab780e2688968c76185147ab941bd358cb66aa00481f6593cd8b5d53d32c67bf0847f795359b1c1861480b83197982e109c184900a1f64ed919f724f85751cdbd8d90ba6f8a363574c9910f3f7dade37f5edc2d1caf6dc2faad4bab6aeef10aa6c1d48f55138286f4189a4ecedd440197754942cd3a2dbc0c685f914b5d4cbc06cfa1e9dd0041c3f8bc983db1017297dc8da3ce0ed49a3f319b79e963f5edf725ca9805f0adeb34a00bc94ab9362f2271ba6d7b95e99d5f9bf3d35a8ec3b156efc797519191969798b63eaea03bbed610e591c7b9d6c9d599eb0f78240814e1b82c2845df23e580c9d61997947cde91801a3485c1d45d25dc5529f1a3332a07aefa9ec5d327caedf5d0aaa955abc54dee271f818b8c0cf899d999c1d4e666364a51a4d7bb61a48f4149dc32f20987a95948e1ace4c5175c7635a71ea8f49d6ec5582d020cf0c7d246d41e3b171eb58f8c9ab04e6cbd8c20d585f90b409f95c372bf5a80f63f9520f7e36250370b2f22796f5fbf40e1e1c1011ab2d8bc35b158812f362afd9da0e3651d720366482a941b73beb65e10f5afdd70926d25c726d28b37a98e50","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"643649ba80ed23fdeeac84c02c742703"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
